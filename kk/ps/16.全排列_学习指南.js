// ═══════════════════════════════════════════════════════════════
// 全排列算法 - 完整学习指南
// ═══════════════════════════════════════════════════════════════

// 📌 核心概念：用【递归分解】思想来解决全排列问题

// ═══════════════════════════════════════════════════════════════
// 第一步：理解最简单的例子 [1, 2]
// ═══════════════════════════════════════════════════════════════

console.log("=== 第一步：最简单的例子 ===\n");

// [1, 2] 的全排列应该是：
// - 第一个数选1，剩下[2] → 1后面加2的全排列 → [1,2]
// - 第一个数选2，剩下[1] → 2后面加1的全排列 → [2,1]
// 结果：[[1,2], [2,1]]

function permute_step1(nums) {
  // 📍 递归的【结束条件】
  if (nums.length === 0) {
    return [[]];  // ⚠️ 重要！返回【一个空数组】，不是空
  }

  const result = [];

  // 📍 第一层：循环选择第一个数字
  for (let i = 0; i < nums.length; i++) {
    const firstNum = nums[i];  // 当前选中的第一个数

    // 📍 第二层：获取剩余的数字（去掉第一个）
    const remaining = nums.slice(0, i).concat(nums.slice(i + 1));

    // 📍 第三层：递归求剩余数字的全排列
    const subPermutations = permute_step1(remaining);

    // 📍 第四层：把第一个数【拼接】到每个子排列前面
    for (const subPerm of subPermutations) {
      result.push([firstNum, ...subPerm]);
    }
  }

  return result;
}

console.log("[1, 2] 的全排列：");
console.log(permute_step1([1, 2]));
console.log("✅ 预期结果：[[1,2], [2,1]]\n");

// ═══════════════════════════════════════════════════════════════
// 第二步：用图解法理解 [1, 2, 3]
// ═══════════════════════════════════════════════════════════════

console.log("=== 第二步：[1,2,3] 的递归树 ===\n");

console.log(`
递归树（逐层分解）：

                    [1,2,3]
                      |
        ┌─────────────┼─────────────┐
        ↓             ↓             ↓
    选1       选2           选3
 剩[2,3]   剩[1,3]       剩[1,2]
   |          |             |
 ┌─┴─┐      ┌─┴─┐         ┌─┴─┐
 ↓   ↓      ↓   ↓         ↓   ↓
 2   3      1   3         1   2
 |   |      |   |         |   |
 3   2      3   1         2   1

结果：[1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,1,2] [3,2,1]
`);

console.log("[1, 2, 3] 的全排列：");
console.log(permute_step1([1, 2, 3]));
console.log("✅ 预期结果：6个排列\n");

// ═══════════════════════════════════════════════════════════════
// 第三步：【带注释版本】 - 完全理解每一行代码
// ═══════════════════════════════════════════════════════════════

console.log("=== 第三步：代码详解 ===\n");

function permute_detailed(nums, depth = 0) {
  const indent = "  ".repeat(depth);

  // 【递归终止条件】：数组为空时
  if (nums.length === 0) {
    console.log(indent + "📍 递归到底！返回 [[]]");
    return [[]];
  }

  console.log(indent + `🔄 处理：${JSON.stringify(nums)}`);

  const result = [];

  // 【关键循环】：遍历每个数字作为"第一个位置"
  for (let i = 0; i < nums.length; i++) {
    const cur = nums[i];

    // 【提取剩余元素】：删除当前元素，保留其他元素
    const rest = nums.slice(0, i).concat(nums.slice(i + 1));
    console.log(indent + `  ├─ 选择 ${cur} 作为第一个，剩余：${JSON.stringify(rest)}`);

    // 【递归调用】：对剩余元素进行全排列
    const subResults = permute_detailed(rest, depth + 1);

    // 【组合结果】：将 cur 拼接到每个子结果前面
    for (const p of subResults) {
      const newPerm = [cur, ...p];
      result.push(newPerm);
      console.log(indent + `  └─ 组成：${JSON.stringify(newPerm)}`);
    }
  }

  return result;
}

console.log("执行 permute_detailed([1, 2])：\n");
permute_detailed([1, 2]);

// ═══════════════════════════════════════════════════════════════
// 第四步：化繁为简 - 原始代码讲解
// ═══════════════════════════════════════════════════════════════

console.log("\n=== 第四步：原始代码 ===\n");

function quanpailie(nums) {
  // ✅ 第1行：递归出口
  //   当数组为空时，返回包含一个空数组的数组 [[]]
  //   这是递归的"基础情况"
  if (nums.length === 0) {
    return [[]];
  }

  // ✅ 第2行：准备结果数组
  const res = [];

  // ✅ 第3行：循环每一个元素作为"第一个"
  for (let i = 0; i < nums.length; i++) {

    // ✅ 第4行：取出第i个元素
    const cur = nums[i];

    // ✅ 第5行：【核心】 获取除了第i个元素外的所有元素
    //         slice(0, i) 是前i个元素
    //         slice(i+1) 是第i+1个之后的元素
    //         拼接起来就是除了i的所有元素
    const rest = nums.slice(0, i).concat(nums.slice(i + 1));

    // ✅ 第6行：递归调用，获取rest的所有排列
    for (const p of quanpailie(rest)) {
      // ✅ 第7行：将cur放在每个排列的前面
      res.push([cur, ...p]);
    }
  }

  return res;
}

console.log("原始代码执行 [1, 2, 3]：");
console.log(quanpailie([1, 2, 3]));

// ═══════════════════════════════════════════════════════════════
// 第五步：关键概念总结
// ═══════════════════════════════════════════════════════════════

console.log("\n=== 第五步：✨ 关键概念总结 ===\n");

console.log(`
🎯 全排列的核心思想 - 【递归分解】

问题：求 [1,2,3] 的所有排列
分解：
  ├─ 以1开头 → 求 [2,3] 的所有排列 → 1 + [2,3]排列
  ├─ 以2开头 → 求 [1,3] 的所有排列 → 2 + [1,3]排列
  └─ 以3开头 → 求 [1,2] 的所有排列 → 3 + [1,2]排列

💡 三个必须理解的点：

1️⃣  【递归终止条件】
    if (nums.length === 0) return [[]];
    → 数组为空时，返回包含一个空排列的数组
    → 这样后续 cur + 空排列 = [cur]

2️⃣  【提取剩余元素】
    rest = nums.slice(0, i).concat(nums.slice(i + 1));
    → 删除第i个元素，保留其他所有元素
    → nums = [1,2,3], i=1(数字2) → rest = [1,3]

3️⃣  【组合结果】
    res.push([cur, ...p])
    → 将当前元素放在每个子排列的前面
    → [1] + [2,3] = [1,2,3]
    → [1] + [3,2] = [1,3,2]

⏱️  时间复杂度：O(n! × n)
    - n! 个排列
    - 每个排列需要 O(n) 时间复制
`);

// ═══════════════════════════════════════════════════════════════
// 第六步：互动练习 - 手动追踪
// ═══════════════════════════════════════════════════════════════

console.log("\n=== 第六步：📝 你来追踪一下 ===\n");

console.log(`
题目：追踪 quanpailie([1, 2]) 的执行过程

第一次调用：quanpailie([1, 2])
  i=0: cur=1, rest=[2]
       调用 quanpailie([2]) →
       i=0: cur=2, rest=[]
            调用 quanpailie([]) → [[]]
            push([2, ...[]]) = [2]
       返回 [[2]]
       push([1, ...[2]]) = [1, 2]

  i=1: cur=2, rest=[1]
       调用 quanpailie([1]) →
       i=0: cur=1, rest=[]
            调用 quanpailie([]) → [[]]
            push([1, ...[]]) = [1]
       返回 [[1]]
       push([2, ...[1]]) = [2, 1]

最终返回：[[1,2], [2,1]] ✅
`);

// ═══════════════════════════════════════════════════════════════
// 第七步：变种题目 - 相同模式的问题
// ═══════════════════════════════════════════════════════════════

console.log("\n=== 第七步：🎓 类似的题目（相同模式）===\n");

console.log(`
如果你掌握了全排列，这些题目都是同一个模式：

1. 【组合】combination([1,2,3], 2) → [[1,2], [1,3], [2,3]]
   → 递归选择，但不需要每个位置都选

2. 【子集】subset([1,2,3]) → [[], [1], [2], [1,2], ...]
   → 递归选择，但可以选0个到n个

3. 【N皇后】
   → 每行选择一列放皇后，递归处理下一行

4. 【单词搜索】
   → 从某个位置开始，递归探索相邻位置

所有这些都是：递归 + 选择 + 回溯 的模式！
`);

// ═══════════════════════════════════════════════════════════════
// 测试
// ═══════════════════════════════════════════════════════════════

console.log("\n=== 最终测试 ===\n");
console.log("quanpailie([]):", quanpailie([]));
console.log("quanpailie([1]):", quanpailie([1]));
console.log("quanpailie([1,2]):", quanpailie([1, 2]));
console.log("quanpailie([1,2,3]):", quanpailie([1, 2, 3]));
console.log("\n✅ 全排列算法学习完成！");

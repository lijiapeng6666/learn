// # 最长递增子序列

// ## 问题描述

// 给定一个整数数组 `nums`，找到其中最长**严格递增子序列**的长度。

// **子序列**是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

// **例如：**
// ```
// 示例 1:
// 输入：nums = [10, 9, 2, 5, 3, 7, 101, 18]
// 输出：4
// 解释：最长递增子序列是 [2, 3, 7, 101]，因此长度为 4

// 示例 2:
// 输入：nums = [0, 1, 0, 3, 2, 3]
// 输出：4
// 解释：最长递增子序列是 [0, 1, 2, 3]，长度为 4

// 示例 3:
// 输入：nums = [7, 7, 7, 7, 7, 7, 7]
// 输出：1
// 解释：所有元素相同，最长递增子序列只能是单个元素
// ```

function longestIncreasingSubsequence(nums) {
  if (nums.length === 0) return 0;

  // dp[i] 表示以 nums[i] 结尾的最长递增子序列长度
  const dp = new Array(nums.length).fill(1);

  for (let i = 1; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[j] < nums[i]) {
        // 如果找到比 nums[i] 小的前面的数
        // 就可以接在那个序列后面
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }

  // 返回所有 dp 中的最大值
  return Math.max(...dp);
}
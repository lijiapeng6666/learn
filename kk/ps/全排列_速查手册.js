/*
═══════════════════════════════════════════════════════════════════════════
          全排列算法 - 一页纸速查手册（打印这个！）
═══════════════════════════════════════════════════════════════════════════
*/

// ┌─────────────────────────────────────────────────────────────────────────┐
// │ 【快速查阅】一分钟理解全排列                                            │
// └─────────────────────────────────────────────────────────────────────────┘

/*

🎯 什么是全排列？
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
从n个元素中全部取出，按不同顺序排列。

例：[1,2,3] → [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]
总数：n! = 3! = 6个


🧠 核心思想
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     【分解】大问题拆成小问题

     求 [1,2,3] 的排列 =
       ├─ 1 放第一个 + 求[2,3]的排列
       ├─ 2 放第一个 + 求[1,3]的排列
       └─ 3 放第一个 + 求[1,2]的排列


📝 标准代码（5行）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

function permute(nums) {
  if (nums.length === 0) return [[]];           // ① 出口：返回[[]]

  const res = [];
  for (let i = 0; i < nums.length; i++) {      // ② 循环选第一个
    const first = nums[i];
    const rest = nums.slice(0, i).concat(nums.slice(i + 1));  // ③ 删除该元素

    for (const p of permute(rest)) {            // ④ 递归求剩余排列
      res.push([first, ...p]);                  // ⑤ 拼接结果
    }
  }
  return res;
}


🔑 记住这3行
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

行1  if (nums.length === 0) return [[]];
     │
     └─ 为什么不是 [] ？
        因为要返回"1个排列"（虽然是空的）
        [] 意味着"0个排列"，那就错了

行2  const rest = nums.slice(0, i).concat(nums.slice(i + 1));
     │
     └─ 为什么不用 splice ？
        splice 会修改原数组，破坏循环

行3  res.push([first, ...p]);
     │
     └─ 为什么要 ...p ？
        p 是数组，...展开它
        [first, ...p] 才能拼接

*/

// ┌─────────────────────────────────────────────────────────────────────────┐
// │ 【执行追踪】手动走一遍 permute([1, 2])                                 │
// └─────────────────────────────────────────────────────────────────────────┘

/*

第一次调用：permute([1, 2])
│
├─ 第i=0轮（选1）：
│  ├─ first = 1
│  ├─ rest = [2]
│  ├─ 递归 permute([2])：
│  │  ├─ i=0: first=2, rest=[]
│  │  ├─ 递归 permute([])：return [[]]  ← 出口！
│  │  ├─ 组合：[2, ...[]=[2]]
│  │  └─ 返回 [[2]]
│  ├─ p=[2]：组合 [1, ...[2]] = [1,2]  ✓
│  └─ res = [[1,2]]
│
└─ 第i=1轮（选2）：
   ├─ first = 2
   ├─ rest = [1]
   ├─ 递归 permute([1])：
   │  ├─ i=0: first=1, rest=[]
   │  ├─ 递归 permute([])：return [[]]  ← 出口！
   │  ├─ 组合：[1, ...[]=[1]]
   │  └─ 返回 [[1]]
   ├─ p=[1]：组合 [2, ...[1]] = [2,1]  ✓
   └─ res = [[1,2], [2,1]]

最终返回：[[1,2], [2,1]] ✅

*/

// ┌─────────────────────────────────────────────────────────────────────────┐
// │ 【对比速查】常见错误 VS 正确做法                                       │
// └─────────────────────────────────────────────────────────────────────────┘

const compareTable = `

┌──────────────────────┬──────────────────────┬──────────────────────┐
│      错误写法        │      为什么错         │      正确写法        │
├──────────────────────┼──────────────────────┼──────────────────────┤
│                      │                      │                      │
│ return [];           │ 返回0个排列          │ return [[]];         │
│                      │ 导致 for 循环        │                      │
│                      │ 不执行               │ 返回1个排列          │
│                      │                      │ (就是空列表)         │
│                      │                      │                      │
├──────────────────────┼──────────────────────┼──────────────────────┤
│                      │                      │                      │
│ nums.splice(i, 1)    │ 修改原数组           │ slice(0,i).concat    │
│                      │ 破坏 for 循环        │ (slice(i+1))         │
│                      │ 得到错的 rest        │                      │
│                      │                      │ 不修改原数组         │
│                      │                      │                      │
├──────────────────────┼──────────────────────┼──────────────────────┤
│                      │                      │                      │
│ [first, p]          │ p=[2,3] 嵌套了       │ [first, ...p]        │
│                      │ 变成 [1,[2,3]]      │                      │
│                      │ 错了！              │ [1,2,3]              │
│                      │                      │ 正确！               │
│                      │                      │                      │
├──────────────────────┼──────────────────────┼──────────────────────┤
│                      │                      │                      │
│ for(let i=0;         │ splice 修改了数组    │ 先计算 rest          │
│     i<nums.length;   │ 导致 length 变化    │ 再进循环             │
│     i++)             │ 循环异常             │ 或使用 slice         │
│   nums.splice(...)   │                      │                      │
│                      │                      │                      │
└──────────────────────┴──────────────────────┴──────────────────────┘

`;

console.log(compareTable);

// ┌─────────────────────────────────────────────────────────────────────────┐
// │ 【记忆技巧】编个故事记住它                                             │
// └─────────────────────────────────────────────────────────────────────────┘

const story = `

📖 故事记忆法：排队的故事

想象你是"排队老师"，要让n个学生排队。

方法：【先选队长，再让其他人排队】

步骤：
  1️⃣  选第1个学生做"队长"站第一个
  2️⃣  让剩下的 n-1 个学生排队（递归！）
  3️⃣  把"队长"放在最前面

  重复这个过程...

  直到只剩 0 个学生
  └─ 0个学生怎么排？就是空队列（[]）
     但这代表"1种排法"（什么都不做）
     所以返回 [[]]

🎯 要点：
  ✓ 每次选1个"队长"
  ✓ 剩下的递归处理
  ✓ 拼接结果
  ✓ 最后数组为空时是"基础情况"

`;

console.log(story);

// ┌─────────────────────────────────────────────────────────────────────────┐
// │ 【模板套用】用这个解相似问题                                           │
// └─────────────────────────────────────────────────────────────────────────┘

const template = `

🚀 这个模板可以套用到很多问题：

function solve(data) {

  // 第一步：终止条件
  if (data.length === 0) {
    return [/* 返回"一个空答案" */];
  }

  // 第二步：选择循环
  const result = [];
  for (let i = 0; i < data.length; i++) {
    const choice = data[i];

    // 第三步：删除该选择
    const remaining = data.slice(0, i).concat(data.slice(i + 1));

    // 第四步：递归
    for (const answer of solve(remaining)) {

      // 第五步：组合
      result.push([choice, ...answer]);
    }
  }

  return result;
}

类似问题：
  ✓ 全排列（本题）
  ✓ 组合问题
  ✓ N皇后
  ✓ 子集生成
  ✓ 回溯算法题

都能用这个思路！

`;

console.log(template);

// ┌─────────────────────────────────────────────────────────────────────────┐
// │ 【时间复杂度】快速估算                                                 │
// └─────────────────────────────────────────────────────────────────────────┘

const complexity = `

⏱️ 复杂度速查

                 n=1    n=2    n=3    n=4    n=5    n=6
排列个数(n!)      1      2      6     24    120    720
时间(n! × n)      1      4     18     96    600   4320
                                            ↑
                                    开始有点慢了...

结论：n > 10 就很慢了！这是【指数级复杂度】

`;

console.log(complexity);

// ┌─────────────────────────────────────────────────────────────────────────┐
// │ 【实战测试】检查你学会了没                                            │
// └─────────────────────────────────────────────────────────────────────────┘

console.log("\n💪 自测题\n");

const selfTestQuestions = [
  {
    q: "1. 为什么终止条件是 return [[]] 而不是 return [] ？",
    a: "因为要返回'1个排列'（虽然是空的），[]表示0个排列会导致循环不执行"
  },
  {
    q: "2. 为什么不用 splice ？",
    a: "因为 splice 修改原数组，会破坏 for 循环的计数"
  },
  {
    q: "3. [first, ...p] 中的 ... 是什么？",
    a: "展开符，把数组 p 中的元素拆开，与 first 合并成一个新数组"
  },
  {
    q: "4. 时间复杂度是多少？",
    a: "O(n! × n)，n! 个排列，每个需要 O(n) 时间"
  },
  {
    q: "5. permute([1,2,3]) 的第一步做什么？",
    a: "选择1作为第一个元素，然后递归求[2,3]的排列，再拼接结果"
  }
];

selfTestQuestions.forEach((item, i) => {
  console.log(`${item.q}\n   答：${item.a}\n`);
});

// ┌─────────────────────────────────────────────────────────────────────────┐
// │ 【最后冲刺】三个要点一定要记住                                        │
// └─────────────────────────────────────────────────────────────────────────┘

const finalTip = `

🎯 离考试只差这3点！

第一点【递归出口】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
if (nums.length === 0) return [[]];
                               ^^^^
                            这里有2层括号！！！

● 单括号 [] 表示"什么都没有"
● 双括号 [[]] 表示"有一个空列表"

对排列来说，n=0时有1种排法（什么都不做）
所以要返回 [[]]

第二点【删除元素】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
const rest = nums.slice(0, i).concat(nums.slice(i + 1));
             ═════════════════╤═════════════════════════

slice(0, i)        → 前i个元素
concat(slice(i+1)) → 拼接第i+1个之后的元素

结果 = 除了第i个元素的所有元素

第三点【拼接结果】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
res.push([cur, ...p]);
         ┌────────────┘
         这里是【关键】

...p 表示把数组p展开
[cur, ...p] 意思是：先放cur，再依次放p中的元素

例如：
  cur = 1, p = [2, 3]
  [cur, ...p] = [1, 2, 3]  ✓

  如果写成 [cur, p]
  结果就是 [1, [2, 3]]     ✗ 错了！

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

背下这3点，全排列就不会错！

`;

console.log(finalTip);

console.log("\n✅ 学习资料已生成，请反复阅读本文件！\n");

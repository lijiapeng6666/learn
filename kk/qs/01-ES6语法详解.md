# ES6 语法详解

## 考点概述
ES6（ECMAScript 2015）是JavaScript的重大更新，引入了许多现代语法特性。在前端开发中频繁使用，是面试和实际工作的必备知识。

---

## 核心考点详解

### 1. let & const 变量声明
**考点：** 理解块级作用域、变量提升、暂时性死区

**通俗解释：**
- `var` 像一个"全局霸权"，声明的变量到处都能用
- `let` 像"房间内有效"，声明的变量只在该块级作用域内有效
- `const` 像"不可更改的合同"，声明后就不能改值

**原理：**
```javascript
// var - 函数作用域，存在变量提升
function test1() {
  if (true) {
    var x = 1
  }
  console.log(x) // 1，因为var没有块级作用域
}

// let - 块级作用域
function test2() {
  if (true) {
    let y = 1
  }
  console.log(y) // ReferenceError，y只在if块内有效
}

// const - 块级作用域 + 常量特性
const obj = { name: 'Tom' }
obj.name = 'Jerry' // 可以修改属性
// obj = {} // 错误！不能重新赋值
```

**实战应用：**
```javascript
// ✅ 推荐做法
const MAX_RETRY = 3 // 常量用const
let count = 0       // 会变化的数据用let
for (let i = 0; i < 10; i++) { // 循环变量用let避免作用域污染
  // ...
}
```

---

### 2. 箭头函数
**考点：** this指向、闭包、简洁语法

**通俗解释：**
箭头函数就是"懒人写法"，更简洁。但是**this永远指向定义时的外层this**，不会改变。

**原理：**
```javascript
// 普通函数 - this指向调用者
const obj1 = {
  name: 'Alice',
  greet: function() {
    console.log(this.name) // Alice
  }
}
obj1.greet() // 正常输出

// 箭头函数 - this指向定义时的上下文
const obj2 = {
  name: 'Bob',
  greet: () => {
    console.log(this.name) // undefined，因为this指向全局对象
  }
}
obj2.greet() // 输出undefined

// 实际应用：在对象方法中使用箭头函数处理回调
const user = {
  name: 'Charlie',
  hobbies: ['reading', 'coding'],
  printHobbies() {
    this.hobbies.forEach(hobby => {
      console.log(`${this.name} likes ${hobby}`)
      // 这里的this仍然指向user对象
    })
  }
}
user.printHobbies()
// 输出：
// Charlie likes reading
// Charlie likes coding
```

**实战应用：**
```javascript
// ✅ 回调中保留this
class Counter {
  count = 0
  increment() {
    setTimeout(() => {
      this.count++ // this正确指向Counter实例
    }, 1000)
  }
}

// ❌ 不要在需要独立this的地方用箭头函数
const button = {
  label: 'Click',
  onClick: () => {
    // 这里this指向全局，错误！
  }
}
```

---

### 3. 解构赋值
**考点：** 对象解构、数组解构、嵌套解构、默认值

**通俗解释：**
从数组或对象中快速提取你需要的值，就像"拆礼盒"取出你想要的东西。

**原理：**
```javascript
// 对象解构
const user = { name: 'David', age: 25, city: 'Shanghai' }
const { name, age } = user
console.log(name, age) // David 25

// 数组解构
const arr = [1, 2, 3, 4, 5]
const [first, second, ...rest] = arr
console.log(first, second, rest) // 1, 2, [3,4,5]

// 嵌套解构
const employee = {
  id: 1,
  profile: {
    name: 'Emma',
    skills: ['JS', 'React']
  }
}
const { profile: { name, skills: [lang1, lang2] } } = employee
console.log(name, lang1, lang2) // Emma JS React

// 默认值
const { country = 'China' } = { city: 'Beijing' }
console.log(country) // China
```

**实战应用：**
```javascript
// 函数参数解构
function getUserInfo({ id, name, email }) {
  return `${id}: ${name} (${email})`
}

getUserInfo({ id: 1, name: 'Frank', email: 'frank@example.com' })

// API响应处理
async function fetchUser() {
  const { data: { user: { id, name } } } = await api.getUser()
  // 直接获取嵌套数据，代码更清晰
}
```

---

### 4. 模板字符串
**考点：** 字符串插值、多行字符串、标签模板

**通俗解释：**
用反引号包裹字符串，可以在字符串中直接插入变量，不需要繁琐的字符串拼接。

**原理：**
```javascript
// 传统方式 - 繁琐
const name = 'Grace'
const age = 28
console.log('My name is ' + name + ', age is ' + age)

// ES6 方式 - 简洁
console.log(`My name is ${name}, age is ${age}`)

// 多行字符串
const html = `
  <div>
    <h1>${name}</h1>
    <p>Age: ${age}</p>
  </div>
`

// 表达式在${中执行
console.log(`2 + 2 = ${2 + 2}`)
console.log(`${age > 20 ? 'Adult' : 'Minor'}`) // Adult
```

---

### 5. Promise & async/await
**考点：** 异步流程控制、错误处理、链式调用

**通俗解释：**
- **Promise** 像"承诺"：我答应你某个事会做，做成功了(resolve)或失败了(reject)我会通知你
- **async/await** 像"等待"：用同步的写法处理异步操作，更直观

**原理：**
```javascript
// Promise - 三种状态
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Success!') // pending → fulfilled
  }, 1000)
})

promise
  .then(result => console.log(result))
  .catch(error => console.log(error))

// async/await - 更优雅的写法
async function fetchData() {
  try {
    const response = await fetch('/api/user')
    const data = await response.json()
    return data
  } catch (error) {
    console.log('Error:', error)
  }
}

// 与Promise等价，但更易读
// async函数返回Promise
fetchData().then(data => console.log(data))
```

---

### 6. 类 (Class)
**考点：** 继承、构造函数、static方法、getter/setter

**通俗解释：**
类是面向对象编程的方式，让代码更有组织性。

**原理：**
```javascript
// 基础类
class Animal {
  constructor(name) {
    this.name = name
  }

  speak() {
    console.log(`${this.name} makes a sound`)
  }
}

// 继承
class Dog extends Animal {
  constructor(name, breed) {
    super(name) // 调用父类构造函数
    this.breed = breed
  }

  speak() {
    console.log(`${this.name} barks`)
  }
}

// static方法 - 属于类本身，不属于实例
class Math2 {
  static add(a, b) {
    return a + b
  }
}
Math2.add(1, 2) // 3

// getter/setter
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName
    this.lastName = lastName
  }

  get fullName() {
    return `${this.firstName} ${this.lastName}`
  }

  set fullName(name) {
    [this.firstName, this.lastName] = name.split(' ')
  }
}

const p = new Person('Henry', 'Lee')
console.log(p.fullName) // Henry Lee
p.fullName = 'Isaac Newton'
```

---

### 7. 模块化 (Import/Export)
**考点：** 命名导出、默认导出、重新导出

**通俗解释：**
把代码分成多个文件，需要时导入，需要给别人用时导出。

**原理：**
```javascript
// math.js - 命名导出
export const add = (a, b) => a + b
export const subtract = (a, b) => a - b

// 默认导出
export default class Calculator {}

// main.js - 导入
import Calculator, { add, subtract } from './math'
// 或者导入全部
import * as math from './math'

// 重新导出 - 用于统一入口
export { add, subtract } from './math'
export { default as Calc } from './calculator'
```

---

## 实战项目建议

在你的前端项目中：
- ✅ 总是用 `const` 和 `let`，避免 `var`
- ✅ 在回调中充分利用箭头函数
- ✅ 用解构简化函数参数和变量声明
- ✅ 用模板字符串拼接动态内容
- ✅ 用 async/await 处理异步逻辑
- ✅ 用类组织相关代码逻辑
- ✅ 合理拆分模块，保持文件简洁

---

## 深入学习

| 概念 | 为什么重要 | 典型面试题 |
|-----|---------|---------|
| this指向 | 避免在回调中出bug | 箭头函数中this指向什么？ |
| 作用域 | 防止变量污染 | var和let的区别？ |
| 闭包 | 数据隐藏和缓存 | 什么是闭包？如何使用？ |
| Promise链 | 控制异步流程 | 如何处理多个异步操作的顺序？ |

---

## 快速自测

- [ ] 能解释var/let/const的区别吗？
- [ ] 箭头函数的this指向有什么特殊吗？
- [ ] 能写出嵌套的对象解构吗？
- [ ] 能手写Promise吗？
- [ ] 能解释async/await的原理吗？

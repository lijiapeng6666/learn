# 面试高频考题与标准答案

这份文档包含基于岗位要求的高频面试题。每道题都提供了**标准答案**、**深化讨论**、**评分标准**，帮助你给出让面试官印象深刻的回答。

---

## 第一部分：ES6 与现代 JavaScript

### Q1: 请解释 var、let、const 的区别

**标准答案框架：**
```
从4个维度展开：作用域、变量提升、重复声明、修改

1️⃣ 作用域
- var: 函数作用域，在函数内都能访问
- let: 块级作用域，只在{}内能访问
- const: 块级作用域，同let

2️⃣ 变量提升
- var: 提升，初值为undefined（存在暂时性死区前阶段）
- let/const: 也会提升，但不初始化（暂时性死区）

3️⃣ 重复声明
- var: 允许重复声明
- let/const: 不允许重复声明

4️⃣ 修改
- var: 可声明可修改
- let: 可修改，不可重新声明
- const: 不可修改，不可重新声明（对象属性可修改）
```

**优秀回答示例：**
```
首先，var、let、const这三种变量声明方式的最根本区别在于作用域。
var采用函数作用域，这是一个设计缺陷，容易导致变量污染。

具体来说，我会从以下几个方面解释：

【作用域维度】
var声明的变量在整个函数内都可见，这很容易出现问题：
```javascript
for (var i = 0; i < 3; i++) {}
console.log(i)  // 3 - 泄露到全局！
```

而let采用块级作用域，在{}内声明就只在{}内有效：
```javascript
for (let i = 0; i < 3; i++) {}
console.log(i)  // ReferenceError - 安全！
```

【变量提升维度】
var会被提升到作用域顶部并初始化为undefined：
```javascript
console.log(x)  // undefined (不报错!)
var x = 1
```

但let/const虽然也会提升，但不会初始化，而是创建所谓的"暂时性死区"：
```javascript
console.log(y)  // ReferenceError (报错!)
let y = 1
```
这样的设计更符合逻辑，让我们尽早发现错误。

【重新声明维度】
var允许重复声明，导致不注意时容易覆盖变量：
```javascript
var a = 1
var a = 2  // 没有警告
```

let/const不允许重复声明，能防止意外覆盖。

【实战建议】
在现代开发中，我遵循以下原则：
- 默认使用const，这样能防止意外修改
- 需要修改时改用let
- 很少使用var，除非为了向后兼容

这样的组合既安全又清晰。
```

**让面试官觉得很棒的额外补充：**
```
如果面试官追问"暂时性死区是什么？"，你可以说：

暂时性死区就是从块级作用域开始到let/const声明之前这段代码。
在这段区域内，变量已经被引擎识别，但尚未初始化。

这是一个很聪明的设计。它迫使开发者在使用变量前声明它，
这样能防止在JavaScript动态特性下出现的某些坑。

例如：
```javascript
var x = 1
{
  console.log(x)  // 在这里访问的x？
  let x = 2
}
```
这会报ReferenceError，因为块内的let x创建了新的绑定，
遮挡了外层的x，导致块内从开始到let x都是暂时性死区。
这样的设计虽然有点复杂，但能防止很多隐藏的bug。
```

**评分标准：**
- ⭐ 基础回答：说出3个区别（作用域、提升、重新声明）
- ⭐⭐ 良好回答：加上代码示例和实战建议
- ⭐⭐⭐ 优秀回答：解释暂时性死区，讨论设计理由，说明最佳实践

---

### Q2: 箭头函数和普通函数的区别，什么时候不能用箭头函数？

**标准答案框架：**
```
3个关键区别：
1. this指向 - 最重要！
2. prototype属性 - 箭头函数没有
3. arguments对象 - 箭头函数没有

什么时候不能用？
- 作为对象方法
- 作为构造函数
- 需要arguments对象的地方
```

**优秀回答示例：**
```
箭头函数和普通函数的最核心区别就是this指向。

【this指向的区别】
普通函数的this在运行时由谁调用决定，很容易出坑：

```javascript
const obj = {
  name: 'Alice',
  greet: function() {
    console.log(this.name)
  }
}

obj.greet()  // 'Alice' - 这时this是obj

const greet = obj.greet
greet()  // undefined - 这时this是全局对象！
```

这个问题困扰了多少JavaScript开发者啊。

箭头函数则不同，它没有自己的this，而是继承外层的this：

```javascript
const obj = {
  name: 'Alice',
  greet: () => {
    console.log(this)  // 这里的this是外层的this（全局或模块）
  }
}
```

【真实应用场景】
这个特性在处理回调时特别有用：

```javascript
class Timer {
  constructor() {
    this.count = 0
  }

  start() {
    setInterval(() => {
      this.count++  // 这里的this正确指向Timer实例
      console.log(this.count)
    }, 1000)
  }
}

// 如果用普通函数就会出错
class TimerBad {
  constructor() {
    this.count = 0
  }

  start() {
    setInterval(function() {
      this.count++  // 这里this是全局对象，undefined.count报错！
    }, 1000)
  }
}
```

【其他区别】
除了this，箭头函数还没有自己的prototype和arguments：

```javascript
const arrow = () => {}
const normal = function() {}

arrow.prototype  // undefined
normal.prototype  // {constructor: normal}

// 需要arguments时要用剩余参数
const arrow = (...args) => console.log(args)
```

【什么时候不能用箭头函数？】
基于this的特性，以下场景不适合：

1️⃣ 作为对象方法
```javascript
// ❌ 错误
const person = {
  name: 'Bob',
  sayHello: () => {
    console.log(this.name)  // this不是person！
  }
}

// ✅ 正确
const person = {
  name: 'Bob',
  sayHello: function() {
    console.log(this.name)  // this是person
  }
}
```

2️⃣ 作为构造函数
```javascript
// ❌ 箭头函数不能用new
const User = (name) => {
  this.name = name
}
new User('Charlie')  // TypeError!

// ✅ 普通函数可以
const User = function(name) {
  this.name = name
}
new User('Charlie')  // 可以
```

3️⃣ 需要arguments对象
```javascript
// ❌ 错误
const sum = () => {
  return Array.from(arguments).reduce((a, b) => a + b)
}

// ✅ 正确
const sum = function() {
  return Array.from(arguments).reduce((a, b) => a + b)
}
```

【我的最佳实践】
- 默认用箭头函数，简洁高效
- 需要自己的this时改用普通函数
- 在组件方法中用普通函数保证this指向正确
- 在回调中用箭头函数保留外层this
```

**让面试官觉得很棒的额外补充：**
```
如果面试官问"能通过bind或call改变箭头函数的this吗？"

答案是不能。这是箭头函数的一个核心设计特性。
试图改变箭头函数的this就像试图改变常数一样，是行不通的。

这样的设计其实体现了函数式编程的思想：
箭头函数是一个纯函数，它没有隐藏的状态（this），
这样更容易推理和测试。
```

**评分标准：**
- ⭐ 基础：说出this指向不同
- ⭐⭐ 良好：加上代码示例和不适用场景
- ⭐⭐⭐ 优秀：讨论函数式编程理念，说明最佳实践

---

### Q3: Promise 和 async/await 的关系是什么？

**优秀回答示例：**
```
这是一个很好的问题，关系到JavaScript异步编程的演进。

【简单来说】
async/await是Promise的语法糖。它不是替代Promise，
而是在Promise基础上提供了更优雅的语法。

【演进历程】
JavaScript异步编程经历了三个阶段：

1️⃣ Callback地狱
```javascript
getUser(userId, (user) => {
  getOrders(user.id, (orders) => {
    getOrderDetails(orders[0].id, (details) => {
      console.log(details)  // 三层嵌套，难以维护
    })
  })
})
```

2️⃣ Promise链式调用
```javascript
getUser(userId)
  .then(user => getOrders(user.id))
  .then(orders => getOrderDetails(orders[0].id))
  .then(details => console.log(details))
  .catch(error => console.error(error))
```
好多了，但仍然需要理解then链式。

3️⃣ async/await（最优雅）
```javascript
async function process() {
  try {
    const user = await getUser(userId)
    const orders = await getOrders(user.id)
    const details = await getOrderDetails(orders[0].id)
    console.log(details)
  } catch(error) {
    console.error(error)
  }
}
```
看起来就像同步代码，但实际上在后台是异步的。

【本质关系】
async/await实际上是Promise的包装。你写的async函数
本质上返回一个Promise：

```javascript
// 这两个是等价的

// 方式1：async/await
async function fetchUser(id) {
  const response = await fetch(`/api/user/${id}`)
  return await response.json()
}

// 方式2：Promise链
function fetchUser(id) {
  return fetch(`/api/user/${id}`)
    .then(response => response.json())
}

// 两种方式返回的都是Promise！
```

【await的工作原理】
当你在async函数中使用await时，发生了什么？

```javascript
async function example() {
  console.log('1')
  await new Promise(resolve => setTimeout(resolve, 1000))
  console.log('2')
}

example()
console.log('3')

// 输出顺序：
// 1
// 3
// (等待1秒)
// 2
```

这说明await会暂停async函数的执行，但不会阻塞主线程。
这是通过Generator实现的（内部细节）。

【错误处理对比】
Promise错误处理需要catch：
```javascript
getUser(id)
  .then(user => getOrders(user.id))
  .catch(error => console.error('failed:', error))
```

async/await可以用try/catch，更自然：
```javascript
try {
  const user = await getUser(id)
  const orders = await getOrders(user.id)
} catch(error) {
  console.error('failed:', error)
}
```

【什么时候用哪个？】
- 优先用async/await，代码更清晰
- 需要并行执行多个Promise时用Promise.all：
  ```javascript
  const results = await Promise.all([
    getUser(id),
    getSettings(id),
    getNotifications(id)
  ])
  ```
- 复杂的链式操作可能用.then()更好理解
- 在循环中需要顺序执行时，async/await是最佳选择

【常见误区】
❌ 误区：async函数一定比Promise快
✅ 真相：性能相同，只是语法更优雅

❌ 误区：await会阻塞主线程
✅ 真相：不会，只是暂停该async函数的执行

❌ 误区：不能混合使用async/await和.then()
✅ 真相：完全可以，因为async返回Promise
```

**评分标准：**
- ⭐ 基础：说出async/await是Promise的语法糖
- ⭐⭐ 良好：加上演进历程和代码对比
- ⭐⭐⭐ 优秀：讨论工作原理、错误处理、最佳实践

---

## 第二部分：HTTP 与网络

### Q4: 请详细解释 HTTPS 的工作原理

**优秀回答示例：**
```
这是一个关于网络安全的重要问题。

【HTTPS = HTTP + 加密层(SSL/TLS)】
简单来说，HTTPS就是在HTTP和TCP之间加了一个加密层。

【为什么需要HTTPS？】
HTTP有三大致命缺陷：

1️⃣ 窃听风险：明文传输，任何中间节点都能看到
2️⃣ 篡改风险：数据可以被修改，接收方无法察觉
3️⃣ 冒充风险：无法确认对方身份

【HTTPS如何解决这些问题？】

使用两种加密方式的组合：

📌 非对称加密（RSA）
用途：密钥交换
特点：
- 有两把钥匙：公钥（任何人都能有）和私钥（只有服务器有）
- 公钥加密的内容只有私钥能解，反之亦然
- 安全但计算量大

📌 对称加密（AES）
用途：数据加密传输
特点：
- 只有一把钥匙，双方都有
- 加解密速度快
- 问题是钥匙怎么安全传递？

结合：用非对称加密来安全交换对称密钥！

【TLS握手的完整过程】

```
客户端                                  服务器
  |                                      |
  |----1. ClientHello（支持的加密套件）--->|
  |                                      |
  |<---2. ServerHello（选定的套件） ------|
  |<---3. Certificate（服务器证书）------|
  |<---4. ServerKeyExchange（参数）-----|
  |<---5. ServerHelloDone -------------|
  |                                      |
  |---6. ClientKeyExchange（预主密钥）--->|
  |---7. ChangeCipherSpec（准备加密）--->|
  |---8. Finished（握手完成）------------>|
  |                                      |
  |<---9. ChangeCipherSpec （准备加密）---|
  |<---10. Finished --------------------|
  |                                      |
  |====加密通道建立完毕，可以传输数据====|
  |----->| 加密HTTP请求数据 |----->|
  |<-----| 加密HTTP响应数据 |<-----|
  |                                      |
```

详细步骤：

1️⃣ ClientHello
客户端发送支持的TLS版本、加密套件、压缩方法等，
还有一个随机数。

2️⃣ ServerHello
服务器选定一个加密套件和TLS版本，也生成一个随机数。

3️⃣ Certificate
服务器发送自己的证书，包含：
- 服务器身份信息
- 服务器的公钥
- CA的签名（保证证书真实）

4️⃣ ServerKeyExchange
发送额外的密钥交换参数。

5️⃣ ClientKeyExchange
客户端生成"预主密钥"(PreMasterSecret)，
用服务器的公钥加密后发送。
只有服务器的私钥能解密！

6️⃣ 双方计算会话密钥
客户端和服务器都使用同样的算法，
从客户端随机数+服务器随机数+预主密钥
推导出"会话密钥"。

现在双方都有相同的对称密钥了！

7️⃣ ChangeCipherSpec
通知对方从现在起要开始使用加密。

8️⃣ Finished
发送使用会话密钥加密的完成消息。
对方能正确解密说明钥匙交换成功。

9️⃣ 服务器重复过程
服务器也发送ChangeCipherSpec和Finished。

【关键保障】

✅ 防止窃听
所有数据都用会话密钥加密，第三方看不懂。

✅ 防止篡改
加密数据包含MAC（消息认证码），
任何篡改都会被立即发现。

✅ 防止冒充
服务器证书由CA签名，用CA的公钥验证签名可以确认
证书来自真实的服务器。

【证书验证过程】
浏览器收到服务器证书后：

1. 检查证书是否过期
2. 检查域名是否匹配（防止man-in-the-middle）
3. 验证CA签名（用CA公钥解密签名，比对内容）
4. 检查CA是否在信任列表中

任何检查失败都会警告用户。

【完整的加密过程示意】

未加密的明文：
  POST /login HTTP/1.1
  username=alice&password=secret

加密后（base64表示）：
  c2VsZnNlbGZzZWxmODk4OTguLi4u

传输中无人能看懂！

【性能考虑】

HTTPS vs HTTP：
- 多了TLS握手的时间（100-300ms）
- 加密解密计算（几ms）
- 整体只慢10%左右，完全可以接受

现在大多数网站都用HTTPS了。

【我的建议】
- 所有网站都应该用HTTPS
- 在开发时也应该用HTTPS，及早发现问题
- 注意HTTP2会改进HTTPS的性能，
  多路复用能更充分地利用加密连接
```

**让面试官觉得很棒的额外补充：**
```
如果面试官追问"如何防止中间人攻击？"

答案：这就是HTTPS的核心作用。

中间人攻击（MITM）的常见场景：
1. 攻击者拦截你的流量
2. 用自己的证书替换服务器的证书
3. 你和攻击者加密通信，攻击者和服务器加密通信
4. 攻击者就能看到所有信息

HTTPS如何防止：
1. 浏览器会检查证书是否由可信的CA颁发
2. 如果攻击者用自己的证书，浏览器会警告
3. 用户看到红色警告，就知道不对劲了

这是一个很优雅的设计：
- 充分利用了PKI（公钥基础设施）
- 成本很低：CA证书是免费的
- 防护很强：原理上无法绕过
```

**评分标准：**
- ⭐ 基础：说出HTTPS = HTTP + 加密，提到非对称和对称加密
- ⭐⭐ 良好：讲清TLS握手流程，说明防护机制
- ⭐⭐⭐ 优秀：讨论证书验证、防止中间人攻击、性能考虑

---

## 第三部分：前端工程化

### Q5: Webpack 的构建流程是怎样的？

**优秀回答示例：**
```
这是前端工程化的核心问题。

【Webpack的本质】
Webpack本质上是一个模块打包器。
它的目标是把所有资源（JS、CSS、图片、字体等）
都看作模块，然后打包成浏览器能理解的产物。

【核心流程分为5个阶段】

阶段1️⃣：初始化(Initialization)
```
┌─────────────────────────────────┐
│ webpack.config.js               │
│ command line arguments          │
│ defaults                        │
└─────────────────┬───────────────┘
                  │
                  ↓
        读取配置，创建Compiler实例
          注册插件的hook
```

阶段2️⃣：编译(Compilation) - 核心！
```
从entry开始，递归处理每个模块：

entry: './src/index.js'
  │
  ├─> require('./utils.js')
  │     │
  │     ├─> require('./math.js')
  │     └─> require('lodash')
  │
  ├─> require('./styles.css')
  │     │
  │     └─> url('./background.png')
  │
  └─> require('./template.html')

构建模块依赖图
```

对每个模块的处理流程：

```
模块内容
   │
   ├─> 匹配loader规则
   │     ├─ babel-loader: JS → 转译JS
   │     ├─ css-loader: CSS → 处理@import
   │     ├─ sass-loader: SCSS → CSS
   │     └─ url-loader: 图片 → Data URL
   │
   ├─> 调用对应loader处理
   │
   ├─> 解析AST（抽象语法树）
   │     获取模块的dependencies
   │
   ├─> 递归处理dependencies
   │
   └─> 加入到依赖图中
```

最终形成一个完整的模块依赖图。

阶段3️⃣：优化(Optimization)
```
对依赖图进行优化：

Tree Shaking
  未使用的export → 标记为dead code

Code Splitting
  按chunk分割

Minification
  移除空白、重命名变量

Deduplication
  相同模块只保留一份
```

阶段4️⃣：生成(Generation)
```
根据优化后的依赖图生成最终代码：

生成的代码结构：
(function(modules) {
  // webpack runtime - 运行时代码
  // 模块加载函数
  // 缓存管理

  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) {
      return installedModules[moduleId].exports
    }

    var module = {
      id: moduleId,
      exports: {}
    }

    modules[moduleId].call(module.exports, module, ...)

    return module.exports
  }

  // 执行entry模块
  return __webpack_require__(0)
})({
  0: function() { /* index.js内容 */ },
  1: function() { /* utils.js内容 */ },
  2: function() { /* math.js内容 */ }
})
```

这个结构很巧妙：
- 用对象存储所有模块
- 用函数的闭包模拟模块的私有作用域
- __webpack_require__函数负责加载模块

阶段5️⃣：输出(Emit)
```
文件写入到output目录：

dist/
├─ main.js (主bundle)
├─ vendor.js (第三方库)
├─ index.html (自动注入script标签)
└─ style.css (提取的样式)
```

【核心机制详解】

📌 Loader的链式调用
```javascript
module: {
  rules: [{
    test: /\.scss$/,
    use: ['style-loader', 'css-loader', 'sass-loader']
  }]
}

执行顺序：
sass-loader: SCSS → CSS
  ↓
css-loader: 处理@import、url()
  ↓
style-loader: CSS → JS (注入到DOM)
```

为什么从右到左？因为这是函数组合的方式。
想象：style(css(sass(content)))

📌 Plugin vs Loader
```
Loader：转换模块内容
- 输入：模块内容
- 输出：处理后的内容
- 例子：babel-loader、sass-loader

Plugin：扩展Webpack功能
- Hook到编译过程
- 在关键时刻执行
- 例子：HtmlWebpackPlugin生成HTML
```

【性能优化的原理】

🎯 Tree Shaking原理
```javascript
// math.js
export const add = (a, b) => a + b
export const unused = () => {}

// index.js
import { add } from './math'  // 只导入add

编译后：
- add保留
- unused被标记为"不使用的导出"
- uglifyjs等压缩工具会删除它
```

关键条件：必须是ES6 Module！
因为Webpack在编译时就能确定导出。

🎯 Code Splitting原理
```javascript
// 动态导入
button.addEventListener('click', () => {
  import('./heavy').then(module => {
    module.doSomething()
  })
})

// Webpack会生成两个chunk：
// main.js：主逻辑
// 0.js：heavy模块

首次加载只加载main.js（小）
点击后才加载0.js（大）
```

【我的最佳实践】

1️⃣ 理解构建流程
- 知道每个阶段做什么
- 能预测配置的效果

2️⃣ 合理的代码分割
```javascript
optimization: {
  splitChunks: {
    cacheGroups: {
      vendor: {
        // node_modules单独打包
        test: /[\\/]node_modules[\\/]/,
        name: 'vendors',
        priority: 10
      }
    }
  }
}
```

3️⃣ 监控bundle大小
```bash
npm install webpack-bundle-analyzer
```

4️⃣ 开发环境配置简化
```javascript
mode: 'development'  // 快速重建

devtool: 'eval-cheap-module-source-map'
// 编译快，调试也够用
```

5️⃣ 生产环境配置完整
```javascript
mode: 'production'  // 自动优化
// Tree Shaking、minify等都启用
```

【常见误区】

❌ 只会用webpack，不理解原理
✅ 理解流程，能配置和优化

❌ 以为splitChunks越多越好
✅ 关键是找到平衡点

❌ 忽视source map的生成时间
✅ 开发用cheap版本，生产用完整版本
```

**让面试官觉得很棒的额外补充：**
```
如果面试官问"能自己写一个简单的Webpack吗？"

这展现了你对原理的深入理解。虽然不必写完整的Webpack，
但你可以说：

核心就是：
1. 从entry开始，用require()或import()递归找到所有模块
2. 对每个模块应用对应的loader
3. 构建依赖图
4. 生成可执行的JavaScript

我可以用以下伪代码演示：

```javascript
class SimpleWebpack {
  constructor(config) {
    this.entry = config.entry
    this.modules = new Map()
    this.graph = {}
  }

  bundle() {
    // 步骤1：找到依赖
    this.createModuleGraph(this.entry)

    // 步骤2：生成代码
    return this.generate()
  }

  createModuleGraph(entry) {
    const modules = this.analyzeModule(entry)
    // 递归处理dependencies...
  }

  generate() {
    // 生成IIFE包装的代码
    return `(function() {
      // webpack runtime
      // 模块定义
      // 执行entry
    })()`
  }
}
```

这样答题会给人"这个人真的理解了"的感觉。
```

**评分标准：**
- ⭐ 基础：说出5个阶段
- ⭐⭐ 良好：详细讲解每个阶段，说出核心机制
- ⭐⭐⭐ 优秀：讨论性能优化原理，说明最佳实践

---

## 第四部分：后端框架

### Q6: NestJS 的依赖注入系统是怎样工作的？

**优秀回答示例：**
```
这是一个关键的NestJS特性。

【什么是依赖注入(DI)？】

先看没有DI的代码：
```javascript
class UserService {
  private database = new Database()

  getUser(id) {
    return this.database.query(`SELECT * FROM users WHERE id=${id}`)
  }
}

const service = new UserService()
```

问题：
- UserService和Database紧密耦合
- 无法切换不同的Database实现
- 单元测试时难以mock Database

有DI的代码：
```typescript
class UserService {
  constructor(private database: DatabaseInterface) {}

  getUser(id) {
    return this.database.query(...)
  }
}

// 从外部注入Database，而不是内部创建
const database = new RealDatabase()
const service = new UserService(database)

// 测试时注入MockDatabase
const mockDb = new MockDatabase()
const testService = new UserService(mockDb)
```

好处：
- 解耦：可以随意替换实现
- 可测试：容易mock依赖
- 灵活：配置灵活

【NestJS的DI系统】

NestJS内置了强大的DI容器。

🔷 核心概念：Provider

Provider是任何可以注入的东西：

```typescript
// 方式1：类Provider（最常见）
@Module({
  providers: [UserService]  // 自动注入
})

// 方式2：值Provider
{
  provide: 'DATABASE_URL',
  useValue: 'postgres://localhost/mydb'
}

// 方式3：工厂Provider
{
  provide: UserService,
  useFactory: (database) => {
    return new UserService(database)
  },
  inject: [Database]
}

// 方式4：别名Provider
{
  provide: 'USER_SERVICE',
  useClass: UserService
}
```

🔷 完整的注入流程

```
@Module声明
  │
  ├─ 声明providers
  ├─ 声明controllers
  └─ 导入其他modules

       ↓

NestJS DI容器解析
  │
  ├─ 分析所有providers
  ├─ 构建依赖图
  │  如果A依赖B，B依赖C
  │  就构建：A → B → C
  │
  └─ 按依赖顺序创建实例

       ↓

Controller需要Service
  │
  ├─ 容器查找是否有Service
  ├─ 如果没有，创建新实例
  ├─ 如果有，返回缓存的实例
  └─ 注入到Controller
```

【具体例子】

```typescript
// database.service.ts
@Injectable()  // 标记为可注入
export class DatabaseService {
  query(sql: string) {
    return execute(sql)
  }
}

// user.service.ts
@Injectable()
export class UserService {
  // 🔑 构造函数注入
  constructor(private db: DatabaseService) {}

  findAll() {
    return this.db.query('SELECT * FROM users')
  }
}

// user.controller.ts
@Controller('users')
export class UserController {
  constructor(private userService: UserService) {}

  @Get()
  getAll() {
    return this.userService.findAll()
  }
}

// user.module.ts
@Module({
  providers: [DatabaseService, UserService],
  controllers: [UserController]
})
export class UserModule {}
```

NestJS自动做的事：
1. 读到DatabaseService和UserService都是Injectable
2. 构建依赖图：UserService → DatabaseService
3. 先创建DatabaseService实例
4. 再创建UserService实例（注入Database）
5. 再创建UserController实例（注入UserService）

所有连接自动完成！

【不同的生命周期】

```typescript
// Transient：每次注入都创建新实例
@Injectable({ scope: Scope.TRANSIENT })

// Request：每个请求创建一个实例
@Injectable({ scope: Scope.REQUEST })

// Default (Singleton)：全应用共享一个实例
@Injectable({ scope: Scope.DEFAULT })
```

【优势vs Spring DI】

NestJS的DI vs Java Spring：
```
相似点：
- 都基于Constructor Injection
- 都支持Provider/Bean配置
- 都能自动解决依赖关系

NestJS优势：
- TypeScript的装饰器很优雅
- 配置更简洁
- 编译时类型检查

Spring优势：
- 生态更成熟
- 功能更丰富
- 社区资源更多
```

【测试中的DI】

单元测试时利用DI的好处：

```typescript
describe('UserService', () => {
  let userService: UserService
  let mockDb: MockDatabaseService

  beforeEach(() => {
    mockDb = new MockDatabaseService()
    userService = new UserService(mockDb)
  })

  it('should return user', () => {
    mockDb.mockQuery(() => ({ id: 1, name: 'Alice' }))
    const user = userService.findAll()
    expect(user.name).toBe('Alice')
  })
})
```

或者用NestJS Test模块：

```typescript
const module = await Test.createTestingModule({
  providers: [
    UserService,
    {
      provide: DatabaseService,
      useValue: mockDatabaseService  // 注入mock
    }
  ]
}).compile()

const userService = module.get(UserService)
```

这样测试就很容易了。

【最佳实践】

1️⃣ 充分利用DI
```typescript
// ✅ 好的做法
@Injectable()
export class UserService {
  constructor(
    private userRepository: UserRepository,
    private emailService: EmailService,
    private logger: Logger
  ) {}
}

// 而不是
export class UserService {
  private repository = new UserRepository()
  private email = new EmailService()
}
```

2️⃣ 提供清晰的接口
```typescript
export interface IUserRepository {
  findAll(): Promise<User[]>
  findById(id: string): Promise<User>
}

@Injectable()
export class UserService {
  constructor(private repo: IUserRepository) {}
}
```

3️⃣ 合理使用Provider配置
```typescript
const providers = [
  UserService,
  {
    provide: DATABASE_CONNECTION,
    useFactory: () => createConnection(...)
  },
  {
    provide: CONFIG_SERVICE,
    useValue: new ConfigService()
  }
]
```

4️⃣ 避免循环依赖
```typescript
// ❌ 错误
UserService → OrderService → UserService

// 如果遇到，重新设计
// 可能需要提取共同依赖或重组module
```
```

**让面试官觉得很棒的额外补充：**
```
如果面试官问"NestJS的DI和Spring的DI有什么区别？"

答案可以是：

虽然都是依赖注入，但实现细节不同：

Spring：
- 基于反射机制
- 运行时动态创建对象
- 支持复杂的AOP编织

NestJS：
- 基于TypeScript装饰器
- 更静态的配置
- 编译时进行更多检查

我更喜欢NestJS的方式，因为：
1. 用装饰器很声明式，代码意图清晰
2. TypeScript类型检查能发现更多问题
3. 轻量级，性能更好
```

**评分标准：**
- ⭐ 基础：解释DI的好处，说出基本原理
- ⭐⭐ 良好：详细讲解Provider、生命周期、完整流程
- ⭐⭐⭐ 优秀：对比Spring、讨论测试、说明最佳实践

---

## 第五部分：系统设计与架构

### Q7: 设计一个组件库，你会如何考虑？

**优秀回答示例：**
```
这个问题考查的是系统设计能力。

【第一步：理解需求】

如果要设计一个企业级的UI组件库，我首先要思考：

1️⃣ 针对谁？
- 内部团队用（可以定制化）
- 还是开源供所有人用（需要通用）
- 我假设是服务于团队的业务组件库

2️⃣ 包含哪些组件？
- 基础组件：Button、Input、Select...
- 业务组件：UserPicker、DateRange...
- 布局组件：Grid、Layout...
- 工具组件：Modal、Toast...

3️⃣ 质量要求？
- 支持哪些浏览器？
- 单元测试覆盖率要多少？
- 文档完整度？
- 无障碍(a11y)支持？

【第二步：架构设计】

使用Monorepo架构：

```
component-library/
├─ packages/
│  ├─ vue/              # Vue 3版本
│  ├─ react/            # React版本
│  ├─ shared/           # 共享逻辑和样式
│  └─ cli/              # 命令行工具
│
├─ docs/                # 文档
├─ storybook/           # 组件预览
└─ scripts/             # 自动化脚本
```

为什么Monorepo：
- 共享设计令牌和样式
- 统一的版本管理
- 简化发布流程
- 跨框架代码复用

【第三步：设计令牌】

定义统一的设计规范：

```scss
// tokens/colors.scss
$color-primary: #1890ff;
$color-success: #52c41a;
$color-warning: #faad14;
$color-danger: #f5222d;

// tokens/sizes.scss
$size-xs: 4px;
$size-sm: 8px;
$size-md: 16px;
$size-lg: 24px;
$size-xl: 32px;

// tokens/typography.scss
$font-size-sm: 12px;
$font-size-base: 14px;
$font-size-lg: 16px;
```

好处：
- 一致的视觉风格
- 修改token立即影响所有组件
- 主题切换容易

【第四步：组件分类和优先级】

```
P0 (必须有)
├─ Button
├─ Input
├─ Select
├─ Modal
└─ Form

P1 (重要)
├─ Table
├─ DatePicker
├─ Checkbox
├─ Radio
└─ Tooltip

P2 (优化)
├─ Popover
├─ Steps
├─ Pagination
└─ Tabs

P3 (额外增强)
├─ Upload
├─ Tree
├─ Cascader
└─ 自定义组件
```

分阶段实现，先实现P0保证核心功能。

【第五步：组件规范】

每个组件必须包含：

```
Button/
├─ Button.vue           # 组件实现
├─ Button.module.scss   # 样式
├─ Button.test.ts       # 单元测试
├─ Button.story.ts      # Storybook故事
├─ types.ts             # TypeScript定义
├─ README.md            # 使用文档
└─ index.ts             # 导出
```

规范约束：
- 所有组件必须是可复用的
- Props/Events必须文档齐全
- 支持Slots提高灵活性
- 单元测试覆盖率>80%

【第六步：API设计】

学习Ant Design的优点：

```typescript
// Button组件API
<Button
  type="primary"           // 样式类型
  size="large"             // 大小
  :loading="isLoading"     // 加载状态
  :disabled="isDisabled"   // 禁用
  icon="download"          // 图标
  @click="handleClick"     // 事件
>
  Click me
</Button>

设计原则：
- Props用于输入（控制组件外观和行为）
- Events用于输出（组件向外通信）
- Slots用于内容插槽（高度灵活）
```

【第七步：文档和演示】

使用Storybook：

```typescript
// Button.stories.ts
export default {
  title: 'Components/Button',
  component: Button,
  argTypes: {
    type: { control: 'select', options: ['primary', 'default'] },
    size: { control: 'select', options: ['small', 'middle', 'large'] }
  }
}

export const Primary = {
  args: { type: 'primary', children: 'Primary Button' }
}

export const Loading = {
  args: { loading: true, children: 'Loading' }
}
```

优势：
- 可交互地预览组件
- 自动生成文档
- 开发时快速反馈

【第八步：质量保证】

测试策略：

```typescript
// Button.test.ts
describe('Button', () => {
  // 功能测试
  it('should render', () => {...})
  it('should emit click event', () => {...})

  // Props测试
  it('should apply type class', () => {...})
  it('should disable button', () => {...})

  // 交互测试
  it('should handle click', async () => {...})
  it('should show loading state', () => {...})

  // 快照测试
  it('should match snapshot', () => {...})
})
```

CI/CD流程：
```
代码提交
  ↓
运行Lint检查
  ↓
运行单元测试
  ↓
生成覆盖率报告
  ↓
构建Storybook
  ↓
构建库文件
  ↓
部署文档和预览
```

【第九步：发布和版本管理】

语义化版本：
```
1.2.3
├─ 1: MAJOR（不兼容改动）
├─ 2: MINOR（新增功能）
└─ 3: PATCH（bug修复）
```

发布流程：
```bash
# 1. 更新版本
npm run version

# 2. 构建
npm run build

# 3. 发布到npm
npm publish

# 4. 生成changelog
git log...

# 5. 发布Release
gh release create v1.2.3
```

【第十步：主题定制】

支持主题切换：

```scss
// 使用CSS变量
:root {
  --primary-color: #1890ff;
  --success-color: #52c41a;
  --warning-color: #faad14;
  --danger-color: #f5222d;
}

.button-primary {
  background-color: var(--primary-color);
}

// 暗黑主题
body.dark {
  --primary-color: #177ddc;
  --success-color: #49aa19;
  // ...
}
```

【我的完整方案总结】

```
第1-2个月：
- 搭建Monorepo
- 定义设计令牌
- 实现P0组件（Button、Input、Form等）
- 搭建Storybook文档
- 配置测试框架

第3-4个月：
- 实现P1组件（Table、DatePicker等）
- 完善单元测试
- 编写详细文档
- 性能优化
- 发布v1.0

第5-6个月：
- 实现P2组件
- 收集团队反馈
- 支持主题定制
- 国际化(i18n)支持
- 发布v1.1

持续维护：
- 响应用户反馈
- 修复bug
- 性能优化
- 新增功能
```

【核心成功因素】

✅ 高质量：单元测试+完整文档
✅ 易使用：清晰的API+完善的例子
✅ 高性能：懒加载+Tree Shaking
✅ 可扩展：支持主题、国际化
✅ 可维护：清晰的架构+规范的代码
```

**让面试官觉得很棒的额外补充：**
```
如果面试官问"如果要支持多个框架（Vue、React），怎么处理？"

答案可以是：

有几种方案：

方案1：分别用Vue和React实现（推荐）
优点：
- 每个框架都有最优的实现
- 充分利用框架特性
- 维护清晰
缺点：
- 重复代码多
- 维护成本高

方案2：Web Components
用Web Components作为基础组件，Vue和React作为包装层。
优点：
- 框架无关
- 代码复用
缺点：
- Web Components成熟度不够
- 性能可能有问题

方案3：Monorepo + 共享逻辑
不同框架的组件分别实现，但共享样式和逻辑。

我会选择方案3：
- 在shared包里放CSS和类型定义
- 在vue/和react/分别实现具体组件
- 共享同一套设计令牌
```

**评分标准：**
- ⭐ 基础：说出要点（组件分类、文档、测试）
- ⭐⭐ 良好：详细讲解各个阶段、设计决策
- ⭐⭐⭐ 优秀：讨论权衡、多框架支持、长期规划

---

## 第六部分：综合问题

### Q8: 给定一个性能缓慢的应用，你如何诊断和优化？

**优秀回答示例：**
```
这是一个很实际的问题，考查问题诊断和解决能力。

【第一步：定义性能指标】

首先要明确"性能缓慢"的具体含义：

Web Vitals指标：
- LCP (Largest Contentful Paint): 最大内容绘制
  目标：< 2.5秒

- FID (First Input Delay): 首次输入延迟
  目标：< 100毫秒

- CLS (Cumulative Layout Shift): 累积布局偏移
  目标：< 0.1

还有其他指标：
- TTFB (Time to First Byte): 首字节时间
- DCL (DOMContentLoaded): DOM加载时间
- L (Load): 页面加载完成时间
- TTI (Time to Interactive): 可交互时间

【第二步：使用工具诊断】

🔧 Chrome DevTools
```
Lighthouse报告：
1. 打开DevTools → Lighthouse
2. 选择Performance
3. 运行审核
4. 得到0-100的分数和具体建议

举例输出：
- 首次内容绘制：2.3秒
- 最大内容绘制：3.5秒
- 累积布局偏移：0.05
- 建议：
  └─ 减少未使用的CSS
  └─ 推迟非关键JavaScript
  └─ 使用下一代格式的图像
```

🔧 Performance API
```javascript
// 自己测量性能
const startTime = performance.now()

// ...执行操作

const endTime = performance.now()
console.log(`耗时: ${endTime - startTime}ms`)

// 或者用PerformanceObserver监听
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log(`${entry.name}: ${entry.duration}ms`)
  }
})

observer.observe({ entryTypes: ['measure', 'navigation'] })
```

🔧 Network分析
```
DevTools → Network选项卡：
1. 按大小排序，找到最大的资源
2. 检查加载时间
3. 查看请求头和响应
4. 关闭缓存重新加载，看最坏情况
```

【第三步：识别瓶颈】

常见的性能问题：

1️⃣ Bundle过大
```
症状：首页加载慢
诊断：Lighthouse显示"JavaScript execution time too high"

分析方法：
webpack-bundle-analyzer分析bundle结构
```

2️⃣ 图片没有优化
```
症状：页面占用内存多
诊断：看Network，发现大量高分辨率图片

分析方法：
- 原始图片太大
- 没有使用现代格式（WebP）
- 没有响应式图片
```

3️⃣ 首屏渲染慢
```
症状：LCP很高
诊断：Lighthouse建议检查渲染阻塞资源

原因：
- CSS太多
- 关键JavaScript没有优化
- 没有预加载关键资源
```

4️⃣ 运行时卡顿
```
症状：交互时有明显延迟
诊断：Performance录制，看看是否有长任务

原因：
- JavaScript执行时间长
- 频繁重排重绘
- 没有使用requestAnimationFrame
```

【第四步：优化方案】

📍 优化Bundle
```javascript
// 1. 代码分割
import(/* webpackChunkName: "heavy" */ './heavy')

// 2. 移除未使用代码
// 确保用ES6 module，启用Tree Shaking
// webpack会自动处理

// 3. 压缩库
// 用lodash-es替代lodash
import { debounce } from 'lodash-es'  // ✅ 支持Tree Shaking
// import { debounce } from 'lodash'  // ❌ 不支持

// 4. 延迟加载
// 路由级别
const Home = lazy(() => import('./Home'))
const Admin = lazy(() => import('./Admin'))
```

📍 优化图片
```html
<!-- 使用现代格式 -->
<picture>
  <source srcset="image.webp" type="image/webp" />
  <source srcset="image.png" type="image/png" />
  <img src="image.png" alt="..." />
</picture>

<!-- 响应式图片 -->
<img
  src="image.jpg"
  srcset="
    image-320w.jpg 320w,
    image-640w.jpg 640w,
    image-960w.jpg 960w"
  sizes="
    (max-width: 320px) 280px,
    (max-width: 640px) 600px,
    960px"
/>

<!-- 使用图片压缩服务 -->
<!-- CDN会根据客户端自动优化 -->
<img src="https://cdn.example.com/image.jpg?w=640&h=480" />

<!-- 懒加载 -->
<img src="..." loading="lazy" />
```

📍 优化渲染
```javascript
// 1. 移除渲染阻塞的CSS
// 内联关键CSS
<style>
  /* 首屏必需的样式 */
  body { margin: 0 }
  .header { background: blue }
</style>

// 延迟加载非关键CSS
<link rel="stylesheet" href="critical.css" />
<link rel="stylesheet" href="non-critical.css" media="print" onload="this.media='all'" />

// 2. 使用font-display优化字体
@font-face {
  font-family: 'MyFont';
  src: url('font.woff2');
  font-display: swap;  // ← 立即显示后备字体
}

// 3. 预加载关键资源
<link rel="preload" href="critical.js" as="script" />
<link rel="preload" href="style.css" as="style" />
<link rel="prefetch" href="future-page.js" />
```

📍 优化JavaScript执行
```javascript
// 1. 避免长任务
function processData() {
  const items = [/* 大数组 */]

  // ❌ 一次性处理，阻塞主线程
  items.forEach(process)

  // ✅ 分批处理
  const batchSize = 100
  for (let i = 0; i < items.length; i += batchSize) {
    requestAnimationFrame(() => {
      items.slice(i, i + batchSize).forEach(process)
    })
  }
}

// 2. 使用Web Worker处理密集计算
const worker = new Worker('worker.js')
worker.postMessage(heavyData)
worker.onmessage = (e) => {
  console.log('计算结果', e.data)
}

// 3. 防抖和节流
const debounce = (fn, delay) => {
  let timer
  return (...args) => {
    clearTimeout(timer)
    timer = setTimeout(() => fn(...args), delay)
  }
}

// 处理window resize
window.addEventListener('resize', debounce(() => {
  // 重新计算布局
}, 200))
```

📍 缓存策略
```javascript
// 1. HTTP缓存
// 服务器设置合适的Cache-Control头
// Cache-Control: public, max-age=31536000  // 一年
// 但使用[contenthash]确保内容变化时失效

// 2. Service Worker缓存
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open('v1').then(cache => {
      return cache.addAll([
        '/',
        '/index.html',
        '/styles.css',
        '/app.js'
      ])
    })
  )
})

// 3. LocalStorage/IndexedDB
// 缓存不经常变化的数据
localStorage.setItem('userData', JSON.stringify(user))

// 4. CDN缓存
// 静态资源部署到CDN
```

【第五步：监控和验证】

部署优化后：

```javascript
// 1. 配置真实用户监控(RUM)
if ('web-vital' in window) {
  import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
    getCLS(console.log)
    getFID(console.log)
    getFCP(console.log)
    getLCP(console.log)
    getTTFB(console.log)
  })
}

// 2. 发送给分析平台
class Analytics {
  track(metric) {
    navigator.sendBeacon('/api/metrics', JSON.stringify(metric))
  }
}

// 3. 设置告警
if (metric.value > threshold) {
  alert('性能下降！')
}
```

【我的优化检查清单】

```
加载性能
☐ 代码分割，减少首屏bundle
☐ 启用gzip压缩
☐ 使用CDN
☐ 图片优化（格式、尺寸、懒加载）
☐ 预加载关键资源
☐ 内联关键CSS

运行时性能
☐ 避免长任务（> 50ms）
☐ 使用requestAnimationFrame
☐ 虚拟化长列表
☐ 防抖/节流高频操作
☐ 使用Web Worker处理密集计算
☐ 避免频繁DOM操作

缓存策略
☐ 配置HTTP缓存
☐ 使用Service Worker
☐ LocalStorage缓存数据
☐ [contenthash]版本控制

监控
☐ 集成Lighthouse
☐ 配置RUM监控
☐ 设置性能告警
☐ 定期分析报告
```

【实战案例】

假设优化一个电商网站：

```
优化前：
- LCP: 5.2秒
- FID: 200ms
- 首屏bundle: 1.2MB

诊断发现：
1. 产品图片太大（每张1MB）
2. 第三方脚本阻塞渲染
3. 没有代码分割

优化方案：
1. 图片优化
   ✓ 转换为WebP，减小50%
   ✓ 添加响应式图片
   ✓ 启用懒加载
   结果：图片从500KB减至150KB

2. 脚本优化
   ✓ 延迟加载分析脚本
   ✓ 使用async加载非关键脚本
   ✓ 提取vendor bundle
   结果：首屏JS从700KB减至300KB

3. 代码分割
   ✓ 按路由分割：列表/详情/结算
   ✓ 按类别分割：搜索/推荐
   结果：首屏加载从1.2MB减至350KB

4. 缓存
   ✓ 设置长期缓存
   ✓ 启用Service Worker
   ✓ CDN缓存静态资源
   结果：重复访问速度提升5倍

优化后：
- LCP: 1.8秒 ✓
- FID: 80ms ✓
- 首屏加载: 350KB ✓

提升：65%的性能提升！
```
```

**让面试官觉得很棒的额外补充：**
```
如果面试官问"如何持续监控生产环境的性能？"

答案可以是：

我会搭建完整的性能监控系统：

1️⃣ 收集数据
- 使用Performance API和Web Vitals
- 采样率选择（100%会增加服务器负担）
- 发送到分析平台

2️⃣ 聚合分析
- 按地区、浏览器、设备等维度分析
- 识别异常情况
- 对比历史数据

3️⃣ 告警机制
- 性能下降时立即告警
- 关键指标监控
- 自动报告

4️⃣ 定期回顾
- 周报：关键指标趋势
- 月报：主要优化工作
- 季度评审：长期目标

这样能及时发现问题，快速响应。
```

**评分标准：**
- ⭐ 基础：知道Performance API，能用DevTools分析
- ⭐⭐ 良好：详细讲解常见瓶颈和优化方案
- ⭐⭐⭐ 优秀：讨论监控和持续改进，提供实战案例

---

## 面试答题的核心技巧

### 通用模板

所有好的技术面试答案都遵循这个模板：

```
1️⃣ 开场定义（10%）
   "这个问题涉及...，我从以下几个方面讲解"

2️⃣ 核心知识（50%）
   - 概念解释
   - 代码示例
   - 原理分析
   - 对比分析

3️⃣ 实战应用（25%）
   - 最佳实践
   - 常见误区
   - 真实案例

4️⃣ 深度思考（15%）
   - 为什么这样设计
   - 权衡和取舍
   - 相关扩展
```

### 高分答题特征

✅ **清晰的结构**
- "我分三点讲...首先...其次...最后..."
- 用序号、标题组织思路

✅ **丰富的例子**
- 每个概念都有代码示例
- 正面例子和反面例子对比

✅ **深度分析**
- 不止说"是什么"，还要说"为什么"
- 讨论原理和设计理由

✅ **实战经验**
- "在我的项目中..."
- "我遇到过..."
- "最佳实践是..."

✅ **主动扩展**
- 面试官问A，你讲解A后主动说"B也相关..."
- "如果追问会问到..."

✅ **诚实和谨慎**
- 不懂就说"我不确定，但我猜..."
- 不自信的地方坦白说"这是我的理解..."

### 回答有水平的信号

面试官会这样评价：

❌ 低水平："他/她知道这个概念"
✅ 中等水平："他/她能用好这个技术"
⭐ 高水平："他/她能教我关于这个技术的东西"
⭐⭐ 专家级："他/她在这个领域有独到见解"

要努力达到后两个水平！

---

## 总结

这份文档提供了8个高频面试题和标准答案。每个答案都：

✅ 从基础概念开始
✅ 用代码例子讲解原理
✅ 说明实战应用
✅ 讨论最佳实践
✅ 预留深度讨论空间

关键是：
1. **准备充分**：每道题至少练习3遍
2. **讲清楚**：用例子说明，不要只讲概念
3. **示弱得当**：不懂的地方说不懂，但说出你的理解
4. **主动扩展**：展现你的思考深度

祝面试顺利！💪

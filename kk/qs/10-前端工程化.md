# 前端工程化完整指南

## 考点概述

前端工程化是现代前端开发的基石，贯穿从项目初始化、开发、构建、测试到部署的整个生命周期。面试官关注的不仅是工具使用，更是对工程化思想的理解。

**核心考点分布：**
```
模块化开发 (20%)
构建工具 - Webpack/Vite (25%)
包管理与依赖 (15%)
代码质量管理 (15%)
自动化流程 (12%)
性能优化 (13%)
```

---

## 第一部分：模块化开发

### 1. 为什么需要模块化？

**通俗解释：**
模块化就像"把大房子分成小房间"：
- 每个房间有独立的功能
- 房间之间可以开门通话
- 不会互相干扰，便于管理

```
没有模块化的问题：
├─ 全局污染：所有变量都在全局作用域
│  └─ 问题：var a = 1; 后面又var a = 2，代码冲突
│
├─ 依赖混乱：文件加载顺序很重要
│  └─ 问题：<script>顺序错了，就崩溃
│
├─ 难以维护：改一个地方要改很多地方
│  └─ 问题：同一段逻辑复制在10个文件里
│
└─ 难以测试：无法独立测试某个功能
   └─ 问题：要测试util.js，必须先加载所有依赖
```

---

### 2. 模块化演进过程

**第一阶段：原始阶段**
```javascript
// file1.js
var moduleA = {
  name: 'module-a',
  fn: function() {}
}

// file2.js
var moduleA = {  // ← 覆盖了！全局污染！
  name: 'module-a-v2',
  fn: function() {}
}
```

**第二阶段：IIFE命名空间模式**
```javascript
// file1.js
var app = app || {}
app.moduleA = (function() {
  var count = 0  // ← 私有变量
  return {
    add: function() {
      count++
    }
  }
})()

// 使用
app.moduleA.add()
```

**第三阶段：模块规范**

```javascript
// ===== CommonJS (Node.js) =====
// math.js
module.exports = {
  add: function(a, b) { return a + b }
}

// app.js
const math = require('./math')
math.add(1, 2)

// ===== AMD (浏览器) =====
// math.js
define(['jquery'], function($) {
  return {
    add: function(a, b) { return a + b }
  }
})

// app.js
require(['math'], function(math) {
  math.add(1, 2)
})

// ===== ES Module (现代标准) =====
// math.js
export const add = (a, b) => a + b
export const subtract = (a, b) => a - b

// app.js
import { add, subtract } from './math'
add(1, 2)
```

---

### 3. CommonJS vs ES Module

**面试考点：为什么现在要用 ES Module？**

| 特性 | CommonJS | ES Module |
|------|----------|-----------|
| 加载时机 | 运行时 | 编译时 |
| 导出方式 | module.exports = | export |
| 导入方式 | require() | import |
| 异步支持 | ❌ | ✅ |
| Tree Shaking | ❌ | ✅ |
| 浏览器原生支持 | ❌ | ✅ |
| 循环依赖 | 可以 | 报错 |

```javascript
// ===== CommonJS - 运行时执行 =====
if (condition) {
  module.exports = {...}
} else {
  module.exports = {...}
}
// Webpack无法在编译时判断

// ===== ES Module - 编译时确定 =====
export const a = 1  // 明确知道导出什么
export const b = 2
// Webpack可以提前知道，没用的就删除
```

---

## 第二部分：构建工具深入

### 4. Webpack vs Vite

**面试经常问：为什么要用 Vite？**

```
╔════════════════════════════════════════════════════════════════╗
║                    Webpack 时代的问题                          ║
╚════════════════════════════════════════════════════════════════╝

问题1：冷启动慢
├─ 原因：需要构建整个依赖图
└─ 耗时：大项目可能需要10-30秒

问题2：热更新慢
├─ 原因：修改一个文件，要重新打包
└─ 耗时：可能需要5-10秒才能看到变化

问题3：构建体积大
├─ 原因：所有代码都打包到一起
└─ 问题：修改任何地方都会影响缓存

╔════════════════════════════════════════════════════════════════╗
║                   Vite 如何解决这些问题                       ║
╚════════════════════════════════════════════════════════════════╝

解决1：利用 ES Module 的原生支持
├─ 不需要预打包
├─ 浏览器直接请求源文件
└─ 冷启动从30秒 → 1秒

解决2：按需编译
├─ 修改一个文件，只编译这个文件
├─ 通过 HMR (Hot Module Replacement) 更新
└─ 热更新从10秒 → 100ms

解决3：生产构建用 Rollup
├─ 只在生产环节打包
├─ 开发不打包，充分利用浏览器缓存
└─ 生产构建优化充分
```

**对比表：**

| 指标 | Webpack | Vite |
|------|---------|------|
| 冷启动时间 | 30-60s | 1-3s |
| 热更新时间 | 5-10s | <100ms |
| 学习成本 | 高 | 低 |
| 生产优化 | 很好 | 很好 |
| 插件生态 | 完整 | 发展中 |
| 兼容性 | 好 | 较好 |

---

### 5. Vite 核心原理

**Vite 两阶段工作模式：**

```
╔═════════════════════════════════════════════════════════════╗
║                     开发阶段 (Dev Server)                    ║
╠═════════════════════════════════════════════════════════════╣
║                                                             ║
║  浏览器请求                                                  ║
║      │                                                      ║
║      ▼                                                      ║
║  Vite 捕获请求                                               ║
║      │                                                      ║
║      ├─ 如果是 .vue 文件                                     ║
║      │  └─ @vitejs/plugin-vue 转换为 JS                    ║
║      │                                                      ║
║      ├─ 如果是 TypeScript                                   ║
║      │  └─ esbuild 转换为 JS                               ║
║      │                                                      ║
║      ├─ 如果是普通 JS                                        ║
║      │  └─ 直接返回                                         ║
║      │                                                      ║
║      ▼                                                      ║
║  浏览器执行 ES Module 代码                                    ║
║                                                             ║
╚═════════════════════════════════════════════════════════════╝

╔═════════════════════════════════════════════════════════════╗
║                    生产阶段 (npm run build)                  ║
╠═════════════════════════════════════════════════════════════╣
║                                                             ║
║  运行 Rollup                                                 ║
║      │                                                      ║
║      ├─ 打包所有模块                                         ║
║      ├─ Tree Shaking                                        ║
║      ├─ 代码分割                                             ║
║      ├─ 压缩优化                                             ║
║      │                                                      ║
║      ▼                                                      ║
║  生成 dist/ 目录                                             ║
║      ├─ index.html                                          ║
║      ├─ main.[hash].js                                      ║
║      ├─ vendor.[hash].js                                    ║
║      └─ chunk.[hash].js                                     ║
║                                                             ║
╚═════════════════════════════════════════════════════════════╝
```

**Vite 配置示例：**

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  plugins: [
    vue()  // ← 支持.vue单文件组件
  ],

  // 别名配置
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  },

  // 开发服务器
  server: {
    port: 5173,
    open: true,  // 自动打开浏览器

    // 代理API请求
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  },

  // 构建配置
  build: {
    target: 'esnext',
    minify: 'terser',
    rollupOptions: {
      output: {
        // 分割策略
        manualChunks: {
          vue: ['vue'],
          'vue-router': ['vue-router'],
          pinia: ['pinia']
        }
      }
    }
  }
})
```

---

### 6. 理解 HMR (热模块替换)

**面试问：什么是HMR？为什么快？**

```
普通刷新 vs HMR：

普通刷新过程（F5）：
  1. 浏览器刷新页面
  2. 重新加载所有资源
  3. 重新执行所有JS
  4. 重新渲染页面
  5. 应用状态全部丢失
  耗时：3-5秒

HMR 过程：
  1. 编辑文件，保存
  2. Vite 检测到变化
  3. 编译新的模块代码
  4. 发送到浏览器
  5. 浏览器替换该模块
  6. 应用状态保留
  耗时：<100ms

关键优势：
├─ 状态保留：应用状态不丢失
├─ 部分更新：只更新改动的模块
└─ 快速反馈：实时看到变化
```

**如何使用 HMR：**

```javascript
// Vue 组件自动支持 HMR
<template>
  <div>
    <p>{{ count }}</p>
    <button @click="count++">+1</button>
  </div>
</template>

<script setup>
import { ref } from 'vue'
const count = ref(0)
// 修改这个文件保存时，count值保留！
</script>

// 自定义模块支持 HMR
if (import.meta.hot) {
  import.meta.hot.accept((newModule) => {
    // newModule 是更新后的模块
    console.log('模块已更新')
  })
}
```

---

## 第三部分：包管理与依赖

### 7. npm vs yarn vs pnpm

**面试考点：这三者有什么区别？什么时候用什么？**

```
╔══════════════════════════════════════════════════════════════╗
║                  依赖安装方式对比                            ║
╚══════════════════════════════════════════════════════════════╝

npm 方式（node_modules 地狱）：
project/
├── node_modules/
│   ├── react/
│   │   ├── node_modules/  ← React的依赖
│   │   │   ├── scheduler/
│   │   │   └── prop-types/
│   │   └── package.json
│   ├── vue/
│   │   ├── node_modules/  ← Vue的依赖
│   │   │   ├── esprima/
│   │   │   └── source-map/
│   │   └── package.json
│   └── ...其他包
└── package.json

问题：
✗ 嵌套太深，路径过长（Windows不支持）
✗ 相同的包被重复安装多次
✗ node_modules 体积巨大（1GB+）
✗ 安装速度慢
✗ 幻影依赖（可以用没声明的包）

yarn 方式（改进 npm）：
project/
├── node_modules/
│   ├── react/
│   │   └── package.json
│   ├── scheduler/  ← 提升到顶级
│   │   └── package.json
│   ├── vue/
│   │   └── package.json
│   └── ...
└── package.json

改进：
✓ 并行安装，速度快
✓ 更好的依赖提升（Hoist）
✓ yarn.lock 更严格
✗ 仍然有幻影依赖

pnpm 方式（最优方案）：
project/
├── node_modules/
│   ├── .pnpm/  ← 核心存储
│   │   ├── react@18.0.0/
│   │   ├── react-dom@18.0.0/
│   │   └── ...所有版本
│   ├── react → .pnpm/react@18.0.0/node_modules/react
│   ├── vue → .pnpm/vue@3.0.0/node_modules/vue
│   └── ...符号链接
├── pnpm-lock.yaml  ← 超精准 lock 文件
└── package.json

优势：
✓ 节省磁盘空间（共享存储）
✓ 安装速度最快
✓ 严格模式（不允许幻影依赖）
✓ 依赖版本隔离
✓ monorepo 支持最好
```

**选择建议：**

```javascript
// 新项目，个人项目：用 pnpm
npm install -g pnpm
pnpm init

// 公司项目，需要兼容性：用 yarn
npm install -g yarn
yarn init

// 学习、小项目：用 npm（预装）
npm init

// monorepo 项目：必须用 pnpm
```

---

### 8. 语义化版本 (SemVer)

**面试必考：版本号的含义？**

```
版本格式：MAJOR.MINOR.PATCH
示例：1.2.3

MAJOR (主版本号)：做了不兼容的API改动
MINOR (次版本号)：增加了兼容的新功能
PATCH (补丁版本号)：修复了bug

示例：
1.0.0 - 初始版本
1.1.0 - 增加了新功能，向下兼容
1.1.1 - 修复了一个bug
2.0.0 - 破坏性改动，不兼容1.x

package.json 中的版本符号：
"vue": "^3.2.0"  ← 插入符（Caret）
  └─ 可以自动更新到 3.x.x（不改变主版本）
  └─ 即：3.2.0, 3.2.1, 3.3.0 都可以

"vue": "~3.2.0"  ← 波浪符（Tilde）
  └─ 可以自动更新到 3.2.x（不改变主次版本）
  └─ 即：3.2.0, 3.2.1 可以，3.3.0不行

"vue": "3.2.0"   ← 精确版本（不推荐）
  └─ 只能用 3.2.0，不灵活

推荐做法：
✓ package.json：使用 ^（允许向下兼容的更新）
✓ package-lock.json / pnpm-lock.yaml：锁定具体版本
```

---

## 第四部分：代码质量管理

### 9. ESLint - 代码检查

**为什么需要 ESLint？**

```javascript
// ❌ 问题代码（ESLint能检查出来）

// 问题1：声明未使用
const unused = 123

// 问题2：使用未声明的变量
console.log(undeclaredVar)

// 问题3：使用 var（容易出问题）
var count = 0
for (var i = 0; i < 10; i++) {
  setTimeout(() => console.log(i), 0)  // 全是10
}

// 问题4：没有分号（风格不一致）
const name = 'John'
const age = 30

// 问题5：没有 break（switch 穿透）
switch(type) {
  case 'admin':
    grantPermissions()
    // 忘写 break，会继续执行下面的
  case 'user':
    grantBasicAccess()
    break
}

// 问题6：嵌套太深（代码复杂）
if (a) {
  if (b) {
    if (c) {
      if (d) {
        // 太深了，难以维护
      }
    }
  }
}
```

**ESLint 配置：**

```javascript
// .eslintrc.js
module.exports = {
  // 选择预设规则集
  extends: [
    'eslint:recommended',      // ← 推荐规则
    'plugin:vue/vue3-recommended',  // ← Vue3规则
    'prettier'                 // ← 与Prettier兼容
  ],

  // 解析器（支持最新语法）
  parser: '@babel/eslint-parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module'
  },

  // 环境（定义全局变量）
  env: {
    browser: true,      // window, document等
    node: true,         // global, process等
    es2021: true,       // 最新的ES特性
    jest: true          // jest 测试框架
  },

  // 自定义规则
  rules: {
    // 错误级别：'off' 关闭, 'warn' 警告, 'error' 错误
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-unused-vars': 'warn',
    'semi': ['error', 'never'],  // 不要分号
    'quotes': ['error', 'single'], // 单引号
    'indent': ['error', 2],       // 2空格缩进
    'comma-dangle': ['error', 'never'],  // 末尾不要逗号
  }
}
```

**package.json 中集成：**

```json
{
  "scripts": {
    "lint": "eslint src/**/*.{js,vue}",
    "lint:fix": "eslint src/**/*.{js,vue} --fix"
  },
  "devDependencies": {
    "eslint": "^8.0.0",
    "eslint-plugin-vue": "^9.0.0"
  }
}
```

---

### 10. Prettier - 代码格式化

**ESLint vs Prettier：**

```
┌─────────────────────────────────────────────────┐
│ ESLint - 检查代码质量（找问题）                 │
├─────────────────────────────────────────────────┤
│ 检查项：                                        │
│ ✓ 变量未使用                                    │
│ ✓ 使用 === 而不是 ==                            │
│ ✓ 不要用 eval                                   │
│ ✗ 不关心代码格式（只要有效就行）                │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│ Prettier - 格式化代码（修复格式）               │
├─────────────────────────────────────────────────┤
│ 格式化项：                                      │
│ ✓ 缩进（2 空格 vs 4 空格）                     │
│ ✓ 引号（单引号 vs 双引号）                     │
│ ✓ 分号（加 vs 不加）                           │
│ ✓ 括号间距                                      │
│ ✓ 行宽（80 vs 100 vs 120）                     │
│ ✗ 不检查代码逻辑问题                            │
└─────────────────────────────────────────────────┘

最佳实践：ESLint + Prettier 搭配
```

**Prettier 配置：**

```javascript
// .prettierrc.js
module.exports = {
  // 行宽
  printWidth: 100,

  // 缩进
  tabWidth: 2,
  useTabs: false,

  // 引号
  singleQuote: true,

  // 末尾逗号
  trailingComma: 'es5',

  // 对象空格
  bracketSpacing: true,

  // 分号
  semi: false,

  // 箭头函数参数
  arrowParens: 'always'
}

// .prettierignore
node_modules
dist
coverage
*.md
```

**集成到编辑器：**

```json
// .vscode/settings.json
{
  // 保存时自动格式化
  "editor.formatOnSave": true,

  // 使用Prettier作为默认格式化工具
  "editor.defaultFormatter": "esbenp.prettier-vscode",

  // Vue文件也格式化
  "[vue]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  }
}
```

---

### 11. husky + lint-staged - Git钩子

**面试问：如何保证提交的代码质量？**

```
没有 Git 钩子的问题：
├─ 开发者提交代码前不检查
├─ ESLint 错误被上传到仓库
├─ 构建时才发现问题，浪费时间
└─ 代码风格混乱

使用 Git 钩子的流程：
  开发者修改文件
      ↓
  git add .
      ↓
  git commit -m "message"
      ↓
  husky 拦截 commit
      ↓
  lint-staged 运行 lint 和 prettier
      ↓
  如果有错误，commit 失败
      ↓
  修复错误，重新 commit
      ↓
  检查通过，commit 成功
```

**安装和配置：**

```bash
# 安装
npm install husky lint-staged --save-dev

# 初始化 husky
npx husky install

# 创建 pre-commit 钩子
npx husky add .husky/pre-commit "npx lint-staged"

# 创建 commit-msg 钩子（校验提交信息）
npx husky add .husky/commit-msg 'npx --no -- commitlint --edit "$1"'
```

**package.json 配置：**

```json
{
  "lint-staged": {
    "src/**/*.{js,vue}": [
      "eslint --fix",
      "prettier --write"
    ],
    "src/**/*.css": [
      "prettier --write"
    ]
  },
  "devDependencies": {
    "husky": "^8.0.0",
    "lint-staged": "^13.0.0"
  }
}
```

---

## 第五部分：自动化流程

### 12. 持续集成 (CI/CD)

**什么是 CI/CD？**

```
CI (Continuous Integration) - 持续集成：
  代码提交 → 自动运行测试 → 自动检查质量 → 通过则合并

CD (Continuous Deployment) - 持续部署：
  代码合并 → 自动构建 → 自动部署到生产环境

完整流程：
  ┌─────────────┐
  │ 开发者      │
  │ git push    │
  └──────┬──────┘
         │
         ▼
  ┌─────────────┐
  │ GitHub      │
  │ Webhook     │
  │ 触发        │
  └──────┬──────┘
         │
         ▼
  ┌─────────────────────────────┐
  │ CI/CD Pipeline              │
  ├─────────────────────────────┤
  │ 1. 代码检查 (lint)          │
  │ 2. 运行测试 (test)          │
  │ 3. 构建应用 (build)         │
  │ 4. 部署 (deploy)            │
  └──────┬──────────────────────┘
         │
         ├─ 失败 → 通知开发者 → 修复
         │
         └─ 成功 → 发布到生产 → 完成
```

**GitHub Actions 配置示例：**

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test-and-build:
    runs-on: ubuntu-latest

    steps:
      # 步骤1：拉取代码
      - uses: actions/checkout@v3

      # 步骤2：安装 Node.js
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      # 步骤3：安装依赖
      - name: Install dependencies
        run: npm ci

      # 步骤4：代码检查
      - name: Lint code
        run: npm run lint

      # 步骤5：运行测试
      - name: Run tests
        run: npm run test:unit

      # 步骤6：构建项目
      - name: Build project
        run: npm run build

      # 步骤7：部署（仅main分支）
      - name: Deploy to production
        if: github.ref == 'refs/heads/main'
        run: npm run deploy
        env:
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
```

---

### 13. 提交规范 (Conventional Commits)

**为什么需要提交规范？**

```
问题1：提交信息混乱
  ❌ "fix" "修复" "qqq" "临时提交"
  ✓ 看不出做了什么

问题2：无法自动生成 Changelog
  ❌ 手动整理发版日志，很麻烦
  ✓ 从提交信息中自动生成

问题3：无法追踪改动
  ❌ git log 一片混乱
  ✓ 无法快速找到某个功能

解决：采用 Conventional Commits 规范
```

**提交信息格式：**

```
<type>(<scope>): <subject>
<BLANK LINE>
<body>
<BLANK LINE>
<footer>

示例1：
fix(auth): fix login validation error
改进了登录验证的错误处理

示例2：
feat(dashboard): add user statistics widget

Added a new widget to display user statistics:
- Monthly active users chart
- User growth trend
- Device distribution

Closes #123

---

type 类型（必需）：
  feat      - 新功能 (MINOR)
  fix       - bug 修复 (PATCH)
  docs      - 文档修改
  style     - 代码风格改动（无逻辑改变）
  refactor  - 代码重构（不改变功能）
  perf      - 性能优化
  test      - 测试相关
  chore     - 构建流程、依赖更新等

scope 作用域（可选）：
  影响的模块或组件
  如：auth, api, ui, database

subject 主题（必需）：
  短描述（50字以内）
  以命令式口吻描述改动

body 正文（可选）：
  详细描述改动
  为什么这样改
  解决的问题

footer 页脚（可选）：
  关闭的issue
  Breaking Changes
```

**集成 commitlint：**

```bash
# 安装
npm install commitlint @commitlint/config-conventional --save-dev

# 创建配置
echo "module.exports = { extends: ['@commitlint/config-conventional'] }" > commitlint.config.js

# 创建 Git 钩子
npx husky add .husky/commit-msg 'npx --no -- commitlint --edit "$1"'
```

**自动生成 Changelog：**

```bash
# 安装 standard-version
npm install standard-version --save-dev

# 运行一次
npx standard-version

# 自动：
# 1. 根据提交信息生成 CHANGELOG.md
# 2. 升级 package.json 版本号
# 3. 创建 Git tag
# 4. 提交修改

# package.json 添加脚本
{
  "scripts": {
    "release": "standard-version"
  }
}
```

---

## 第六部分：性能优化

### 14. 构建体积优化

**面试考点：如何优化 bundle 体积？**

```
常见体积问题：

问题1：依赖包太大
  ├─ moment.js (67KB) vs day.js (2KB)
  ├─ lodash (19KB) vs lodash-es (可 tree-shake)
  └─ 解决：选择轻量级库

问题2：代码没有压缩
  ├─ 注释、空白、长变量名都被保留
  └─ 解决：terser 压缩 JS，cssnano 压缩 CSS

问题3：Tree Shaking 不生效
  ├─ 使用了 CommonJS
  ├─ package.json 标记了 sideEffects
  └─ 解决：用 ES Module + 正确配置

问题4：重复代码
  ├─ 相同的库被打包多次
  └─ 解决：代码分割，提取公共代码

问题5：大型库未按需加载
  ├─ 引入整个库，但只用了一小部分
  └─ 解决：按需导入

问题6：Polyfill 太多
  ├─ 为了兼容旧浏览器，引入大量 polyfill
  └─ 解决：按需加载 polyfill
```

**具体优化方案：**

```javascript
// ❌ 错误方式
import _ from 'lodash'  // 整个库都打包，19KB
const result = _.debounce(fn, 300)

// ✅ 正确方式1：按需导入
import debounce from 'lodash-es/debounce'  // 只有 debounce，0.5KB
const result = debounce(fn, 300)

// ✅ 正确方式2：使用更小的库
import { debounce } from 'lodash-es'
// 借助 tree-shaking 只包含 debounce

// --- moment 示例 ---

// ❌ 整个 moment.js (67KB)
import moment from 'moment'
const date = moment().format('YYYY-MM-DD')

// ✅ 使用 day.js (2KB)
import dayjs from 'dayjs'
const date = dayjs().format('YYYY-MM-DD')
```

**Vite 体积分析：**

```javascript
// vite.config.js
import { visualizer } from 'rollup-plugin-visualizer'

export default {
  plugins: [
    visualizer({
      open: true,  // 自动打开分析报告
      gzipSize: true
    })
  ]
}

// 运行
npm run build
// 会生成一个可视化图表，显示各个包的体积
```

---

### 15. 运行时性能优化

**核心指标：**

```
LCP (Largest Contentful Paint) - 最大内容绘制
├─ 定义：可视区域最大元素渲染完成的时间
├─ 目标：< 2.5s
└─ 优化：
   - 减少首屏 JS 体积
   - 优化图片加载
   - 使用 CDN

FID (First Input Delay) - 首次输入延迟
├─ 定义：用户首次交互到浏览器响应的延迟
├─ 目标：< 100ms
└─ 优化：
   - 减少主线程阻塞
   - 使用 Web Worker
   - 分解长任务

CLS (Cumulative Layout Shift) - 累积布局移位
├─ 定义：页面加载过程中的意外布局移位
├─ 目标：< 0.1
└─ 优化：
   - 为图片指定尺寸
   - 避免动态插入内容
   - 使用 transform 动画
```

**代码优化示例：**

```javascript
// ❌ 问题：长任务阻塞主线程
function processLargeData(data) {
  const result = []
  for (let i = 0; i < data.length; i++) {
    // 耗时计算
    const processed = heavyCompute(data[i])
    result.push(processed)
  }
  return result
}

// ✅ 解决：分割任务
function* processLargeDataGenerator(data) {
  for (let i = 0; i < data.length; i++) {
    yield heavyCompute(data[i])
  }
}

function processLargeDataAsync(data) {
  const generator = processLargeDataGenerator(data)
  const result = []

  return new Promise((resolve) => {
    function processChunk() {
      const startTime = performance.now()

      // 在 5ms 内处理尽可能多的数据
      while (performance.now() - startTime < 5) {
        const { value, done } = generator.next()
        if (done) {
          resolve(result)
          return
        }
        result.push(value)
      }

      // 让出主线程，下一帧继续
      requestIdleCallback(processChunk)
    }

    processChunk()
  })
}
```

---

## 第七部分：高频面试题答题方案

### 16. 经典面试题

**题目 1：说说 Webpack 的打包原理**

```
标准答案思路：

1️⃣ 初始化阶段（Initialization）
  ├─ 读取 webpack.config.js 配置
  ├─ 创建 Compiler 实例
  ├─ 注册所有插件
  └─ 准备开始编译

2️⃣ 编译阶段（Compilation）
  ├─ 从 entry 开始递归解析依赖
  ├─ 每个文件经过对应的 loader 处理
  │  └─ JS/TS → babel-loader 转换
  │  └─ CSS → css-loader 处理
  │  └─ Vue → vue-loader 处理
  ├─ 解析代码的 AST，提取依赖关系
  └─ 输出：Module Dependency Graph（依赖图）

3️⃣ 优化阶段（Optimization）
  ├─ Tree Shaking：删除未使用代码
  ├─ Code Splitting：分割代码块
  ├─ 去重：同一包只保留一份
  └─ 压缩：移除注释和空白

4️⃣ 生成阶段（Generation）
  ├─ 根据优化后的依赖图
  ├─ 使用 Template 生成最终代码
  ├─ 生成 source map 供调试
  └─ 输出：可执行的 JS 文件

5️⃣ 输出阶段（Emit）
  ├─ 将文件写入文件系统
  ├─ 执行插件的 emit 钩子
  └─ 生成 HTML、source map 等

核心概念：
- Entry：应用入口
- Loader：处理非 JS 资源的转换器
- Plugin：增强 Webpack 功能的钩子
- Output：输出配置
```

**题目 2：Webpack 的 Loader 和 Plugin 有什么区别？**

```
Loader - 文件转换器：
├─ 职责：转换某种类型的文件
├─ 输入：文件内容（字符串）
├─ 输出：转换后的内容
├─ 执行时机：编译阶段
├─ 链式调用：是（从右到左）
└─ 使用场景：
   - .vue → JavaScript
   - TypeScript → JavaScript
   - CSS → JavaScript
   - 图片 → Data URL

Plugin - 功能增强器：
├─ 职责：在某个阶段执行特定操作
├─ 输入：Webpack 的编译过程
├─ 输出：修改/增强编译过程
├─ 执行时机：整个生命周期
├─ 调用方式：在特定钩子上注册回调
└─ 使用场景：
   - 生成 HTML
   - 提取 CSS
   - 压缩代码
   - 定义全局变量

类比：
Loader  = 翻译官（翻译某种语言）
Plugin  = 项目经理（管理整个流程）
```

**题目 3：如何优化 Webpack 构建速度？**

```
从三个角度优化：

1️⃣ 缩小编译范围
  └─ exclude/include：不处理 node_modules
     module: {
       rules: [{
         test: /\.js$/,
         exclude: /node_modules/,  // ← 关键
         use: 'babel-loader'
       }]
     }

2️⃣ 使用缓存
  ├─ Babel 缓存：cacheDirectory: true
  ├─ 文件系统缓存：webpack 5+ 自动启用
  └─ 示例：
     {
       loader: 'babel-loader',
       options: { cacheDirectory: true }
     }

3️⃣ 使用多进程
  └─ thread-loader：多核 CPU 并行编译
     {
       test: /\.js$/,
       use: ['thread-loader', 'babel-loader']
     }

4️⃣ 优化 source map
  └─ 开发：eval-cheap-module-source-map（快）
  └─ 生产：source-map（准确）

5️⃣ 使用 Vite
  └─ 开发不打包，直接使用 ES Module
  └─ 冷启动：30s → 1s
  └─ 热更新：10s → 100ms
```

**题目 4：说说 Tree Shaking 的原理**

```
Tree Shaking 是什么：
  删除代码中未使用的部分

为什么能做到：
  ├─ ES Module 是静态导出（编译时知道）
  ├─ CommonJS 是动态导出（运行时才知道）
  └─ Webpack 在编译时就能分析出哪些代码没用

实现步骤：
  1️⃣ 静态分析：标记所有导出的代码
  2️⃣ 追踪使用：找出哪些代码被使用
  3️⃣ 标记死代码：未使用的代码标记为死代码
  4️⃣ 压缩阶段：删除标记的死代码

配置要点：
  1️⃣ mode: 'production'（自动启用）
  2️⃣ usedExports: true（标记未使用）
  3️⃣ package.json 的 sideEffects 字段
     - "sideEffects": false  // 所有文件都可以 tree-shake
     - "sideEffects": ["*.css"]  // CSS 文件不能 tree-shake

常见问题：
  Q：为什么我的代码没有被 tree-shake？
  A：可能原因：
    1. 用的是 CommonJS（require）
    2. 引入了整个包，没有 export
    3. 代码有副作用（import './style.css'）
```

**题目 5：npm、yarn、pnpm 的区别是什么？**

```
核心差异：依赖储存方式

npm:
  node_modules 中嵌套安装
  问题：
  - 路径过长（Windows 有限制）
  - 重复安装（同一包多个版本都保存）
  - 幻影依赖（可以用没声明的包）

yarn:
  改进的 npm，并行安装、更快
  改进：
  - 并行下载，速度快
  - Hoist（提升）依赖到顶层
  - yarn.lock 更精确
  问题：
  - 仍有幻影依赖

pnpm:
  最新最优的方案
  优势：
  ✓ 节省磁盘空间（共享存储）
  ✓ 安装速度最快（并行）
  ✓ 严格模式（不允许幻影依赖）
  ✓ monorepo 支持最好
  ✓ 兼容 npm / yarn 命令

推荐：
  ├─ 新项目：用 pnpm
  ├─ 公司项目：用 yarn（兼容）
  ├─ 学习：用 npm（预装）
  └─ monorepo：必须用 pnpm
```

**题目 6：什么是模块化，为什么需要模块化？**

```
模块化是什么：
  将代码分割成独立的、可复用的单元（模块）

为什么需要模块化：

1️⃣ 避免全局污染
  ❌ var count = 1; var count = 2;  // 后面的覆盖前面的
  ✅ 模块内部是私有作用域

2️⃣ 解决依赖混乱
  ❌ <script>a.js</script> <script>b.js</script> <script>c.js</script>
     必须按顺序加载，容易出错
  ✅ 模块化管理依赖关系

3️⃣ 便于维护和测试
  ❌ 代码重复、散落各处
  ✅ 模块可独立维护和测试

4️⃣ 促进代码复用
  ❌ 相同的逻辑复制多次
  ✅ 提取成模块，多处引用

模块化规范演进：
  IIFE → CommonJS → AMD → ES Module
```

**题目 7：介绍一下 ESLint 和 Prettier，它们有什么区别？**

```
ESLint：代码质量检查工具
  检查项：
  ✓ 变量是否声明
  ✓ 是否有未使用的代码
  ✓ 是否用了 == 而不是 ===
  ✓ 函数是否太复杂
  ✗ 代码格式（空格、缩进等）

Prettier：代码格式化工具
  格式化项：
  ✓ 缩进（空格 vs Tab）
  ✓ 引号（单 vs 双）
  ✓ 分号（加 vs 不加）
  ✓ 括号空格
  ✗ 代码逻辑和质量

总结：
  ESLint = 质量检查（找问题）
  Prettier = 格式化（修复格式）
  结合使用 = 代码质量 + 风格统一

配置建议：
  1. eslint + prettier 都安装
  2. .eslintrc.js 中 extends 中加入 'prettier'
  3. .prettierrc.js 配置格式规则
  4. husky + lint-staged 在提交前检查
```

**题目 8：怎样保证代码提交的质量？**

```
方案：husky + lint-staged + commitlint

流程：
  开发者 git commit
       ↓
  husky 拦截（pre-commit 钩子）
       ↓
  lint-staged 运行检查
       ├─ ESLint 检查代码
       ├─ Prettier 格式化
       ├─ 运行测试
       └─ 运行类型检查
       ↓
  检查通过 → commit 成功
  检查失败 → commit 失败，展示错误

提交信息规范（commitlint）：
  feat(scope): 描述
  fix(scope): 描述
  docs: 描述
  style: 描述
  ...

配置步骤：
  1. npm install husky lint-staged --save-dev
  2. npx husky install
  3. 在 .husky/pre-commit 中配置 lint-staged
  4. 在 package.json 中配置 lint-staged 任务
  5. 运行 npm run lint:fix
```

---

## 第八部分：工程化工具集成示例

### 17. 完整项目工程化配置

```javascript
// ============ 项目结构 ============
project/
├── src/
│   ├── pages/
│   ├── components/
│   ├── utils/
│   ├── types/
│   ├── App.vue
│   └── main.ts
├── tests/
├── .github/workflows/
│   └── ci.yml
├── .husky/
│   ├── pre-commit
│   └── commit-msg
├── vite.config.ts
├── tsconfig.json
├── .eslintrc.js
├── .prettierrc.js
├── package.json
└── README.md

// ============ vite.config.ts ============
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true
      }
    }
  },
  build: {
    outDir: 'dist',
    target: 'esnext',
    minify: 'terser'
  }
})

// ============ package.json ============
{
  "name": "my-project",
  "version": "1.0.0",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint src --ext .ts,.vue",
    "lint:fix": "eslint src --ext .ts,.vue --fix",
    "format": "prettier --write src",
    "test": "vitest",
    "prepare": "husky install",
    "release": "standard-version"
  },
  "dependencies": {
    "vue": "^3.3.0",
    "vue-router": "^4.2.0",
    "pinia": "^2.1.0"
  },
  "devDependencies": {
    "vite": "^4.4.0",
    "@vitejs/plugin-vue": "^4.3.0",
    "typescript": "^5.1.0",
    "eslint": "^8.45.0",
    "eslint-plugin-vue": "^9.15.0",
    "prettier": "^3.0.0",
    "husky": "^8.0.0",
    "lint-staged": "^13.2.0",
    "commitlint": "^17.6.0",
    "vitest": "^0.34.0"
  },
  "lint-staged": {
    "src/**/*.{ts,vue}": [
      "eslint --fix",
      "prettier --write"
    ],
    "src/**/*.css": [
      "prettier --write"
    ]
  }
}

// ============ .eslintrc.js ============
module.exports = {
  root: true,
  env: {
    browser: true,
    node: true,
    es2021: true
  },
  extends: [
    'eslint:recommended',
    'plugin:vue/vue3-recommended',
    'plugin:@typescript-eslint/recommended',
    'prettier'
  ],
  parser: 'vue-eslint-parser',
  parserOptions: {
    parser: '@typescript-eslint/parser',
    ecmaVersion: 'latest',
    sourceType: 'module'
  },
  rules: {
    'no-unused-vars': 'off',
    '@typescript-eslint/no-unused-vars': 'warn',
    'vue/multi-word-component-names': 'off'
  }
}

// ============ .prettierrc.js ============
module.exports = {
  printWidth: 100,
  tabWidth: 2,
  useTabs: false,
  singleQuote: true,
  semi: false,
  trailingComma: 'es5',
  bracketSpacing: true,
  arrowParens: 'always'
}

// ============ .github/workflows/ci.yml ============
name: CI
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18
      - run: npm ci
      - run: npm run lint
      - run: npm run test
      - run: npm run build
```

---

## 快速自测清单

### 核心概念
- [ ] 能解释什么是模块化及其必要性吗？
- [ ] 知道 CommonJS、AMD 和 ES Module 的区别吗？
- [ ] 理解 Webpack 的 5 个打包阶段吗？
- [ ] 知道 Loader 和 Plugin 的本质区别吗？
- [ ] 能解释 Tree Shaking 的原理吗？

### 工具使用
- [ ] 理解 Webpack 和 Vite 的区别及选择依据吗？
- [ ] 知道 npm、yarn、pnpm 各自的优劣吗？
- [ ] 能写出基本的 ESLint 和 Prettier 配置吗？
- [ ] 知道如何使用 husky 和 lint-staged 吗？
- [ ] 理解 Conventional Commits 规范吗？

### 性能优化
- [ ] 能列举 5 种以上的优化 bundle 体积的方法吗？
- [ ] 知道如何使用代码分割吗？
- [ ] 理解缓存的几种 hash 方案吗？
- [ ] 能解释 LCP、FID、CLS 这些性能指标吗？
- [ ] 知道如何分析 bundle 体积吗？

### 最佳实践
- [ ] 能搭建一个完整的工程化项目吗？
- [ ] 知道如何配置 CI/CD 流程吗？
- [ ] 理解提交规范和自动化检查的流程吗？
- [ ] 能自定义配置 ESLint 和 Prettier 吗？
- [ ] 知道如何优化开发体验吗？

---

## 参考资源

```
官方文档：
- Webpack: https://webpack.js.org/
- Vite: https://vitejs.dev/
- Vue: https://vuejs.org/

深入学习：
- Webpack 打包原理：模块化 → 依赖图 → Bundle
- Vite 按需编译：开发快速 → 生产完整
- 性能优化：从 Web Vitals 的三个指标出发

实战项目：
- 搭建 Vite + Vue 3 + TypeScript 项目
- 配置完整的 Lint 和 Format 流程
- 实现 CI/CD Pipeline
```

---

**版本历史：**
- v1.0 - 完整的前端工程化指南（涵盖所有高频面试考点）

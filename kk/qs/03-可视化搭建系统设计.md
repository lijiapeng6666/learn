# 可视化搭建系统设计

## 考点概述
可视化搭建（Visual Builder/Low-Code Builder）是现代前端的关键能力，用于快速生成页面和应用而无需手写代码。核心是理解如何将UI设计转化为可执行的代码。

---

## 核心概念

### 1. 什么是可视化搭建
**通俗解释：**
就像用乐高积木搭房子：
- **传统开发** - 从头写代码，就像手工制作房子的每个零件
- **可视化搭建** - 拖拽现成的组件，就像直接拼接现成的积木

**优势：**
```
传统开发 (编码)
├─ 效率：需要手写所有代码 (10%)
├─ 学习成本：需要懂编程 (100%)
├─ 灵活性：完全自由 (100%)
└─ 维护：代码多，维护成本高 (50%)

可视化搭建 (拖拽)
├─ 效率：快速生成页面 (50%)
├─ 学习成本：不需要懂编程 (20%)
├─ 灵活性：受限于预设组件 (60%)
└─ 维护：结构清晰，易维护 (80%)

最佳实践 (混合)
└─ 简单页面用可视化搭建，复杂逻辑用代码
```

---

## 系统架构设计

### 2. Amis 架构参考
**百度 Amis 是业界最成熟的可视化搭建方案**

**核心三层架构：**
```
┌─────────────────────────────────────────┐
│         编辑器 (Editor)                  │ ← 用户界面
│    - 组件库面板                         │
│    - 画布区域                           │
│    - 属性编辑面板                       │
└──────────────┬──────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────┐
│      Schema JSON (配置文件)              │ ← 数据格式
│  {                                      │
│    "type": "page",                      │
│    "body": [                            │
│      {                                  │
│        "type": "form",                  │
│        "fields": [{...}]                │
│      },                                 │
│      {                                  │
│        "type": "table",                 │
│        "columns": [{...}]               │
│      }                                  │
│    ]                                    │
│  }                                      │
└──────────────┬──────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────┐
│      渲染器 (Renderer)                   │ ← 执行层
│   - 根据Schema解析                      │
│   - 动态创建组件                        │
│   - 处理交互事件                        │
└─────────────────────────────────────────┘
```

---

## 详细设计方案

### 3. Schema JSON 格式设计
**什么是Schema？**
Schema是描述UI结构的JSON配置文件。让我们看一个实际例子：

```json
{
  "type": "page",
  "title": "用户管理系统",
  "body": [
    {
      "type": "search-form",
      "name": "userFilter",
      "api": "/api/users",
      "fields": [
        {
          "type": "text",
          "name": "username",
          "label": "用户名",
          "placeholder": "请输入用户名",
          "validation": "required"
        },
        {
          "type": "select",
          "name": "role",
          "label": "角色",
          "options": [
            { "label": "管理员", "value": "admin" },
            { "label": "普通用户", "value": "user" }
          ]
        }
      ],
      "submitText": "搜索"
    },
    {
      "type": "table",
      "name": "userTable",
      "source": "${userFilter.data}",
      "columns": [
        {
          "name": "id",
          "label": "ID",
          "type": "text"
        },
        {
          "name": "username",
          "label": "用户名",
          "type": "text"
        },
        {
          "name": "email",
          "label": "邮箱",
          "type": "text"
        },
        {
          "name": "role",
          "label": "角色",
          "type": "tag"
        },
        {
          "name": "actions",
          "label": "操作",
          "type": "operation",
          "buttons": [
            {
              "type": "button",
              "label": "编辑",
              "actionType": "dialog",
              "dialog": {
                "title": "编辑用户",
                "body": { "type": "form", "fields": [...] }
              }
            },
            {
              "type": "button",
              "label": "删除",
              "actionType": "confirm",
              "confirmText": "确定删除？",
              "api": "/api/users/${id}",
              "method": "delete"
            }
          ]
        }
      ]
    }
  ]
}
```

**Schema的特点：**
```
优势：
✅ 声明式：描述"是什么"，不是"怎么做"
✅ 易于序列化：可以保存到数据库
✅ 动态性：可以在运行时动态修改
✅ 跨平台：同一个Schema可在不同平台使用

不足：
❌ 灵活性有限：复杂逻辑表达困难
❌ 学习成本：需要学习Schema规范
❌ 调试困难：问题难以定位
```

---

### 4. 编辑器设计（Editor）

**核心功能模块：**
```
编辑器
├─ 组件库面板（Components Panel）
│  ├─ 基础组件（Basic）
│  │  ├─ 文本框 (TextInput)
│  │  ├─ 选择框 (Select)
│  │  ├─ 日期选择 (DatePicker)
│  │  └─ ...
│  ├─ 容器组件（Container）
│  │  ├─ 表单 (Form)
│  │  ├─ 表格 (Table)
│  │  ├─ 弹窗 (Dialog)
│  │  └─ ...
│  └─ 业务组件（Business）
│     ├─ 用户选择 (UserPicker)
│     ├─ 图表 (Chart)
│     └─ ...
│
├─ 画布区域（Canvas Area）
│  ├─ 实时预览
│  ├─ 拖拽放置
│  ├─ 选中定位
│  └─ 辅助线对齐
│
├─ 属性编辑面板（Property Panel）
│  ├─ 基础属性
│  │  ├─ name (字段名)
│  │  ├─ label (标签)
│  │  ├─ type (组件类型)
│  │  └─ ...
│  ├─ 样式属性
│  │  ├─ width
│  │  ├─ height
│  │  ├─ margin
│  │  └─ ...
│  ├─ 事件配置
│  │  ├─ onClick
│  │  ├─ onChange
│  │  └─ ...
│  └─ 高级配置
│     ├─ 动态绑定
│     ├─ 条件显示
│     └─ ...
│
└─ 代码预览（Code Preview）
   └─ 实时显示生成的Schema
```

**编辑器实现要点：**
```typescript
// 编辑器核心类
class VisualBuilder {
  // 存储当前Schema
  schema: SchemaObject

  // 存储组件元数据（每个组件的定义）
  componentRegistry: Map<string, ComponentMeta>

  // 操作历史（撤销/重做）
  history: HistoryManager

  // 选中的组件引用
  selectedComponent: ComponentNode

  // 添加组件
  addComponent(type: string, props: any) {
    const component = new ComponentNode(type, props)
    this.schema.body.push(component)
    this.history.push('add', component)
  }

  // 删除组件
  removeComponent(id: string) {
    const index = this.schema.body.findIndex(c => c.id === id)
    this.schema.body.splice(index, 1)
    this.history.push('remove', id)
  }

  // 更新属性
  updateProperty(componentId: string, key: string, value: any) {
    const component = this.findComponent(componentId)
    component[key] = value
    this.history.push('update', { componentId, key, value })
  }

  // 生成预览
  render() {
    return new Renderer().render(this.schema)
  }

  // 导出Schema
  export(): SchemaObject {
    return JSON.stringify(this.schema)
  }
}
```

---

### 5. 渲染器设计（Renderer）

**渲染流程：**
```
Schema JSON
    ↓
解析器 (Parser)
    ↓ 逐个处理每个节点
组件工厂 (Factory)
    ↓ 根据type创建对应组件
Vue/React 组件
    ↓
DOM元素
    ↓
用户界面
```

**实现示例（Vue）：**
```vue
<!-- 通用渲染组件 -->
<template>
  <div :class="['schema-container', schema.className]">
    <template v-for="(item, index) in schema.body" :key="index">
      <SchemaRenderer :schema="item" :context="context" />
    </template>
  </div>
</template>

<script>
export default {
  name: 'SchemaRenderer',
  components: {
    Form: () => import('@/components/builders/Form.vue'),
    Table: () => import('@/components/builders/Table.vue'),
    Button: () => import('@/components/builders/Button.vue'),
    // 其他组件...
  },
  props: {
    schema: Object,
    context: Object
  },
  computed: {
    componentName() {
      // 将type映射到组件名
      const typeMap = {
        'form': 'Form',
        'table': 'Table',
        'button': 'Button',
        // ...
      }
      return typeMap[this.schema.type] || 'div'
    }
  },
  render(h) {
    const Component = this.$options.components[this.componentName]

    if (!Component) {
      return h('div', `Unknown component: ${this.schema.type}`)
    }

    return h(Component, {
      props: this.schema,
      attrs: this.schema.attrs || {},
      on: this.schema.events || {},
      style: this.schema.style || {}
    })
  }
}
</script>
```

---

### 6. 组件库设计（Component Library）

**组件元数据定义：**
```typescript
interface ComponentMeta {
  // 基础信息
  id: string
  name: string
  title: string
  description: string

  // 组件定义
  component: Vue/ReactComponent

  // 属性schema（编辑器会根据这个生成属性面板）
  propertySchema: {
    type: 'object',
    properties: {
      label: {
        type: 'string',
        title: '标签',
        description: '组件标签'
      },
      placeholder: {
        type: 'string',
        title: '占位符'
      },
      required: {
        type: 'boolean',
        title: '是否必填',
        default: false
      },
      validation: {
        type: 'string',
        title: '验证规则',
        enum: ['email', 'phone', 'number', 'required']
      }
      // ...
    }
  },

  // 可用事件
  events: ['onClick', 'onChange', 'onSubmit'],

  // 默认配置
  defaultProps: {
    label: '',
    placeholder: '',
    required: false
  },

  // 分类
  category: 'basic' | 'container' | 'business',

  // 预览图
  preview: 'https://...'
}
```

**组件库管理：**
```typescript
class ComponentLibrary {
  // 存储所有组件元数据
  private components: Map<string, ComponentMeta> = new Map()

  // 注册组件
  register(meta: ComponentMeta) {
    this.components.set(meta.id, meta)
  }

  // 获取组件
  get(id: string): ComponentMeta {
    return this.components.get(id)
  }

  // 按分类获取
  getByCategory(category: string): ComponentMeta[] {
    return Array.from(this.components.values())
      .filter(c => c.category === category)
  }

  // 搜索组件
  search(keyword: string): ComponentMeta[] {
    return Array.from(this.components.values())
      .filter(c =>
        c.name.includes(keyword) ||
        c.title.includes(keyword)
      )
  }
}
```

---

### 7. 数据绑定与动态能力

**动态绑定表达式：**
```json
{
  "type": "form",
  "fields": [
    {
      "type": "text",
      "name": "username",
      "label": "用户名",
      "value": "${user.name}"
    },
    {
      "type": "select",
      "name": "department",
      "label": "部门",
      "options": "${departments}",
      "disabled": "${user.role !== 'admin'}"
    }
  ]
}
```

**表达式引擎：**
```javascript
class ExpressionEngine {
  // 执行表达式
  evaluate(expression: string, context: object) {
    // 移除 ${ 和 }
    const code = expression.slice(2, -1)

    // 使用Function构造器（比eval更安全）
    try {
      const fn = new Function(...Object.keys(context), `return ${code}`)
      return fn(...Object.values(context))
    } catch (error) {
      console.error(`Expression error: ${expression}`, error)
      return undefined
    }
  }

  // 批量解析Schema中的表达式
  parseSchema(schema: any, context: object): any {
    if (typeof schema === 'string' && schema.startsWith('${')) {
      return this.evaluate(schema, context)
    }

    if (Array.isArray(schema)) {
      return schema.map(item => this.parseSchema(item, context))
    }

    if (typeof schema === 'object' && schema !== null) {
      const result = {}
      for (const [key, value] of Object.entries(schema)) {
        result[key] = this.parseSchema(value, context)
      }
      return result
    }

    return schema
  }
}
```

---

### 8. 交互和事件系统

**事件流转：**
```
用户操作
    ↓
组件事件触发
    ↓
事件处理器
    ↓
执行Action
    ├─ API调用
    ├─ 页面跳转
    ├─ 弹窗打开
    ├─ 数据更新
    └─ 自定义回调
    ↓
页面响应更新
```

**事件配置示例：**
```json
{
  "type": "button",
  "label": "提交",
  "events": {
    "click": [
      {
        "actionType": "validate",
        "target": "userForm"
      },
      {
        "actionType": "request",
        "api": "/api/users",
        "method": "post",
        "data": "${userForm.data}"
      },
      {
        "actionType": "toast",
        "message": "提交成功！"
      },
      {
        "actionType": "redirect",
        "url": "/users/${res.id}"
      }
    ]
  }
}
```

---

## 核心技术难点

### 9. 拖拽和放置（Drag & Drop）

```vue
<template>
  <div class="canvas-area">
    <!-- 组件库面板 -->
    <div class="component-panel">
      <div
        v-for="component in components"
        :key="component.id"
        :draggable="true"
        @dragstart="handleDragStart"
        class="component-item"
      >
        {{ component.title }}
      </div>
    </div>

    <!-- 画布区域 -->
    <div
      class="canvas"
      @dragover="handleDragOver"
      @drop="handleDrop"
    >
      <template v-for="item in schema.body" :key="item.id">
        <Component
          :schema="item"
          :selected="selectedId === item.id"
          @click="selectComponent(item.id)"
          @dragstart="handleComponentDragStart"
          @drop="handleComponentDrop"
          draggable
        />
      </template>
    </div>
  </div>
</template>

<script>
export default {
  methods: {
    handleDragStart(e) {
      // 保存被拖拽的组件类型
      e.dataTransfer.effectAllowed = 'copy'
      e.dataTransfer.setData('componentType', e.target.dataset.type)
    },

    handleDragOver(e) {
      e.preventDefault()
      e.dataTransfer.dropEffect = 'copy'
    },

    handleDrop(e) {
      e.preventDefault()
      const componentType = e.dataTransfer.getData('componentType')
      const position = {
        x: e.clientX,
        y: e.clientY
      }

      // 在指定位置添加组件
      this.addComponent(componentType, position)
    }
  }
}
</script>
```

### 10. 撤销/重做（Undo/Redo）

```typescript
class CommandManager {
  private history: Command[] = []
  private currentIndex: number = -1

  execute(command: Command) {
    // 执行新命令
    command.execute()

    // 移除当前位置之后的历史（如果用户进行了新操作）
    this.history = this.history.slice(0, this.currentIndex + 1)

    // 添加到历史
    this.history.push(command)
    this.currentIndex++
  }

  undo() {
    if (this.currentIndex >= 0) {
      this.history[this.currentIndex].undo()
      this.currentIndex--
    }
  }

  redo() {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++
      this.history[this.currentIndex].execute()
    }
  }
}

interface Command {
  execute(): void
  undo(): void
}

class AddComponentCommand implements Command {
  constructor(
    private builder: VisualBuilder,
    private componentId: string,
    private schema: SchemaObject
  ) {}

  execute() {
    this.builder.schema.body.push(this.schema)
  }

  undo() {
    const index = this.builder.schema.body.findIndex(
      c => c.id === this.componentId
    )
    this.builder.schema.body.splice(index, 1)
  }
}
```

---

## 实战建议

### 11. 开发路线

**阶段1：MVP（最小可行产品）**
```
✅ 支持基础组件（文本框、按钮、选择框）
✅ 支持简单的拖拽
✅ 支持属性编辑
✅ 能导出Schema
```

**阶段2：核心功能**
```
✅ 支持容器组件（表单、弹窗）
✅ 完整的拖拽和放置
✅ 撤销/重做
✅ 预览和调试
```

**阶段3：高级功能**
```
✅ 数据绑定和表达式
✅ 事件系统
✅ 自定义组件
✅ 组件库管理
✅ 版本控制
```

### 12. 选型建议

**框架选择：**
```
Vue.js ✅
├─ 轻量级，渲染快
├─ 组件开发友好
└─ 模板语法清晰

React ✅
├─ 生态完整
├─ 性能优秀
└─ 学习资源多

Angular ❌
└─ 过于复杂，不适合
```

**UI库选择：**
```
自研 ✅
├─ 完全自主
├─ 高度定制
└─ 维护成本高

Ant Design ✅
├─ 组件完整
├─ 易于使用
└─ 有社区支持

Element Plus ✅
└─ 同上
```

**参考项目：**
```
Amis
├─ 百度开源
├─ 最成熟的方案
└─ 学习最佳参考

Tencent CloudBase CMS
├─ 腾讯开源
└─ 包含后端支持

Apache OFBiz
└─ 企业级方案
```

---

## 快速自测

- [ ] 理解Schema JSON的作用吗？
- [ ] 能设计一个简单的Schema格式吗？
- [ ] 知道编辑器、渲染器的区别吗？
- [ ] 能实现基本的拖拽功能吗？
- [ ] 理解动态绑定表达式吗？
- [ ] 能设计撤销/重做系统吗？
- [ ] 知道Amis的架构吗？


Schema JSON -> 解析器（遍历每一层的节点根据 Type 映射）-> 组件工厂(筛选组件) -> 组件库（众多组件的聚集地）—> Vue,Or,React 代码 -> 视觉层呈现出改动

疑问1，是不是这个 Schema JSON type 下的属性都是为这个组件服务的，比如 api，source
疑问2，解析Schema JSON 的是递归算法吗？
疑问3，比如一个组件内的具体配置该怎么实现呢？比如 api Source
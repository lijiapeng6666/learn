# 最长递增子序列

## 问题描述

给定一个整数数组 `nums`，找到其中最长**严格递增子序列**的长度。

**子序列**是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**例如：**
```
示例 1:
输入：nums = [10, 9, 2, 5, 3, 7, 101, 18]
输出：4
解释：最长递增子序列是 [2, 3, 7, 101]，因此长度为 4

示例 2:
输入：nums = [0, 1, 0, 3, 2, 3]
输出：4
解释：最长递增子序列是 [0, 1, 2, 3]，长度为 4

示例 3:
输入：nums = [7, 7, 7, 7, 7, 7, 7]
输出：1
解释：所有元素相同，最长递增子序列只能是单个元素
```

**关键问题：**
- 子序列是否需要连续？（不需要）
- 是否严格递增？（是，相等不算）
- 数组是否可能为空？（可能）
- 只返回长度还是要返回具体序列？（只返回长度）

---

## 进阶

- 能否将算法的时间复杂度降至 O(n log n)？
- 如何输出具体的最长递增子序列？


  最长递增子序列 - 三步曲

  第一步：初始化

  创建一个 dp 数组，长度与原数组相同，初始值全为 1。
  - dp[i] 表示"以 nums[i] 结尾的最长递增子序列的长度"
  - 初始都是 1，因为每个数字单独成序列长度就是 1

  第二步：对比与继承

  遍历数组，对每个位置 i：
  - 看前面所有位置 j（j < i），是否存在 nums[j] < nums[i]
  - 如果存在，说明 nums[i] 可以接在 nums[j] 后面
  - 计算接上去后的长度：dp[j] + 1

  第三步：取最优

  在所有可能的接法中，选择长度最长的：
  - dp[i] = Math.max(dp[i], dp[j] + 1)
  - 最后返回整个 dp 数组中的最大值

  ---
  一句话总结

  "找前面比我小的，接上去，选最长的链"
# 排队问题

## 问题描述

有一个人领东西的队伍，每个人有三个属性：
- **编号**：标识这个人是谁（1, 2, 3...）
- **到达时间**：这个人什么时候来排队
- **可等待时间**：这个人最多愿意等多久

**规则：**
- 队伍是有序的，先到先得
- 每个人领东西需要的时间是固定的（比如都是 1 分钟）
- 如果一个人到达时还要排队，需要等待，但他只愿意等一定时间
- 如果轮到他时，他已经等不了那么久了（等待时间超过可接受时间），他就不领了
- 否则，他成功领到东西

**目标：** 输出每个人是否成功领到东西

**例如：**
```
人员信息：
编号1：到达时间=0，可等待时间=10
编号2：到达时间=1，可等待时间=5
编号3：到达时间=2，可等待时间=3

结果：
编号1 能领到（到达时就轮到他）
编号2 能领到（到达时=1，轮到他时=1，需要等待0分钟）
编号3 不能领到（到达时=2，轮到他时=2，需要等待0分钟... 实际需要看前面的人）
```

---

## 解题思路

### 核心思想

```
1️⃣  按到达时间排序
    为什么？因为队伍是按到达顺序排的

2️⃣  模拟领东西的过程
    - 记录当前可以开始领东西的时间 current_time
    - 对于每个人：
      ✓ 计算他到达时的 current_time 是多少
      ✓ 计算他需要等待多久 = current_time - 到达时间
      ✓ 检查等待时间是否超过可接受时间
      ✓ 如果没超过，他成功领东西，current_time += 1
      ✓ 如果超过了，他放弃，current_time 不变
```

### 关键变量理解

```
到达时间 arrival_time：这个人什么时候来排队
可等待时间 max_wait_time：这个人最多愿意等多久
current_time：当前可以开始领东西的时间

实际等待时间 = max(0, current_time - arrival_time)
  - 如果 current_time <= arrival_time，说明他来时没人排队，等待时间=0
  - 如果 current_time > arrival_time，说明他要等待
```

---

## 方案：排序 + 模拟

**时间复杂度：** O(n log n)（主要是排序）
**空间复杂度：** O(n)

```typescript
interface Person {
  id: number;
  arrivalTime: number;
  maxWaitTime: number;
}

/**
 * 排队问题解决方案
 */
function queueProblem(people: Person[]): Map<number, boolean> {
  // 第一步：按到达时间排序
  people.sort((a, b) => a.arrivalTime - b.arrivalTime);

  const result = new Map<number, boolean>();
  let currentTime = 0;  // 当前可以开始领东西的时间

  // 第二步：模拟排队过程
  for (const person of people) {
    // 计算实际等待时间
    const actualWaitTime = Math.max(0, currentTime - person.arrivalTime);

    // 检查是否能领到
    if (actualWaitTime <= person.maxWaitTime) {
      result.set(person.id, true);  // ← 成功领到
      currentTime += 1;              // ← 他领了，更新时间
    } else {
      result.set(person.id, false);  // ← 不能领到
      // currentTime 不变，因为他没有领东西
    }
  }

  return result;
}
```

---

## 详细过程演示

### 例子1：所有人都能领到

```
初始状态：currentTime = 0

人员信息（已按到达时间排序）：
编号1：到达时间=0，可等待时间=10
编号2：到达时间=1，可等待时间=5
编号3：到达时间=2，可等待时间=3

处理编号1：
  到达时间=0，currentTime=0
  实际等待时间 = max(0, 0 - 0) = 0
  0 <= 10 ✓ 能领到
  currentTime 更新为 1

处理编号2：
  到达时间=1，currentTime=1
  实际等待时间 = max(0, 1 - 1) = 0
  0 <= 5 ✓ 能领到
  currentTime 更新为 2

处理编号3：
  到达时间=2，currentTime=2
  实际等待时间 = max(0, 2 - 2) = 0
  0 <= 3 ✓ 能领到
  currentTime 更新为 3

结果：所有人都能领到
```

### 例子2：有人等待超时

```
初始状态：currentTime = 0

人员信息（已按到达时间排序）：
编号1：到达时间=0，可等待时间=10
编号2：到达时间=0，可等待时间=1
编号3：到达时间=0，可等待时间=0

处理编号1：
  到达时间=0，currentTime=0
  实际等待时间 = max(0, 0 - 0) = 0
  0 <= 10 ✓ 能领到
  currentTime 更新为 1

处理编号2：
  到达时间=0，currentTime=1
  实际等待时间 = max(0, 1 - 0) = 1
  1 <= 1 ✓ 能领到（刚好在可接受的时间内）
  currentTime 更新为 2

处理编号3：
  到达时间=0，currentTime=2
  实际等待时间 = max(0, 2 - 0) = 2
  2 > 0 ✗ 不能领到（要等2分钟，但只能等0分钟）
  currentTime 保持为 2

结果：编号1和2能领到，编号3不能
```

### 例子3：后来的人突然大量到达

```
初始状态：currentTime = 0

人员信息（已按到达时间排序）：
编号1：到达时间=0，可等待时间=100
编号2：到达时间=100，可等待时间=5
编号3：到达时间=100，可等待时间=1

处理编号1：
  到达时间=0，currentTime=0
  实际等待时间 = max(0, 0 - 0) = 0
  0 <= 100 ✓ 能领到
  currentTime 更新为 1

处理编号2：
  到达时间=100，currentTime=1
  实际等待时间 = max(0, 1 - 100) = 0
  0 <= 5 ✓ 能领到（他来时队伍已经没人了）
  currentTime 更新为 2

处理编号3：
  到达时间=100，currentTime=2
  实际等待时间 = max(0, 2 - 100) = 0
  0 <= 1 ✓ 能领到
  currentTime 更新为 3

结果：所有人都能领到

关键理解：
  max(0, currentTime - arrivalTime)
  如果他来时队伍已经空了，等待时间就是0
  这就是为什么要用 max()
```

---

## 🧠 理解题目的关键点

### 为什么要先排序？

```
❌ 错误思路：
  直接按编号顺序处理
  但题目说的是"队伍"，队伍是按到达时间排的，不是按编号排的

✅ 正确思路：
  按到达时间排序，这样就得到了实际的队伍顺序
  然后模拟队伍的前进过程
```

### currentTime 的含义

```
currentTime 表示：现在可以开始给谁领东西的时间

初始：currentTime = 0（从时间0开始）

处理每个人时：
  - 如果他来时 currentTime 已经过去了，他要等待
  - 等待时间 = currentTime - 到达时间
  - 如果等待时间太长，他就不等了
  - 否则他领了，currentTime += 1（下一个人要排队）
```

### 为什么失败的人不更新 currentTime？

```
编号1：到达时间=0，领东西
  currentTime: 0 → 1

编号2：到达时间=5，不能领东西
  currentTime 仍然是 1（因为他没有领）

编号3：到达时间=6，可能可以领
  他来时 currentTime=1，不用等待，可以领到

这就是模拟的关键：
  - 只有成功领到的人才会"消耗时间"
  - 不能领到的人相当于"没来过"，队伍不动
```

---

## 代码框架速记

```typescript
// 标准框架
function queueProblem(people) {
  // 1. 按到达时间排序
  people.sort((a, b) => a.arrivalTime - b.arrivalTime);

  const result = new Map();
  let currentTime = 0;

  // 2. 遍历每个人
  for (const person of people) {
    // 3. 计算等待时间
    const waitTime = Math.max(0, currentTime - person.arrivalTime);

    // 4. 判断是否能领到
    if (waitTime <= person.maxWaitTime) {
      result.set(person.id, true);
      currentTime += 1;  // ← 关键：只有成功的人才更新时间
    } else {
      result.set(person.id, false);
    }
  }

  return result;
}
```

---

## 常见错误与避坑

```typescript
// ❌ 错误1：忘记排序
for (const person of people) {  // ← 直接用原始顺序，不对！
  ...
}

// ✅ 正确：必须先排序
people.sort((a, b) => a.arrivalTime - b.arrivalTime);

// ❌ 错误2：等待时间计算错误
const waitTime = currentTime - person.arrivalTime;  // ← 可能是负数
if (waitTime < 0) waitTime = 0;  // ← 繁琐

// ✅ 正确：用 max 一步到位
const waitTime = Math.max(0, currentTime - person.arrivalTime);

// ❌ 错误3：不管成功失败都更新 currentTime
for (const person of people) {
  if (waitTime <= person.maxWaitTime) {
    currentTime += 1;
  }
  // 没有 else，所以无论如何都继续... 实际上应该只在成功时更新
}

// ✅ 正确：只有成功才更新
if (waitTime <= person.maxWaitTime) {
  result.set(person.id, true);
  currentTime += 1;  // ← 只有这里更新
} else {
  result.set(person.id, false);  // ← currentTime 不变
}

// ❌ 错误4：混淆"到达时间"和"等待时间"
if (person.arrivalTime > person.maxWaitTime) {  // ← 这是什么逻辑？
  ...
}

// ✅ 正确：比较的是"实际等待时间"和"可接受等待时间"
const actualWait = Math.max(0, currentTime - person.arrivalTime);
if (actualWait <= person.maxWaitTime) {
  ...
}
```

---

## 延伸思考

### Q1: 如果领东西的时间不是1分钟，而是不同的时间呢？

```typescript
interface Person {
  id: number;
  arrivalTime: number;
  maxWaitTime: number;
  serviceTime: number;  // ← 这个人需要的服务时间
}

function queueProblemVariable(people) {
  people.sort((a, b) => a.arrivalTime - b.arrivalTime);

  const result = new Map();
  let currentTime = 0;

  for (const person of people) {
    const waitTime = Math.max(0, currentTime - person.arrivalTime);

    if (waitTime <= person.maxWaitTime) {
      result.set(person.id, true);
      currentTime += person.serviceTime;  // ← 改成 serviceTime
    } else {
      result.set(person.id, false);
    }
  }

  return result;
}
```

### Q2: 如果有多个服务窗口呢？

```typescript
// 这就变成了更复杂的"调度问题"
// 需要用优先队列或其他更复杂的算法
// 超出本题范围
```

### Q3: 如何输出每个人的具体信息（何时开始、何时结束）？

```typescript
function queueProblemDetailed(people) {
  people.sort((a, b) => a.arrivalTime - b.arrivalTime);

  const result = new Map();
  let currentTime = 0;

  for (const person of people) {
    const waitTime = Math.max(0, currentTime - person.arrivalTime);

    if (waitTime <= person.maxWaitTime) {
      result.set(person.id, {
        success: true,
        serviceStartTime: currentTime,
        serviceEndTime: currentTime + 1,
        waitTime: waitTime
      });
      currentTime += 1;
    } else {
      result.set(person.id, {
        success: false,
        waitTime: waitTime,
        reason: `需要等待${waitTime}分钟，但只能等${person.maxWaitTime}分钟`
      });
    }
  }

  return result;
}
```

---

## 总结

| 步骤 | 操作 | 理由 |
|------|------|------|
| 1 | **排序** | 队伍是有序的，要按到达时间排 |
| 2 | **遍历** | 依次处理每个人 |
| 3 | **计算等待时间** | 当前时间 - 到达时间 |
| 4 | **判断** | 等待时间 <= 可接受时间？ |
| 5 | **更新** | 只有成功的人才更新 currentTime |

**口诀：排序 → 遍历 → 计算 → 判断 → 更新**

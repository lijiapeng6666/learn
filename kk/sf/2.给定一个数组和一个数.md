# 给定一个数组和一个数，返回所有满足子数组和为给定数的子数组

## 问题描述

给定一个数组 `nums` 和一个目标和 `target`，找出数组中所有连续子数组，其元素总和等于目标和。

**例如：**
- 数组：`[1, 2, 3, 2, 1]`，target = 3 → 答案是 `[[3], [1, 2], [2, 1]]`
- 数组：`[1, 1, 1, 1]`，target = 2 → 答案是 `[[1, 1], [1, 1], [1, 1]]`（3个）

---

## 解题思路

### 方案1️⃣：暴力法（最简单但最慢）

**思路：**
- 两层循环，枚举所有子数组
- 计算每个子数组的和
- 如果等于 target，保存该子数组

**时间复杂度：** O(n²) 或 O(n³)
**空间复杂度：** O(1)

```typescript
/**
 * 暴力法：枚举所有子数组
 * 最直观但最慢
 */
function findSubarraysByBruteForce(nums: number[], target: number): number[][] {
  const result: number[][] = [];

  // 第一层循环：子数组的起点
  for (let i = 0; i < nums.length; i++) {
    let sum = 0;

    // 第二层循环：子数组的终点
    for (let j = i; j < nums.length; j++) {
      sum += nums[j];

      // 如果和等于 target，保存这个子数组
      if (sum === target) {
        result.push(nums.slice(i, j + 1));
      }
    }
  }

  return result;
}

// 使用示例
const arr1 = [1, 2, 3, 2, 1];
console.log(findSubarraysByBruteForce(arr1, 3));
// 输出：[[3], [1, 2], [2, 1]]

const arr2 = [1, 1, 1, 1];
console.log(findSubarraysByBruteForce(arr2, 2));
// 输出：[[1, 1], [1, 1], [1, 1]]
```

---

### 方案2️⃣：前缀和 + 哈希表（最优）⭐推荐

**核心思想：**
```
如果 prefixSum[j] - prefixSum[i] = target
那么 nums[i+1...j] 的和就是 target

反过来想：
prefixSum[j] - target = prefixSum[i]
所以我们要找有多少个 prefixSum[i] 等于 (prefixSum[j] - target)
```

**时间复杂度：** O(n)
**空间复杂度：** O(n)

```typescript
/**
 * 前缀和 + 哈希表（最优！）
 *
 * 核心思想：
 * prefixSum[j] - prefixSum[i] = target
 * 如果我们记录所有见过的前缀和，就能快速判断
 */
function findSubarraysByPrefixSum(nums: number[], target: number): number[][] {
  const result: number[][] = [];
  const prefixMap = new Map<number, number[]>();  // 前缀和 → 对应的索引列表

  prefixMap.set(0, [-1]);  // 重要：初始化，表示"还没加任何数"
  let prefixSum = 0;

  for (let j = 0; j < nums.length; j++) {
    prefixSum += nums[j];

    // 问：有没有某个前缀和，使得 prefixSum - 它 = target?
    const targetPrefixSum = prefixSum - target;

    if (prefixMap.has(targetPrefixSum)) {
      // 找到了！
      const startIndices = prefixMap.get(targetPrefixSum)!;

      // 对于每一个这样的起点，都能形成一个子数组
      for (const startIndex of startIndices) {
        const subarray = nums.slice(startIndex + 1, j + 1);
        result.push(subarray);
      }
    }

    // 记录当前前缀和及其索引
    if (!prefixMap.has(prefixSum)) {
      prefixMap.set(prefixSum, []);
    }
    prefixMap.get(prefixSum)!.push(j);
  }

  return result;
}

// 使用示例
const arr1 = [1, 2, 3, 2, 1];
console.log(findSubarraysByPrefixSum(arr1, 3));
// 输出：[[1, 2], [3], [2, 1]]

const arr2 = [1, 1, 1, 1];
console.log(findSubarraysByPrefixSum(arr2, 2));
// 输出：[[1, 1], [1, 1], [1, 1]]
```

---

## 🧠 前缀和的核心原理（完全零基础讲解）

让我用一个故事来解释，这样你会真正理解。

### 故事：数钱

假设你去银行存钱，这是你每天的存款记录：

```
第1天：存1块钱  → 你有1块钱
第2天：存2块钱  → 你有3块钱（1+2）
第3天：存3块钱  → 你有6块钱（1+2+3）
第4天：存2块钱  → 你有8块钱（1+2+3+2）
第5天：存1块钱  → 你有9块钱（1+2+3+2+1）
```

这就是 **前缀和**！它就是 **累积的总和**。

```
数组：       [1, 2, 3, 2, 1]
            （每天存的钱）

前缀和：     [1, 3, 6, 8, 9]
            （每天的总余额）
```

---

### 现在问题来了

**问题：第2天到第4天，我总共存了多少钱？**

```
方法1（笨的）：逐个加
nums[1] + nums[2] + nums[3] = 2 + 3 + 2 = 7

方法2（聪明的）：用余额推算
第4天末余额：8块
第1天末余额：1块
差：8 - 1 = 7块  ← 这就是第2到4天存的钱！

为什么？
8块 - 1块 = 7块
（第4天为止的全部）- （第1天为止的全部） = （第2-4天的）
```

这是关键！！！

```
prefixSum[4] - prefixSum[0] = nums[2] + nums[3]
8 - 1 = 7 ✓

用公式：
要找 nums[i...j] 的和，就用：prefixSum[j] - prefixSum[i-1]
```

---

### 再来一个例子，这次用我们真实的数据

**数组：[1, 2, 3, 2, 1]，找子数组和为3的所有子数组**

```
前缀和：[1, 3, 6, 8, 9]
       （这些是累积和）

现在问：哪些连续子数组的和是3？

第1个子数组 [1, 2]？
检查：prefixSum[1] - prefixSum[0] = 3 - 1 = 2？不对，应该是3
等等，我算错了...让我重新标记

正确的前缀和应该这样标记：
位置：    -1   0   1   2   3   4
数组：         1   2   3   2   1
前缀和：  0   1   3   6   8   9
       （0）(加1) (加2)(加3)(加2)(加1)

现在才是对的！
- prefixSum[-1] = 0（开始时）
- prefixSum[0] = 1（加完第1个数）
- prefixSum[1] = 3（加完第2个数）
- ...以此类推

子数组 nums[0...1]（就是[1,2]） 的和：
= prefixSum[1] - prefixSum[-1]
= 3 - 0
= 3 ✓

子数组 nums[2...2]（就是[3]） 的和：
= prefixSum[2] - prefixSum[1]
= 6 - 3
= 3 ✓

子数组 nums[3...4]（就是[2,1]） 的和：
= prefixSum[4] - prefixSum[2]
= 9 - 6
= 3 ✓
```

---

### 现在来解释"减去目标值"的含义

**这是最关键的部分！**

假设你要找：
- 当前累积和：8
- 目标子数组和：3
- 问：前面某个时刻的累积和是多少？

```
用公式：
前面的累积和 = 当前累积和 - 目标子数组和
            = 8 - 3
            = 5

为什么？
8 - ? = 3
所以 ? = 8 - 3 = 5

意义：
如果某个时刻的累积和是5，
那从那时候到现在（累积和8），
中间加了 8 - 5 = 3（就是目标！）
```

---

### 用故事说明"减去目标值"

```
当前时刻：
- 你的总余额：8块钱（前缀和=8）
- 你想知道：最近什么时候，你存了3块钱？

反向推理：
- 现在有8块，减3块就是5块
- 如果某个时刻你有5块，那从那时到现在就存了3块！
- 所以要找：有没有某个时刻，余额是5块？

检查历史：
位置：   -1   0   1   2   3   4
前缀和： 0    1   3   6   8   9
                       ↑   ↑
                    5? 没有5！

等等，我算错了。让我重新找...

其实在 j=1 时（刚加完2），余额是3
3 是不是 8-3=5？不是

在 j=2 时（刚加完3），余额是6
6 是不是 8-3=5？不是

实际上不存在5的时刻...

让我换个问题：当j=2，前缀和=6，目标=3
要找的前缀和 = 6 - 3 = 3
历史中有3吗？有！在位置1

这意味着：从位置1到位置2，中间加了什么？
= nums[2] = 3 ✓ 就是第3个数！
```

---

### 现在加入哈希表

**哈希表的作用：记住所有见过的余额**

```
当我逐个遍历数组时：

第0步：
- 当前前缀和 = 0
- 我记住：{0: [-1]}（在-1位置时，余额是0）

第1步（加1）：
- 当前前缀和 = 0 + 1 = 1
- 要找的目标余额 = 1 - 3 = -2（不存在）
- 我记住：{0: [-1], 1: [0]}

第2步（加2）：
- 当前前缀和 = 1 + 2 = 3
- 要找的目标余额 = 3 - 3 = 0
- 查一下：有没有在哪个时刻余额是0？有！在位置-1
- 所以从-1到当前（位置1），中间加了3！对应 nums[0...1]=[1,2] ✓
- 我记住：{0: [-1], 1: [0], 3: [1]}

第3步（加3）：
- 当前前缀和 = 3 + 3 = 6
- 要找的目标余额 = 6 - 3 = 3
- 查一下：有没有在哪个时刻余额是3？有！在位置1
- 所以从1到当前（位置2），中间加了3！对应 nums[2...2]=[3] ✓
- 我记住：{0: [-1], 1: [0], 3: [1, 2], 6: [2]}

第4步（加2）：
- 当前前缀和 = 6 + 2 = 8
- 要找的目标余额 = 8 - 3 = 5（不存在）
- 我记住：{0: [-1], 1: [0], 3: [1, 2], 6: [2], 8: [3]}

第5步（加1）：
- 当前前缀和 = 8 + 1 = 9
- 要找的目标余额 = 9 - 3 = 6
- 查一下：有没有在哪个时刻余额是6？有！在位置2
- 所以从2到当前（位置4），中间加了3！对应 nums[3...4]=[2,1] ✓
- 我记住：{0: [-1], 1: [0], 3: [1, 2], 6: [2], 8: [3], 9: [4]}

答案找到了：[[1,2], [3], [2,1]] ✓
```

---

### 三句话总结前缀和解题思路

```
1️⃣  维护累积和（前缀和）
    边扫描数组，边累积

2️⃣  每次都问自己：
    "我需要的前面余额是多少？"
    答案 = 当前余额 - 目标和

3️⃣  查哈希表：
    "之前有没有某个时刻，余额就是我需要的？"
    有 → 找到一个答案！
    没有 → 继续扫描
```

---

### 核心概念对比

| 概念 | 含义 | 例子 |
|------|------|------|
| 前缀和 | 从开始到当前位置的累积和 | 到第3天为止，我有6块 |
| 子数组和 | 两个前缀和的差 | 第2-4天，6-1=5块 |
| 目标余额 | 当前余额-目标，推出前面的值 | 8-3=5，要找之前有没有5 |
| 哈希表 | 记住所有见过的余额及位置 | {6: [位置2]} 表示在位置2时有6块 |

---

## 三个版本对比

| 方案 | 时间 | 空间 | 适合场景 |
|------|------|------|---------|
| 暴力法 | O(n²) | O(1) | 数据很小 |
| **前缀和** | **O(n)** | **O(n)** | **推荐（最优）** |

---

## 记忆技巧

### 前缀和的三句话

```
1️⃣  计算前缀和：sum = sum + nums[i]
2️⃣  查询：targetSum = 当前sum - target
3️⃣  检查：targetSum 在哈希表中吗？
```

### 口诀："累计加，反推减，哈希查"

```
累计加：前缀和不断累加
反推减：用当前和减去目标，得到要找的值
哈希查：在哈希表中查是否存在
```

---

## 深入理解：为什么是 `nums.slice(startIndex + 1, j + 1)`？

### 这个问题最关键！必须理解！

**短答案：**
```
startIndex 是前缀和的位置，不是数组元素的位置
所以真正的子数组起点是 startIndex + 1
而子数组终点是 j（当前位置）
```

---

### 完整讲解

#### 前缀和的定义回顾

```
数组：      [1, 2, 3, 2, 1]
索引：       0  1  2  3  4

前缀和：
prefixSum[-1] = 0          ← 虚拟位置，什么都没加
prefixSum[0] = 1           ← 加到索引0，前缀和=1
prefixSum[1] = 1+2 = 3     ← 加到索引1，前缀和=3
prefixSum[2] = 1+2+3 = 6   ← 加到索引2，前缀和=6
prefixSum[3] = 1+2+3+2 = 8 ← 加到索引3，前缀和=8
prefixSum[4] = 1+2+3+2+1 = 9 ← 加到索引4，前缀和=9

关键：prefixSum[i] 是"加到索引i为止"的和
```

#### 子数组和的公式

```
nums[start...end] 的和 = prefixSum[end] - prefixSum[start-1]

例如：
nums[2...3] 的和 = prefixSum[3] - prefixSum[1]
                = (1+2+3+2) - (1+2)
                = 8 - 3
                = 5 ✓
                = nums[2] + nums[3]
                = 3 + 2
```

#### 现在回到代码

```typescript
const targetPrefixSum = prefixSum - target;

if (prefixMap.has(targetPrefixSum)) {
  const startIndex = prefixMap.get(targetPrefixSum)!;  // 得到的是什么？

  // 这里 startIndex 是前缀和的位置
  // 它对应的是"加到该位置为止"
  // 所以真正的子数组要从 startIndex + 1 开始

  const subarray = nums.slice(startIndex + 1, j + 1);
}
```

---

### 用具体例子说明

**问题：找和为 3 的子数组**
```
数组：[1, 2, 3, 2, 1]
目标：target = 3
```

**当 j=2 时（正在看 nums[2]=3）：**
```
当前 prefixSum = 6（1+2+3）
targetPrefixSum = 6 - 3 = 3

prefixMap 中有 3 吗？有！
startIndex = 1（因为 prefixSum[1] = 3）

现在问：从 prefixSum[1] 到 prefixSum[2] 之间，是什么？
prefixSum[1] = 3     ← 这是"加到索引1为止"
prefixSum[2] = 6     ← 这是"加到索引2为止"

中间加了什么？
prefixSum[2] - prefixSum[1] = 6 - 3 = 3
这对应的是 nums[2] = 3

所以子数组是 nums[2...2] = [3]

用代码：
nums.slice(startIndex + 1, j + 1)
= nums.slice(1 + 1, 2 + 1)
= nums.slice(2, 3)  ← JavaScript 的 slice 是左闭右开
= [nums[2]]
= [3] ✓
```

---

### 再来一个例子

**当 j=1 时（正在看 nums[1]=2）：**
```
当前 prefixSum = 3（1+2）
targetPrefixSum = 3 - 3 = 0

prefixMap 中有 0 吗？有！
startIndex = -1（因为我们初始化了 prefixMap.set(0, [-1])）

现在问：从 prefixSum[-1] 到 prefixSum[1] 之间，是什么？
prefixSum[-1] = 0    ← 这是虚拟位置，什么都没加
prefixSum[1] = 3     ← 这是"加到索引1为止"

中间加了什么？
prefixSum[1] - prefixSum[-1] = 3 - 0 = 3
这对应的是 nums[0] + nums[1] = 1 + 2 = 3

所以子数组是 nums[0...1] = [1, 2]

用代码：
nums.slice(startIndex + 1, j + 1)
= nums.slice(-1 + 1, 1 + 1)
= nums.slice(0, 2)  ← JavaScript 的 slice 是左闭右开
= [nums[0], nums[1]]
= [1, 2] ✓
```

---

### 为什么是 slice(start, end) 而不是 slice(start, end+1)？

**JavaScript 的 slice 用法：**
```
nums.slice(start, end)
      ↑          ↑
     包含        不包含（左闭右开）

例如：
[1, 2, 3, 4, 5].slice(1, 3) = [2, 3]  ← 包含索引1，不包含索引3

所以如果我们要包含索引 j，就要写 slice(..., j + 1)
```

**在我们的代码中：**
```
nums.slice(startIndex + 1, j + 1)
       ↑                  ↑
     子数组起点         子数组终点（需要+1因为slice右边不包含）
```

---

### 总结：三个关键点

```
1️⃣  startIndex 是"前缀和的位置"，不是"数组元素的位置"
    prefixSum[startIndex] 表示"加到数组第startIndex位置为止"

2️⃣  子数组的真正起点是 startIndex + 1
    因为 prefixSum[startIndex] 已经包含了 nums[startIndex]
    我们要的是 prefixSum[startIndex] 之后的元素

3️⃣  js的slice(start, end)是左闭右开
    所以要用 slice(startIndex + 1, j + 1) 才能包含第j个元素
```

---

### 可视化对比

```
❌ 错的：nums.slice(startIndex, j + 1)
   会包含 nums[startIndex]，太多了！

   例：startIndex=-1, j=1
   slice(-1, 2) 会报错或不对

✅ 对的：nums.slice(startIndex + 1, j + 1)
   完美包含从 startIndex+1 到 j 的所有元素

   例：startIndex=-1, j=1
   slice(0, 2) = [nums[0], nums[1]] ✓
```

---

### 代码注释版本

```typescript
if (prefixMap.has(targetPrefixSum)) {
  const startIndex = prefixMap.get(targetPrefixSum)!;

  // startIndex 是前缀和数组的索引
  // 表示"加到数组第 startIndex 位置为止的和"
  // 所以子数组真正要从 startIndex + 1 开始

  // j 是当前正在扫描的数组索引
  // 我们要包含 nums[j]，所以用 j + 1（因为 slice 右边不包含）

  const subarray = nums.slice(
    startIndex + 1,  // 子数组起点
    j + 1            // 子数组终点（slice右边不包含，所以+1）
  );

  result.push(subarray);
}
```

---

## 常见错误与避坑

```typescript
// ❌ 错误1：忘记初始化 prefixMap.set(0, [-1])
// 这会导致无法找到从开头开始的子数组
// 原因：没有办法表示"前面什么都没有"的状态

// ❌ 错误2：写成 nums.slice(startIndex, j + 1)
// 这会多包含一个元素！
// 例：应该得 [3]，结果得 [2, 3]

// ❌ 错误3：写成 nums.slice(startIndex + 1, j)
// 这会少包含最后一个元素！
// 例：应该得 [1, 2]，结果得 [1]

// ❌ 错误4：有重复的前缀和没处理
// 用数组存储对应的所有索引，不能只存一个

// ✅ 正确：
prefixMap.set(0, [-1]);  // 初始化虚拟位置
// ...循环中...
if (!prefixMap.has(prefixSum)) {
  prefixMap.set(prefixSum, []);
}
prefixMap.get(prefixSum)!.push(j);  // 存储所有索引

// 提取子数组时：
const subarray = nums.slice(startIndex + 1, j + 1);
```

---

## 延伸思考

### Q1: 如果要返回起始和结束索引而不是子数组本身？

```typescript
// 只需改变返回值
const result: Array<[number, number]> = [];
// ...
result.push([startIndex + 1, j]);  // 返回索引对
```

### Q2: 如果数组中有负数？

前缀和方法同样适用！因为不依赖于数组是否为正。

### Q3: 什么时候用暴力法，什么时候用前缀和？

```
数据量小（<1000）：暴力法简单，快速开发
数据量大（>10000）：前缀和，O(n) 高效
```
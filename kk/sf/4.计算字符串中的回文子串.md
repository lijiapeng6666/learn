# 计算字符串中的回文子串

## 问题描述

给定一个字符串 `s`，计算并返回**字符串中所有回文子串的数量**。

**什么是回文？**
```
正着读和反着读都一样的字符串叫回文

例如：
  "a"     ✓ 回文（只有一个字符）
  "aa"    ✓ 回文（两个相同字符）
  "aba"   ✓ 回文（中间是'b'，两边都是'a'）
  "abba"  ✓ 回文（反着读也是"abba"）
  "abc"   ✗ 不是回文（反着读是"cba"）
  "abcd"  ✗ 不是回文
```

**例如：**
- 字符串：`"abc"` → 回文子串有 `"a"`, `"b"`, `"c"`，共3个
- 字符串：`"aba"` → 回文子串有 `"a"`, `"b"`, `"a"`, `"aba"`，共4个
- 字符串：`"aaa"` → 回文子串有 `"a"`, `"a"`, `"a"`, `"aa"`, `"aa"`, `"aaa"`，共6个

**注意：**
- 回文子串必须是**连续的**
- 单个字符也算回文
- 计算的是**数量**，不是找出所有回文

---

## 解题思路

### 方案1️⃣：暴力法（最简单但最慢）

**思路：**
- 枚举所有子串
- 检查每个子串是否是回文
- 计数

**时间复杂度：** O(n³)
**空间复杂度：** O(1)

```typescript
/**
 * 暴力法：枚举所有子串，逐个检查是否回文
 */
function countPalindromesBruteForce(s: string): number {
  let count = 0;

  // ← 外层：枚举起点
  for (let i = 0; i < s.length; i++) {
    // ← 中层：枚举终点
    for (let j = i; j < s.length; j++) {
      // ← 获取子串
      const substring = s.substring(i, j + 1);

      // ← 检查是否回文
      if (isPalindrome(substring)) {
        count++;
      }
    }
  }

  return count;
}

/**
 * 检查一个字符串是否是回文
 */
function isPalindrome(str: string): boolean {
  const reversed = str.split('').reverse().join('');
  return str === reversed;
}

// 使用示例
console.log(countPalindromesBruteForce("abc"));    // 输出：3
console.log(countPalindromesBruteForce("aba"));    // 输出：4
console.log(countPalindromesBruteForce("aaa"));    // 输出：6
```

---

### 方案2️⃣：中心扩展法（推荐）⭐

**核心思想：**
```
回文的特点：以某个中心为对称轴

所以反向思考：
  选一个中心 → 向两边扩展 → 看能扩展多远

有两种中心：
  1. 单个字符是中心（奇数长度回文）"aba"
  2. 两个字符之间是中心（偶数长度回文）"abba"
```

**时间复杂度：** O(n²)
**空间复杂度：** O(1)

```typescript
/**
 * 中心扩展法（推荐！）
 *
 * 思想：
 * 1. 选择回文的中心
 * 2. 从中心向两边扩展
 * 3. 数一共有多少个回文
 */
function countPalindromesCenterExpand(s: string): number {
  let count = 0;

  // 对于字符串中的每一个位置
  for (let i = 0; i < s.length; i++) {
    // ← 情况1：以单个字符为中心（奇数长度）
    count += expandAroundCenter(s, i, i);

    // ← 情况2：以两个字符之间为中心（偶数长度）
    count += expandAroundCenter(s, i, i + 1);
  }

  return count;
}

/**
 * 从中心向两边扩展，计算有多少个回文
 */
function expandAroundCenter(s: string, left: number, right: number): number {
  let count = 0;

  // ← 从中心开始，不断向两边扩展
  while (left >= 0 && right < s.length && s[left] === s[right]) {
    count++;      // ← 找到一个回文
    left--;       // ← 向左扩展
    right++;      // ← 向右扩展
  }

  return count;
}

// 使用示例
console.log(countPalindromesCenterExpand("abc"));    // 输出：3
console.log(countPalindromesCenterExpand("aba"));    // 输出：4
console.log(countPalindromesCenterExpand("aaa"));    // 输出：6
```

---

## 🧠 深度理解与记忆

### 回文的本质

**什么是回文的中心？**

```
奇数长度回文：有一个单字符中心
  "aba"
    ↑
   中心是'b'

"ababa"
    ↑
   中心是第3个'a'

偶数长度回文：中心在两个字符之间
  "abba"
    ↑ 中心在这里
  "aabb"
    ↑ 中心在这里（但不是回文！）
```

### 中心扩展的过程

**例子：字符串 "aba"**

```
位置0，中心是'a'：
  左右都超出范围，不能扩展
  count = 0

位置0，中心在'a'和'b'之间：
  s[0]='a' 和 s[1]='b' 不相等，不能扩展
  count = 0

位置1，中心是'b'：
  初始：left=1, right=1, s[1]='b'
  匹配！count=1
  扩展：left=0, right=2
  s[0]='a' 和 s[2]='a' 匹配！count=2
  继续扩展：left=-1 或 right=3（超出）
  停止

位置1，中心在'b'和'a'之间：
  s[1]='b' 和 s[2]='a' 不相等，不能扩展
  count = 0

位置2，中心是'a'：
  left=2, right=2, s[2]='a'
  匹配！count=1
  扩展：left=1, right=3（右超出）
  停止

位置2，中心在'a'和超出：
  右已经超出，不处理

总数：0 + 0 + 2 + 0 + 1 + 0 = 3

但等等，我们还没数单个'a'...
```

实际上应该是：
```
"aba" 中的回文：
  "a"（位置0）✓
  "b"（位置1）✓
  "a"（位置2）✓
  "aba"（位置0-2）✓
共4个
```

### 中心扩展的图示

```
字符串：a b a
索引：   0 1 2

尝试中心在位置0（'a'）：
  left=0, right=0
  s[0]='a', 匹配！是"a" ✓ count=1
  left=-1, 超出，停止

尝试中心在位置0-1之间：
  left=0, right=1
  s[0]='a' vs s[1]='b'，不匹配，停止
  count=0

尝试中心在位置1（'b'）：
  left=1, right=1
  s[1]='b', 匹配！是"b" ✓ count=1
  left=0, right=2
  s[0]='a' vs s[2]='a'，匹配！是"aba" ✓ count=1
  left=-1, 超出，停止

尝试中心在位置1-2之间：
  left=1, right=2
  s[1]='b' vs s[2]='a'，不匹配，停止
  count=0

尝试中心在位置2（'a'）：
  left=2, right=2
  s[2]='a', 匹配！是"a" ✓ count=1
  left=1, right=3
  right超出，停止

总数：1 + 0 + (1+1) + 0 + 1 = 4 ✓
```

---

## 三个版本对比

| 方案 | 时间 | 空间 | 优点 | 缺点 |
|------|------|------|------|------|
| 暴力法 | O(n³) | O(1) | 最直观 | 太慢，n大时超时 |
| **中心扩展** | **O(n²)** | **O(1)** | **最优平衡** | **需要理解中心概念** |
| 动态规划 | O(n²) | O(n²) | 可扩展 | 需要额外空间 |

---

## 记忆技巧

### 中心扩展的三句话

```
1️⃣  对每个位置，假设它是回文中心
2️⃣  从中心向两边扩展，数能扩展多远
3️⃣  注意两种中心：单字符和两字符之间
```

### 口诀："选中心，向两边扩，数回文"

```
选中心：选择回文的对称轴
向两边扩：不断扩展找更长的回文
数回文：每次扩展成功都是一个回文
```

---

## 代码框架速记

```typescript
// 中心扩展的框架
function countPalindromes(s) {
  let count = 0;

  for (let i = 0; i < s.length; i++) {
    // 奇数长度：以单字符为中心
    count += expandAroundCenter(s, i, i);

    // 偶数长度：以两字符间为中心
    count += expandAroundCenter(s, i, i + 1);
  }

  return count;
}

function expandAroundCenter(s, left, right) {
  let count = 0;

  while (left >= 0 && right < s.length && s[left] === s[right]) {
    count++;
    left--;
    right++;
  }

  return count;
}
```

---

## 常见错误与避坑

```typescript
// ❌ 错误1：遗漏偶数长度回文
// 只检查奇数长度
for (let i = 0; i < s.length; i++) {
  count += expandAroundCenter(s, i, i);  // ← 漏掉了偶数的情况
}

// ✅ 正确：同时检查两种中心
for (let i = 0; i < s.length; i++) {
  count += expandAroundCenter(s, i, i);        // 奇数
  count += expandAroundCenter(s, i, i + 1);    // 偶数

// ❌ 错误2：扩展条件写错
while (left >= 0 && right < s.length) {  // ← 没检查字符是否相等！
  count++;
  left--;
  right++;
}

// ✅ 正确：必须检查字符相等
while (left >= 0 && right < s.length && s[left] === s[right]) {
  count++;
  left--;
  right++;
}

// ❌ 错误3：计数时机错误
while (left >= 0 && right < s.length && s[left] === s[right]) {
  left--;
  right++;
  count++;  // ← 放在这里也行
}

// ✅ 可以，但最好在前面（逻辑更清晰）
```

---

## 延伸思考

### Q1: 如何找出所有回文子串（不只是计数）？

```typescript
function findAllPalindromes(s) {
  const palindromes = [];

  function expandAroundCenter(left, right) {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
      palindromes.push(s.substring(left, right + 1));  // ← 保存而不是计数
      left--;
      right++;
    }
  }

  for (let i = 0; i < s.length; i++) {
    expandAroundCenter(i, i);
    expandAroundCenter(i, i + 1);
  }

  return palindromes;
}
```

### Q2: 如果有重复的回文怎么办？

```typescript
// 例如 "aaa" 中有两个 "aa"
// 题目通常要求计算所有（包括重复）

"aaa" 的回文：
  "a"（位置0）
  "a"（位置1）
  "a"（位置2）
  "aa"（位置0-1）← 第一个
  "aa"（位置1-2）← 第二个
  "aaa"（位置0-2）
共6个
```

### Q3: 时间复杂度为什么是 O(n²)？

```
外层循环：n 个位置
内层循环（expandAroundCenter）：最多扩展 n 次

总共：n × n = O(n²)

为什么不是 O(n³)？
因为每个字符最多被访问 2 次
（从某个中心向左扩展时访问一次，向右扩展时访问一次）
```
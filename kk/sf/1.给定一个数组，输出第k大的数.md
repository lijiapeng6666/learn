# 给定一个数组，输出第k大的数

## 问题描述
给定一个数组和整数 k，找出数组中第 k 大的元素。

**例如：**
- 数组：`[3, 2, 1, 5, 6, 4]`，k = 2 → 答案是 5（第2大）
- 数组：`[3, 2, 3, 1, 2, 4, 5, 5, 6]`，k = 4 → 答案是 4（第4大）

---

## 解题思路

这道题有多种解法，难度从易到难：

### 1. **排序法**（最简单）
- 思路：直接排序后取第 k 个
- 时间复杂度：O(n log n)
- 适合：数据量小或对时间复杂度要求不高

### 2. **快速选择法**（最优）⭐推荐
- 思路：使用快速排序的分区思想，平均只需遍历一部分数组
- 时间复杂度：O(n)（平均）
- 适合：数据量大，对性能要求高

### 3. **堆法**（中等）
- 思路：维护一个大小为 k 的最小堆
- 时间复杂度：O(n log k)
- 适合：k 远小于 n

---

## 解决方案

### 方案1️⃣：排序法（最简单易懂）

```typescript
/**
 * 使用排序法找第k大的数
 * 思路：
 * 1. 将数组按降序排序
 * 2. 直接返回第 k-1 位置的元素（因为索引从0开始）
 *
 * @param nums 输入数组
 * @param k 第k大
 * @returns 第k大的数
 */
function findKthLargestBySorting(nums: number[], k: number): number {
  // 按降序排序
  nums.sort((a, b) => b - a);

  // 返回第 k-1 位置的元素
  return nums[k - 1];
}

// 使用示例
const arr1 = [3, 2, 1, 5, 6, 4];
console.log(findKthLargestBySorting(arr1, 2)); // 输出：5

const arr2 = [3, 2, 3, 1, 2, 4, 5, 5, 6];
console.log(findKthLargestBySorting(arr2, 4)); // 输出：4
```

**步骤解析：**
```
原数组：[3, 2, 1, 5, 6, 4]，k = 2
排序后：[6, 5, 4, 3, 2, 1]
索引：   [0, 1, 2, 3, 4, 5]
取 k-1 = 1 位置 → 答案：5 ✓
```

---

### 方案2️⃣：快速选择法（最优性能）⭐推荐

```typescript
/**
 * 使用快速选择法找第k大的数（推荐！最优）
 *
 * 核心思想：
 * - 快速排序的分区思想：选择一个基准值，把数组分成两部分
 * - 一部分都 >= 基准，一部分都 < 基准
 * - 不需要完全排序，只需找到第k大所在位置
 *
 * @param nums 输入数组
 * @param k 第k大
 * @returns 第k大的数
 */
function findKthLargestByQuickSelect(nums: number[], k: number): number {
  // 将问题转化为：找第 n - k 小的数
  // 因为第 k 大 = 第 (n - k + 1) 小的数
  const targetIndex = nums.length - k;

  // 调用快速选择辅助函数
  return quickSelect(nums, 0, nums.length - 1, targetIndex);
}

/**
 * 快速选择辅助函数
 * @param nums 数组
 * @param left 左边界
 * @param right 右边界
 * @param targetIndex 目标索引
 * @returns 在目标索引位置的值
 */
function quickSelect(
  nums: number[],
  left: number,
  right: number,
  targetIndex: number
): number {
  // 当只有一个元素时，直接返回
  if (left === right) {
    return nums[left];
  }

  // 分区操作：选择基准值，重新排列数组
  const pivotIndex = partition(nums, left, right);

  // 根据基准值的位置，决定向左还是向右查找
  if (pivotIndex === targetIndex) {
    // 找到了！
    return nums[pivotIndex];
  } else if (pivotIndex < targetIndex) {
    // 目标在右边，向右递归
    return quickSelect(nums, pivotIndex + 1, right, targetIndex);
  } else {
    // 目标在左边，向左递归
    return quickSelect(nums, left, pivotIndex - 1, targetIndex);
  }
}

/**
 * 分区函数：选择基准值，重新排列数组
 * 让所有小于基准的数都在左边，大于等于的都在右边
 */
function partition(nums: number[], left: number, right: number): number {
  // 选择最右边的元素作为基准
  const pivot = nums[right];

  // i 用来追踪分界点
  let i = left;

  // 遍历数组，把小于 pivot 的移到左边
  for (let j = left; j < right; j++) {
    if (nums[j] < pivot) {
      // 交换 nums[i] 和 nums[j]
      [nums[i], nums[j]] = [nums[j], nums[i]];
      i++;
    }
  }

  // 把基准值放到正确位置
  [nums[i], nums[right]] = [nums[right], nums[i]];

  return i;
}

// 使用示例
const arr1 = [3, 2, 1, 5, 6, 4];
console.log(findKthLargestByQuickSelect(arr1, 2)); // 输出：5

const arr2 = [3, 2, 3, 1, 2, 4, 5, 5, 6];
console.log(findKthLargestByQuickSelect(arr2, 4)); // 输出：4
```

**执行过程演示：**
```
原数组：[3, 2, 1, 5, 6, 4]，k = 2
目标索引：6 - 2 = 4（找第4小的数，即第2大）

第1次分区：
- 基准：4，分区后：[3, 2, 1] [4] [5, 6]
- pivotIndex = 3，targetIndex = 4
- 3 < 4，向右查找

第2次分区（右子数组）：
- 数组：[5, 6]
- 基准：6，分区后：[5] [6]
- pivotIndex = 5，targetIndex = 4
- 5 > 4，向左查找

第3次分区（左子数组）：
- 数组：[5]
- pivotIndex = 4，targetIndex = 4
- 找到！返回 nums[4] = 5 ✓
```

---

### 方案3️⃣：堆法（k远小于n时最优）

```typescript
/**
 * 使用最小堆找第k大的数
 *
 * 思想：
 * - 维护一个大小为 k 的最小堆
 * - 遍历数组，如果元素大于堆顶，就删除堆顶，加入新元素
 * - 最后堆顶就是第k大的数
 *
 * @param nums 输入数组
 * @param k 第k大
 * @returns 第k大的数
 */
function findKthLargestByHeap(nums: number[], k: number): number {
  // 创建最小堆（这里用数组表示）
  const heap: number[] = [];

  for (const num of nums) {
    // 加入堆
    heap.push(num);

    // 保持堆的大小为 k
    if (heap.length > k) {
      // 删除堆中最小的元素（根节点）
      heap.sort((a, b) => a - b);
      heap.shift();
    }
  }

  // 最小堆的根（最小值）就是第k大的数
  return Math.min(...heap);
}

// 使用示例
const arr1 = [3, 2, 1, 5, 6, 4];
console.log(findKthLargestByHeap(arr1, 2)); // 输出：5

const arr2 = [3, 2, 3, 1, 2, 4, 5, 5, 6];
console.log(findKthLargestByHeap(arr2, 4)); // 输出：4
```

**执行过程演示：**
```
数组：[3, 2, 1, 5, 6, 4]，k = 2

遍历过程（维护大小为2的最小堆）：
1. 加入3      → heap = [3]
2. 加入2      → heap = [3, 2] 大小=2
3. 加入1      → heap = [3, 2, 1] 大小=3，删除最小值1 → heap = [3, 2]
4. 加入5      → heap = [3, 2, 5] 大小=3，删除最小值2 → heap = [3, 5]
5. 加入6      → heap = [3, 5, 6] 大小=3，删除最小值3 → heap = [5, 6]
6. 加入4      → heap = [5, 6, 4] 大小=3，删除最小值4 → heap = [5, 6]

最后堆中最小值 = min(5, 6) = 5 ✓
```

---

## 方案对比

| 方案 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|-----------|----------|------|------|
| 排序法 | O(n log n) | O(1) | 最简单直观 | 性能一般 |
| **快速选择** | **O(n)平均** | **O(log n)** | **最优性能** | **代码复杂** |
| 堆法 | O(n log k) | O(k) | k小时最优 | 需要堆实现 |

---

## 总结

### 选择建议
- **面试/学习**：先用排序法，再学快速选择 ⭐
- **生产环境**：k 很小用堆法；否则用快速选择
- **快速解题**：用排序法最简单

### 核心要点
1. **排序法**：最直观，O(n log n)
2. **快速选择**：最优效率，O(n) 平均，分而治之思想
3. **堆法**：空间换时间，当 k << n 时最优

---

## 🧠 深度理解与记忆技巧

### 快速选择法 - 最简单的分解讲解

**核心思想（三句话，一定要记住）：**

```
1️⃣  选一个"基准数" → 把数组分成两部分
2️⃣  根据"基准数"的位置，判断目标在哪边
3️⃣  只搜有目标的那一边，排除另一边（不用排整个数组！）
```

---

## 最简单的例子：手工一步步走

**问题：找第2大的数**
```
数组：[3, 2, 1, 5, 6, 4]
k = 2（第2大）
```

**第一步：理解目标**
```
第2大 = 第几小？
→ 第2大就是第(6-2)=4小
→ 目标索引 = 4（在数组的第4个位置，从0开始数）

数组索引：[0, 1, 2, 3, 4, 5]
值：      [3, 2, 1, 5, 6, 4]
                        ↑
                       目标：第4个位置的值

所以我们要找：nums[4] = ?
```

**第二步：第一次分区（PARTITION）**

选最右边的 6 作为基准（随便选一个）：
```
原数组：[3, 2, 1, 5, 6, 4]
               ↑基准=4↑
```

现在用"两个指针"将数组分成两部分：
- **左边（i）**：指向放"小于基准"的位置
- **右边（j）**：向前扫描，找"小于基准"的数

```
开始：
i=0, j=0, 基准=4

j=0: nums[0]=3 < 4？是！
     交换 nums[0] 和 nums[0]（自己和自己）
     [3, 2, 1, 5, 6, 4]
     i=1

j=1: nums[1]=2 < 4？是！
     交换 nums[1] 和 nums[1]（自己和自己）
     [3, 2, 1, 5, 6, 4]
     i=2

j=2: nums[2]=1 < 4？是！
     交换 nums[2] 和 nums[2]（自己和自己）
     [3, 2, 1, 5, 6, 4]
     i=3

j=3: nums[3]=5 < 4？否！
     不交换，i 不动
     [3, 2, 1, 5, 6, 4]
     i=3

j=4: nums[4]=6 < 4？否！
     不交换，i 不动
     [3, 2, 1, 5, 6, 4]
     i=3

扫描结束，把基准放到 i 的位置：
交换 nums[3] 和 nums[5]
[3, 2, 1, 4, 6, 5]
         ↑
    基准在这里了！pivotIndex = 3
```

**分区结果：**
```
[3, 2, 1] | 4 | [6, 5]
 小于4    基准  大于4
 索引0-2   索引3  索引4-5

基准现在在索引3，目标是索引4
3 < 4？是的，目标在右边！
```

**第三步：对右边继续分区**

只看右边：[6, 5]，对应原数组的索引 4-5
```
基准选 5（最右边）

j=4: nums[4]=6 < 5？否！
     [6, 5]
     i=4

j=5跳过（因为j是基准）

交换 nums[4] 和 nums[5]
[5, 6]
pivotIndex = 4
```

**分区结果：**
```
原数组现在是：[3, 2, 1, 4, 5, 6]
索引：        [0, 1, 2, 3, 4, 5]
基准5在索引4，目标是索引4

pivotIndex === targetIndex？
4 === 4？是的！找到了！
```

**答案：nums[4] = 5 ✓**

---

## 用代码看分区过程

```typescript
function partition(nums, left, right) {
  const pivot = nums[right];  // 基准 = 最右边的数
  let i = left;              // i 用来追踪边界

  // ✂️ 分区：遍历 left 到 right-1
  for (let j = left; j < right; j++) {
    if (nums[j] < pivot) {
      // 找到一个"小于基准"的数，交换到左边
      [nums[i], nums[j]] = [nums[j], nums[i]];
      i++;  // 边界向右移动
    }
  }

  // 最后把基准放到正确位置
  [nums[i], nums[right]] = [nums[right], nums[i]];

  return i;  // 返回基准现在的位置
}
```

**这个函数做什么？**
- 输入：数组、左边界、右边界
- 过程：选最右边为基准，把小于基准的都移到左边
- 输出：基准现在的位置 i

---

## 完整的快速选择过程

```typescript
function quickSelect(nums, left, right, targetIndex) {
  if (left === right) {
    // 只剩1个元素，就是答案
    return nums[left];
  }

  // ✂️ 一次分区
  const pivotIndex = partition(nums, left, right);

  // ❓ 问：目标在哪边？
  if (pivotIndex === targetIndex) {
    // 基准正好是目标！找到了
    return nums[pivotIndex];
  } else if (pivotIndex < targetIndex) {
    // 目标在右边，向右搜索
    return quickSelect(nums, pivotIndex + 1, right, targetIndex);
  } else {
    // 目标在左边，向左搜索
    return quickSelect(nums, left, pivotIndex - 1, targetIndex);
  }
}
```

**这个函数的逻辑：**
1. 做一次分区 → 基准找到一个位置
2. 如果基准位置正好是目标 → 完成！
3. 如果基准位置左边 → 目标在右边，继续搜右边
4. 如果基准位置右边 → 目标在左边，继续搜左边

---

## 为什么快？（和排序对比）

```
排序法：必须排好整个数组
[3, 2, 1, 5, 6, 4]
   ↓ 排序很费时间
[1, 2, 3, 4, 5, 6]
取第4个 = 4 ✓

快速选择：不用排整个数组！
[3, 2, 1, 5, 6, 4]
   ↓ 第1次分区
[3, 2, 1] 4 [6, 5]  ← 基准4已经在正确位置
   ↓ 目标在右边，放弃左边
[6, 5]
   ↓ 第2次分区
[5] 6 []  ← 目标在左边
   ↓ 找到！
5 ✓

快速选择只分区了2次，排序要分区6次！
```

---

## 常见困惑解答

### Q1: "为什么第k大 = 第(n-k)小？"

```
数组长度6，k=2（第2大）

升序排列：[1, 2, 3, 4, 5, 6]
           0  1  2  3  4  5  （索引）

第2大 = 5，它在索引4
n - k = 6 - 2 = 4 ✓

原因：
- 最大的（第1大）在索引 n-1 = 5
- 第2大在索引 n-2 = 4
- 第k大在索引 n-k = 4
```

### Q2: "分区后，基准为什么就在正确位置？"

```
分区的特性：
分区后的数组结构：
[小于基准的数...] [基准] [大于基准的数...]

基准前面的数都比它小 → 基准不会是第k大
基准后面的数都比它大 → 基准已经在"按从小到大排列"的位置了！

所以如果目标索引 === 基准索引，那基准就是答案
```

### Q3: "为什么要用 left 和 right？"

```
因为我们不是一次分区处理整个数组
而是根据目标位置，递归地只处理有目标的区域

例如：
第1次分区后，目标在右边
→ 下一次就不用看左边，直接搜 [pivotIndex+1, right]

这样速度才能从 O(n log n) 降到 O(n)
```

### Q4: "i 和 j 指针的作用分别是什么？"

```
j: 扫描指针，从左到右扫描所有数
i: 边界指针，标记"小于基准"和"大于基准"的分界线

当 j 扫到一个小于基准的数时：
- 它本来在"大于基准"的区域
- 要把它交换到左边，交换给 i
- i 再向右移动，扩大"小于基准"的区域

最后 i 的位置就是基准该去的位置
```

---

### 堆法 - 用装水杯子理解

**场景类比：用小杯子装出"最大的k个数"**

```
想象有n个球（数组），你需要用k个杯子装出最重的k个球

方法：只保留最重的k个
┌──────────────────────────────────┐
│ 初始：有6个球                     │
│ [3, 2, 1, 5, 6, 4]               │
│                                   │
│ 准备：k=2的杯子                   │
│                                   │
│ 步骤1：放入3、2 → [3, 2]          │
│        杯子满了！记住最轻的：2     │
│                                   │
│ 步骤2：来了1，比最轻的2还轻      │
│        不放！跳过                 │
│                                   │
│ 步骤3：来了5，比最轻的2重         │
│        丢掉2，放入5 → [3, 5]       │
│        现在最轻的是3              │
│                                   │
│ 步骤4：来了6，比最轻的3重         │
│        丢掉3，放入6 → [5, 6]       │
│        现在最轻的是5              │
│                                   │
│ 步骤5：来了4，比最轻的5轻         │
│        不放！跳过                 │
│                                   │
│ 结果：杯子里最轻的 = 5            │
│ 这就是第2重的球！ ✓               │
└──────────────────────────────────┘
```

**为什么这样做？**
```
核心思想：只记住最大的k个，其他的都丢掉
- 不用存储所有n个数
- 只维护k个数
- 每次比较和操作都是O(log k)，总共O(n log k)
- 比完全排序的O(n log n)快得多（当k很小时）
```

**最小堆的定义：**
```
堆的性质：父节点 < 子节点（最小堆）

       最小值在顶端（根）
         min
        /  \
       L    R
      / \  / \
     ...

为什么用最小堆？
→ 杯子里最轻的球很容易找到（在堆顶）
→ 新球来了，如果比最轻的还轻就不要
→ 如果比最轻的重，就丢掉最轻的，加入新球
```

---

### 快速选择 vs 堆法 - 速度对比图

```
运行时间 对比（n=100万）
    ↑
    │
时间 │  O(n log n) 排序法 ─────────────
    │           /
    │          /
    │         /
    │    ╱──────  O(n) 快速选择（平均）
    │   ╱
    │  ╱
    │ ╱  O(n log k) 堆法（k=100）
    └──────────────────────────→
         k 值大小

结论：
- k ≥ n/10：用快速选择（最快）
- k ≤ n/100：用堆法（节省空间和时间）
- k 中等：都可以，看个人熟悉度
```

---

### 记忆技巧总结

#### 🎯 快速选择 - 三句话记住

1. **分而治之**：选基准 → 分左右 → 找目标区域
2. **不用全排**：只需要找到第k个位置就停止
3. **二分思想**：每次排除至少一半的数据

**口诀："一分二找三排除" 🎵**
```
一分：分出小于、等于、大于基准的三部分
二找：找目标在哪一部分
三排除：排除掉不在的区域，缩小搜索范围
```

#### 🎯 堆法 - 三句话记住

1. **维护k个数**：始终只保留最大的k个
2. **丢掉小的**：新数来了，如果比堆顶小就丢掉堆顶
3. **堆顶是答案**：最后堆顶（最小的）就是第k大的数

**口诀："进来丢小，保大留k" 🎵**
```
进来：新数据进来
丢小：如果比最小的还小，就丢掉
保大：只保留最大的k个数
留k：维护k个数的堆
```

---

### 代码框架速记

**快速选择框架：**
```typescript
// 三个函数，两层嵌套，一个递归
function quickSelect(nums, left, right, target) {
  const pivotIdx = partition(nums, left, right); // ← 分
  if (pivotIdx === target) return nums[pivotIdx];  // ← 找到了
  if (pivotIdx < target) return quickSelect(nums, pivotIdx + 1, right, target);  // ← 去右边
  return quickSelect(nums, left, pivotIdx - 1, target);  // ← 去左边
}
```

**堆法框架：**
```typescript
// 一个循环，两个操作
function heapSelect(nums, k) {
  const heap = [];
  for (num of nums) {
    heap.push(num);        // ← 加入
    if (heap.length > k) {
      heap.sort().shift();  // ← 删最小
    }
  }
  return Math.min(...heap);  // ← 返回最小的（就是第k大）
}
```

---

### 推荐学习路径

1. **第一步**（5分钟）：看生活场景类比，理解核心思想
2. **第二步**（10分钟）：用笔纸手工模拟一遍执行过程
3. **第三步**（15分钟）：敲代码，逐行调试看堆栈变化
4. **第四步**（10分钟）：尝试改变k值和数组，观察变化
5. **第五步**（一周）：定期复习，用口诀快速回忆

---

### 常见错误与避坑

**快速选择常见错误：**
```typescript
// ❌ 错误1：目标索引计算错误
const targetIndex = nums.length - k;  // 对的
const targetIndex = k - 1;            // ❌ 错的

// ❌ 错误2：基准元素没有放回正确位置
// 分区后必须确保基准元素在最终位置

// ❌ 错误3：没有排除已处理区域
// 递归时必须使用 pivotIndex ± 1，不能继续包含基准元素
```

**堆法常见错误：**
```typescript
// ❌ 错误1：堆没有维持k的大小
if (heap.length > k) {  // 对的
  heap.shift();
}

// ❌ 错误2：返回值不对
return Math.min(...heap);  // 对的（最小的就是第k大）
return heap[0];            // 需要排序后，不对
```

---

## 实战练习题

**用上面的方法做这些题：**

1. **简单**：找第k小的数（改改题目方向）
2. **中等**：找第k大且重复出现，去重怎么办？
3. **进阶**：两个排序数组，找第k大的元素
4. **困难**：频繁查询第k大，怎样设计数据结构？

---

## 📚 延伸学习

- **快速排序**：快速选择用的就是快排的分区思想
- **堆排序**：深入理解堆的结构和操作
- **二分查找**：思路和快速选择的"二分"很像
- **中位数**：当k=n/2时的特殊情况
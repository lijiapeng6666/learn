# 18. 观察者模式 - 事件监听系统

## 题目描述

实现一个**事件监听系统**，支持以下功能：

1. **注册观察者（subscribe）**：观察者可以订阅某个事件
2. **取消观察者（unsubscribe）**：观察者可以取消订阅某个事件
3. **发送事件（emit）**：发送事件时，所有订阅该事件的观察者都会收到通知
4. **事件去重**：同一个观察者对同一个事件只能订阅一次

## 示例

```javascript
const eventEmitter = new EventEmitter();

// 定义观察者（回调函数）
const callback1 = (data) => console.log("Observer 1:", data);
const callback2 = (data) => console.log("Observer 2:", data);

// 订阅事件
eventEmitter.subscribe("login", callback1);
eventEmitter.subscribe("login", callback2);
eventEmitter.subscribe("logout", callback1);

// 发送事件
eventEmitter.emit("login", { user: "Alice" });
// 输出:
// Observer 1: { user: 'Alice' }
// Observer 2: { user: 'Alice' }

eventEmitter.emit("logout", { user: "Alice" });
// 输出:
// Observer 1: { user: 'Alice' }

// 取消订阅
eventEmitter.unsubscribe("login", callback1);
eventEmitter.emit("login", { user: "Bob" });
// 输出:
// Observer 2: { user: 'Bob' }

// 取消订阅所有该事件的观察者
eventEmitter.unsubscribeAll("login");
eventEmitter.emit("login", { user: "Charlie" });
// 没有输出
```

## 需求

实现 `EventEmitter` 类，支持以下方法：

| 方法             | 参数                                    | 返回值       | 说明                               |
| ---------------- | --------------------------------------- | ------------ | ---------------------------------- |
| `subscribe`      | `eventName: string, callback: Function` | `void`       | 订阅事件，同一观察者只能订阅一次   |
| `unsubscribe`    | `eventName: string, callback: Function` | `void`       | 取消订阅特定观察者                 |
| `unsubscribeAll` | `eventName: string`                     | `void`       | 取消订阅所有观察者                 |
| `emit`           | `eventName: string, data?: any`         | `void`       | 发送事件给所有订阅者               |
| `listeners`      | `eventName: string`                     | `Function[]` | 获取某事件的所有观察者（用于调试） |

## 约束条件

- 时间复杂度：

  - `subscribe`: O(n)，其中 n 是该事件已有的观察者数量（需要检查是否重复）
  - `unsubscribe`: O(n)
  - `emit`: O(n)

- 空间复杂度：O(m \* n)，其中 m 是事件类型数，n 是平均观察者数

## 扩展需求（可选）

1. **支持 once 方法**：观察者只监听一次事件

   ```javascript
   eventEmitter.once("login", callback);
   eventEmitter.emit("login", data); // callback 执行
   eventEmitter.emit("login", data); // callback 不执行
   ```

2. **支持优先级订阅**：不同优先级的观察者按顺序执行

   ```javascript
   eventEmitter.subscribe("login", callback1, 1);
   eventEmitter.subscribe("login", callback2, 10); // 优先级更高，先执行
   ```

3. **支持异步回调**：回调可以是异步函数，emit 等待所有回调完成
   ```javascript
   await eventEmitter.emit("login", data);
   ```

## 相关问题

- 如何处理订阅过程中的重复回调？
- 如何有效地移除观察者？
- 在执行观察者列表时移除观察者会有什么问题？

## 参考答案

### 基础实现

```javascript
class EventEmitter {
  constructor() {
    this.events = {}; // { eventName: [callback1, callback2, ...] }
  }

  subscribe(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }

    // 检查是否已经订阅，避免重复
    if (!this.events[eventName].includes(callback)) {
      this.events[eventName].push(callback);
    }
  }

  unsubscribe(eventName, callback) {
    if (!this.events[eventName]) return;

    const index = this.events[eventName].indexOf(callback);
    if (index !== -1) {
      this.events[eventName].splice(index, 1);
    }
  }

  unsubscribeAll(eventName) {
    if (this.events[eventName]) {
      this.events[eventName] = [];
    }
  }

  emit(eventName, data) {
    if (!this.events[eventName]) return;

    // 创建副本以避免迭代中修改的问题
    const callbacks = [...this.events[eventName]];
    callbacks.forEach((callback) => {
      callback(data);
    });
  }

  listeners(eventName) {
    return this.events[eventName] || [];
  }
}
```

### 扩展实现（带 once）

```javascript
class EventEmitter {
  constructor() {
    this.events = {};
    this.onceCallbacks = new WeakMap(); // 用于追踪 once 回调
  }

  subscribe(eventName, callback, isOnce = false) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }

    if (!this.events[eventName].includes(callback)) {
      this.events[eventName].push(callback);

      if (isOnce) {
        if (!this.onceCallbacks.has(callback)) {
          this.onceCallbacks.set(callback, new Set());
        }
        this.onceCallbacks.get(callback).add(eventName);
      }
    }
  }

  once(eventName, callback) {
    this.subscribe(eventName, callback, true);
  }

  unsubscribe(eventName, callback) {
    if (!this.events[eventName]) return;

    const index = this.events[eventName].indexOf(callback);
    if (index !== -1) {
      this.events[eventName].splice(index, 1);
    }
  }

  emit(eventName, data) {
    if (!this.events[eventName]) return;

    const callbacks = [...this.events[eventName]];
    callbacks.forEach((callback) => {
      callback(data);

      // 如果是 once 回调，执行后移除
      if (
        this.onceCallbacks.has(callback) &&
        this.onceCallbacks.get(callback).has(eventName)
      ) {
        this.unsubscribe(eventName, callback);
      }
    });
  }

  listeners(eventName) {
    return this.events[eventName] || [];
  }
}
```

## 测试用例

```javascript
// 测试基础功能
const emitter = new EventEmitter();

const onLogin = (user) => console.log(`${user} logged in`);
const onLogout = (user) => console.log(`${user} logged out`);

emitter.subscribe("login", onLogin);
emitter.subscribe("login", onLogout);
emitter.emit("login", "Alice"); // Alice logged in, Alice logged out

emitter.unsubscribe("login", onLogout);
emitter.emit("login", "Bob"); // Bob logged in

// 测试去重
emitter.subscribe("login", onLogin); // 重复订阅，应该被忽略
console.log(emitter.listeners("login").length); // 1

// 测试 once
const emitter2 = new EventEmitter();
const tempCallback = (msg) => console.log("Temp:", msg);
emitter2.once("temp", tempCallback);
emitter2.emit("temp", "Hello"); // Temp: Hello
emitter2.emit("temp", "World"); // 无输出
```

## 核心知识点

1. **设计模式**：观察者模式的实现
2. **数据结构**：使用对象和数组管理事件和回调
3. **去重检查**：`includes()` 方法检查重复
4. **安全迭代**：创建副本避免迭代中修改
5. **内存管理**：及时清理取消订阅的回调
6. **WeakMap 应用**：用于追踪一次性回调

## 难度等级

⭐⭐⭐ (中等)

---

**提示**：

- 考虑边界情况，如订阅不存在的事件
- 在执行回调时创建副本，避免并发修改问题
- 一次性订阅需要额外的数据结构追踪

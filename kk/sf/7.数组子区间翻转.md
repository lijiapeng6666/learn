# 数组子区间翻转

## 问题描述

给定一个数组和 n 个子区间，要求按照这些子区间依次进行翻转操作，最后输出翻转后的数组。

**什么是子区间翻转？**
```
数组：[1, 2, 3, 4, 5]
翻转区间 [1, 4] 表示：将索引 1 到 4 的元素翻转
  注意：这里的索引可能是 1-based（从1开始）或 0-based（从0开始）
  假设是 1-based，那么对应数组的索引 0-3（4个元素）

过程：[1, 2, 3, 4, 5] → [4, 3, 2, 1, 5]
      ↑ 保留        ↑ 翻转这部分 ↑ 保留

再翻转区间 [2, 3]（1-based）：
过程：[4, 3, 2, 1, 5] → [4, 2, 3, 1, 5]
      ↑ 保留 ↑ 翻转 ↑ 保留
```

**例子：**
```
初始数组：[1, 2, 3, 4, 5]
操作1：翻转区间 [1, 4]
  结果：[4, 3, 2, 1, 5]

操作2：翻转区间 [2, 3]
  结果：[4, 2, 3, 1, 5]

最终答案：[4, 2, 3, 1, 5]
```

**关键问题：**
- 区间是 1-based 还是 0-based？
- 区间是闭区间 `[a, b]`（包括两端点）还是左闭右开 `[a, b)`？
- 多个操作是**顺序执行**还是**并行执行**？

---

## 解题思路

### 核心思想

```
1️⃣  理解数据结构
    - 数组索引的表示方式（1-based 或 0-based）
    - 区间的表示方式（闭区间还是左闭右开）

2️⃣  逐个执行翻转操作
    - 按照给定的顺序，依次进行翻转
    - 每次翻转后的结果作为下次翻转的输入

3️⃣  翻转的实现
    - 对于区间 [left, right]，交换两端的元素
    - left++ 和 right-- 逐步向中间靠近
    - 直到 left >= right 为止
```

### 关键变量理解

```
区间 [left, right]：要翻转的起点和终点

如果是 1-based：
  [1, 4] 表示第1到第4个元素，对应数组索引 0-3
  需要转换为 [0, 3] 在数组中使用

如果是 0-based：
  [1, 4] 表示索引 1 到 4，直接使用

如果是闭区间：
  [1, 4] 包括位置1和位置4

如果是左闭右开：
  [1, 4) 包括位置1但不包括位置4
```

---

## 方案1️⃣：双指针翻转（直接修改）

**时间复杂度：** O(n × m)，其中 n 是数组长度，m 是操作数
**空间复杂度：** O(1)（不算返回结果）

```typescript
/**
 * 反转数组的指定区间（假设是 1-based 的闭区间）
 */
function reverseInterval(arr: number[], left: number, right: number): void {
  // 如果是 1-based，转换为 0-based
  left--;
  right--;

  // 从两端向中间逼近，交换元素
  while (left < right) {
    // 交换
    const temp = arr[left];
    arr[left] = arr[right];
    arr[right] = temp;

    left++;
    right--;
  }
}

/**
 * 执行多个翻转操作
 */
function multipleReversal(arr: number[], operations: [number, number][]): number[] {
  // 逐个执行翻转操作
  for (const [left, right] of operations) {
    reverseInterval(arr, left, right);
  }

  return arr;
}
```

---

## 方案2️⃣：三部分拼接法（更直观！）⭐

**核心思想：**
```
数组 = 前半部分 + 要翻转的区间 + 后半部分

步骤：
1️⃣  分割数组成三部分
2️⃣  对中间部分进行翻转
3️⃣  重新拼接三部分
```

**时间复杂度：** O(n × m)
**空间复杂度：** O(n)（需要新数组）

```typescript
/**
 * 三部分拼接法：更直观，更容易理解
 */
function reverseIntervalBySlicing(arr: number[], left: number, right: number): number[] {
  // 1-based 转 0-based
  left--;
  right--;

  // 分割数组成三部分
  const before = arr.slice(0, left);              // 前半部分 [0, left)
  const middle = arr.slice(left, right + 1);     // 中间部分（要翻转的区间）
  const after = arr.slice(right + 1);             // 后半部分 [right + 1, end)

  // 翻转中间部分
  const reversedMiddle = middle.reverse();

  // 拼接三部分
  return [...before, ...reversedMiddle, ...after];
}

/**
 * 使用三部分拼接法执行多个翻转操作
 */
function multipleReversalBySlicing(
  arr: number[],
  operations: [number, number][]
): number[] {
  let result = arr;

  for (const [left, right] of operations) {
    result = reverseIntervalBySlicing(result, left, right);
  }

  return result;
}
```

### 三部分法的详细过程

```
数组：[1, 2, 3, 4, 5]
翻转区间：[1, 4]（1-based）

步骤1：转换为 0-based
  left = 0, right = 3

步骤2：分割成三部分
  before = arr.slice(0, 0) = []           （空）
  middle = arr.slice(0, 4) = [1, 2, 3, 4]
  after = arr.slice(4) = [5]

步骤3：翻转中间部分
  reversedMiddle = [1, 2, 3, 4].reverse() = [4, 3, 2, 1]

步骤4：拼接
  result = [] + [4, 3, 2, 1] + [5] = [4, 3, 2, 1, 5]

---

再翻转区间 [2, 3]（1-based）

步骤1：转换为 0-based
  left = 1, right = 2

步骤2：分割成三部分
  before = [4, 3, 2, 1, 5].slice(0, 1) = [4]
  middle = [4, 3, 2, 1, 5].slice(1, 3) = [3, 2]
  after = [4, 3, 2, 1, 5].slice(3) = [1, 5]

步骤3：翻转中间部分
  reversedMiddle = [3, 2].reverse() = [2, 3]

步骤4：拼接
  result = [4] + [2, 3] + [1, 5] = [4, 2, 3, 1, 5]
```

---

## 方案对比

| 方案 | 实现方式 | 空间 | 代码复杂度 | 可读性 | 适用场景 |
|------|--------|------|----------|--------|---------|
| **双指针翻转** | 在原数组基础上交换 | O(1) | 低 | 需要思考 | 空间紧张，在意效率 |
| **三部分拼接** | 分割-翻转-拼接 | O(n) | 低 | 很直观 | 想要清晰易懂的代码 |

---

---

## 详细过程演示

### 例子1：两个翻转操作

```
初始数组：[1, 2, 3, 4, 5]

操作1：翻转 [1, 4]
  1-based 转换为 0-based：[0, 3]

  步骤1：交换 arr[0]=1 和 arr[3]=4
    [4, 2, 3, 1, 5]
    left=0, right=3

  步骤2：交换 arr[1]=2 和 arr[2]=3
    [4, 3, 2, 1, 5]
    left=1, right=2

  步骤3：left >= right，停止

  结果：[4, 3, 2, 1, 5]

操作2：翻转 [2, 3]
  1-based 转换为 0-based：[1, 2]

  步骤1：交换 arr[1]=3 和 arr[2]=2
    [4, 2, 3, 1, 5]
    left=1, right=2

  步骤2：left >= right，停止

  结果：[4, 2, 3, 1, 5]

最终答案：[4, 2, 3, 1, 5]
```

### 例子2：翻转整个数组

```
初始数组：[1, 2, 3, 4, 5]

操作：翻转 [1, 5]（整个数组）
  1-based 转换为 0-based：[0, 4]

  步骤1：交换 arr[0]=1 和 arr[4]=5
    [5, 2, 3, 4, 1]

  步骤2：交换 arr[1]=2 和 arr[3]=4
    [5, 4, 3, 2, 1]

  步骤3：left=2, right=2，left >= right，停止

  结果：[5, 4, 3, 2, 1]
```

### 例子3：多个操作，有重叠

```
初始数组：[1, 2, 3, 4, 5, 6]

操作1：翻转 [1, 3]
  转换为 0-based：[0, 2]
  交换过程：
    [3, 2, 1, 4, 5, 6]

  结果：[3, 2, 1, 4, 5, 6]

操作2：翻转 [2, 5]
  转换为 0-based：[1, 4]
  交换过程：
    [3, 5, 1, 4, 2, 6]

  结果：[3, 5, 1, 4, 2, 6]

操作3：翻转 [3, 4]
  转换为 0-based：[2, 3]
  交换过程：
    [3, 5, 4, 1, 2, 6]

  结果：[3, 5, 4, 1, 2, 6]

最终答案：[3, 5, 4, 1, 2, 6]
```

---

## 🧠 理解题目的关键点

### 索引转换问题

```
题目中的 [1, 4] 是什么意思？

❌ 错误理解1：直接用作数组索引
arr[1] 到 arr[4] 只有4个元素

✅ 正确理解1（如果是 1-based 闭区间）：
   [1, 4] 表示"第1到第4个元素"
   对应数组索引 [0, 3]
   元素个数 = 4 - 1 + 1 = 4 个

✅ 正确理解2（如果是 0-based 闭区间）：
   [1, 4] 表示"索引1到索引4"
   对应元素：arr[1], arr[2], arr[3], arr[4]
   元素个数 = 4 - 1 + 1 = 4 个

通常题目会明确说明，如果没有，看例子推断
题目例子：[1, 4] 翻转后从 [1,2,3,4,5] 变成 [4,3,2,1,5]
  说明翻转的是前4个元素，所以 [1, 4] 是 1-based
```

### 闭区间 vs 左闭右开

```
闭区间 [1, 4]：包括位置1和位置4
  [1, 2, 3, 4, 5]
   ↑ 位置1      ↑ 位置4
   包括         包括
   翻转元素个数 = right - left + 1

左闭右开 [1, 4)：包括位置1但不包括位置4
  [1, 2, 3, 4, 5]
   ↑ 位置1      ↑ 位置4
   包括         不包括
   翻转元素个数 = right - left
```

### 为什么是顺序执行？

```
题目说：先经过 (1,4) 翻转，再经过 (2,3) 翻转

这说明：
✅ 正确：按顺序执行（第一个操作的结果作为第二个操作的输入）
❌ 错误：同时执行所有操作

例如：
操作1结果：[4, 3, 2, 1, 5]
操作2基于操作1的结果，不是基于原数组
```

---

## 代码框架速记

```typescript
// 基础框架
function multipleReversal(arr, operations) {
  // 对每个操作
  for (const [left, right] of operations) {
    // 1. 转换索引（如果需要）
    let l = left - 1;  // 1-based 转 0-based
    let r = right - 1;

    // 2. 翻转区间
    while (l < r) {
      [arr[l], arr[r]] = [arr[r], arr[l]];  // 交换
      l++;
      r--;
    }
  }

  return arr;
}

// 或者提取为单独函数
function reverseInterval(arr, left, right) {
  left--;   // 1-based → 0-based
  right--;

  while (left < right) {
    [arr[left], arr[right]] = [arr[right], arr[left]];
    left++;
    right--;
  }
}

function multipleReversal(arr, operations) {
  for (const [left, right] of operations) {
    reverseInterval(arr, left, right);
  }
  return arr;
}
```

---

## 常见错误与避坑

```typescript
// ❌ 错误1：忘记 1-based 转 0-based
while (left < right) {
  [arr[left], arr[right]] = [arr[right], arr[left]];  // ← 索引可能越界！
  left++;
  right--;
}

// ✅ 正确：先转换
left--;
right--;
while (left < right) {
  [arr[left], arr[right]] = [arr[right], arr[left]];
  left++;
  right--;
}

// ❌ 错误2：闭区间处理错误
while (left < right) {  // ← 这个对闭区间不完全正确
  ...
}

// ✅ 正确：闭区间应该是
while (left < right) {  // ← 其实这样也是对的
  ...
  // 当 left 和 right 指向同一个元素时，不需要交换
}
// 或者更明确地
while (left < right) {
  // 交换 left 和 right 位置的元素
  left++;
  right--;
}

// ❌ 错误3：数组长度计算错误
const elementCount = right - left;  // ← 少1个！

// ✅ 正确：闭区间
const elementCount = right - left + 1;

// ❌ 错误4：修改了原数组的引用，而不是内容
function multipleReversal(arr, operations) {
  let result = arr;  // ← 只是引用，还是原数组

  for (const [left, right] of operations) {
    reverseInterval(result, left, right);  // ← 正确，修改了内容
  }

  return result;  // ← 返回的还是原数组
}

// ✅ 正确（如果需要副本）
function multipleReversal(arr, operations) {
  const result = [...arr];  // ← 创建新数组
  for (const [left, right] of operations) {
    reverseInterval(result, left, right);
  }
  return result;
}

// ❌ 错误5：翻转条件写错
while (left <= right) {  // ← 如果 left === right，单个元素也会"交换"
  [arr[left], arr[right]] = [arr[right], arr[left]];
  left++;
  right--;
}

// ✅ 正确
while (left < right) {  // ← left === right 时停止，不交换
  [arr[left], arr[right]] = [arr[right], arr[left]];
  left++;
  right--;
}
```

---

## 延伸思考

### Q1: 如果有大量的翻转操作，如何优化？

```typescript
// 基础做法：O(n × m)，每次翻转需要遍历区间
function naiveMultipleReversal(arr, operations) {
  for (const [left, right] of operations) {
    reverseInterval(arr, left, right);
  }
  return arr;
}

// 优化做法：使用"差分数组"思想（高级话题）
// 但对于这个问题，通常不需要
```

### Q2: 如果要输出每一步的结果怎么办？

```typescript
function multipleReversalWithSteps(arr, operations) {
  const steps = [structuredClone(arr)];  // 第一步：原始数组

  for (const [left, right] of operations) {
    reverseInterval(arr, left, right);
    steps.push(structuredClone(arr));  // 记录每一步
  }

  return steps;
}
```

### Q3: 如果区间是左闭右开 `[left, right)` 怎么办？

```typescript
function reverseIntervalLeftClosedRightOpen(arr, left, right) {
  // 不需要 -1，直接用
  left--;  // 只有 left 需要转换（从 1-based 到 0-based）
  right--;  // right 本身是开区间，转换后实际指向要翻转的最后一个元素

  // 等等，这样不对...

  // 正确的做法：
  left--;   // 1-based 左端转换
  // right 已经是开区间，转换后就是最后一个元素的下一个
  right--;  // 但我们要访问最后一个元素，所以要 right - 1

  while (left < right) {
    [arr[left], arr[right]] = [arr[right], arr[left]];
    left++;
    right--;
  }
}

// 或者更清晰地：
function reverseIntervalLeftClosedRightOpen(arr, left, right) {
  // [left, right) 在 1-based 的左闭右开
  // 对应 0-based 的 [left-1, right-1)
  left--;
  // right 不变，因为 [left-1, right-1) 中 right-1 不包括在内

  let r = right - 1;  // 最后一个要翻转的元素的索引

  while (left < r) {
    [arr[left], arr[r]] = [arr[r], arr[left]];
    left++;
    r--;
  }
}
```

### Q4: 能用 reverse() 方法吗？

```typescript
// JavaScript 有内置的 reverse() 方法
function multipleReversalWithBuiltin(arr, operations) {
  for (const [left, right] of operations) {
    // arr.reverse() 翻转整个数组

    // 要翻转子区间，可以这样：
    const subarray = arr.slice(left - 1, right);  // 提取子数组
    subarray.reverse();  // 翻转

    // 放回原数组
    arr.splice(left - 1, right - left + 1, ...subarray);
  }

  return arr;
}

// 但这样做效率不高，因为 splice 和 slice 都需要创建新数组
```

---

## 总结

| 步骤 | 操作 | 关键点 |
|------|------|--------|
| 1 | **确定索引体系** | 1-based 还是 0-based？ |
| 2 | **确定区间类型** | 闭区间还是左闭右开？ |
| 3 | **逐个执行操作** | 顺序很重要，前一个操作的结果是后一个操作的输入 |
| 4 | **实现翻转** | 从两端向中间交换元素，`left < right` 时停止 |
| 5 | **返回结果** | 返回修改后的数组 |

**口诀：确定索引 → 索引转换 → 双指针翻转 → 顺序执行**

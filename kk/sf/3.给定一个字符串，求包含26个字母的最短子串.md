# 给定一个字符串，求包含26个字母的最短子串

## ⚠️ 题意更正（你理解错了！）

### ❌ 错误的理解

```
"长度就是26个字符"就够了？

错了！比如：
子串："abcaaaaaaaaaaaaaaaaaaaaaa"
长度：26个字符
但它只包含 'a' 和 'b' 两种字母（不是26种！）
```

### ✅ 正确的理解

```
"包含26个字母" = "包含 a, b, c, d, ..., z 这26种字母都各至少出现一次"

不是长度26，而是 26种不同的字母！
```

## 问题描述

给定一个字符串 `s`，找出**包含所有26个英文字母（a-z都要有）的最短连续子串**。

### 关键点

- **"包含26个字母"** ≠ 长度26
- **"包含26个字母"** = 包含a,b,c,...,z这26种字母都至少出现一次
- **"最短子串"** = 满足上面条件的，长度最小的

**例如：**

```
字符串：abcdefghijklmnopqrstuvwxyzabc

- 从1-26位：abcdefghijklmnopqrstuvwxyz  ✓ 包含26种字母，长度26
- 从2-27位：bcdefghijklmnopqrstuvwxyza  ✓ 包含26种字母，长度26
- 从1-27位：abcdefghijklmnopqrstuvwxyza ✓ 包含26种字母，长度27（更长）

最短的是长度26的

但如果字符串排列不同：
字符串：abcabc...xyz（其他字母穿插）

可能需要更长，比如：
- 从1-35位：包含了26种字母，长度35

答案就是这个长度35的
```

### 为什么说"最短"？

**因为可能有多个子串都包含26种字母，但长度不同！**

#### 例子1：简单情况

```
字符串：abcdefghijklmnopqrstuvwxyzabc

检查所有可能的子串：
□ 从位置0-25：abcdefghijklmnopqrstuvwxyz
  包含的字母：a,b,c,...,z（26种）✓ 满足！
  长度：26

□ 从位置0-26：abcdefghijklmnopqrstuvwxyza
  包含的字母：a,b,c,...,z（26种）✓ 满足！
  长度：27（比上面长）

□ 从位置1-27：bcdefghijklmnopqrstuvwxyzab
  包含的字母：a,b,c,...,z（26种）✓ 满足！
  长度：27

□ 从位置0-27：abcdefghijklmnopqrstuvwxyzab
  包含的字母：a,b,c,...,z（26种）✓ 满足！
  长度：28

答案：最短的是 abcdefghijklmnopqrstuvwxyz（长度26）
```

#### 例子2：复杂情况

```
字符串：abcdefghijklmnopqrstuvwxyzzzzabc

检查所有可能的子串：
□ 从位置0-25：abcdefghijklmnopqrstuvwxyz
  包含的字母：a,b,c,...,z（26种）✓
  长度：26

□ 从位置0-26：abcdefghijklmnopqrstuvwxyzz
  包含的字母：a,b,c,...,z（26种）✓
  长度：27

...其他都更长或缺少某个字母...

答案：最短的还是 abcdefghijklmnopqrstuvwxyz（长度26）
```

#### 例子3：需要很长的情况

```
字符串：aaaaaabbbbbcccccdddddeeeeeffffffggggghhhhhiiiiijjjjjkkkkklllllmmmmmnnnnnooooopppppqqqqq...xyz

检查所有可能的子串：
□ 前25个字母都是重复的 'a'：
  - 从0-25：aaaaaa...
    包含的字母：只有'a'（1种）❌ 不满足

□ 需要到最后才能凑齐所有26种：
  - 从0-??：aaaaa...bbbbb...ccccc...xyz
    包含的字母：a,b,c,...,z（26种）✓ 满足！
    长度：可能是100、200甚至更长

这种情况答案就是很长的那个字符串
```

### 总结

```
"最短子串"的意思：
在所有包含26种字母的子串中，长度最小的那个
```

### 关键对比

| 项目 | 错误理解 | 正确理解 |
|------|---------|---------|
| "包含26个字母" | 长度 = 26 | 包含 a-z 各至少1个 |
| 例子 | "abcabcabcabcabcabca" | "abcdefghijklmnopqrstuvwxyz" |
| 是否满足 | 长度26但缺少字母 ❌ | 26种字母都有 ✓ |
| "最短" | 所有长度26的都一样 | 在满足条件的中选最短的 |

---

## 解题思路

### 方案1️⃣：暴力法（最简单但最慢）

## 用"找字母"的游戏来理解

**问题：** 给你一个很长的字符串，找出包含所有26个英文字母的最短片段

**最笨的办法（暴力法）：**

```
假设字符串是："xyzabcdefghijklmnopqrstuvwxyzabc"

我的做法就是：
1. 从第1个字符开始，往后看
   - 看第1个：只有'x'（缺少其他25个字母）❌
   - 看第1-2个：'xy'（缺少其他24个字母）❌
   - 看第1-3个：'xyz'（缺少其他23个字母）❌
   - ...
   - 看第1-29个：有26个字母了！✓ 记住长度29

2. 从第2个字符开始，往后看
   - 看第2个：只有'y'❌
   - ...
   - 看第2-29个：有26个字母了！✓ 记住长度28

3. 从第3个字符开始，继续...

4. 找出最短的（长度28）
```

**这就是暴力法！** 没有任何技巧，就是逐个试。

---

## 最简洁的理解

暴力法 = **逐个尝试所有的片段，找最短的那个**

```
就像你要从一堆钥匙里找开锁的那个，
最笨的办法就是：
  第1把钥匙 → 不行
  第2把钥匙 → 不行
  第3把钥匙 → 行！记住这个
  第4把钥匙 → 也行，但不如第3把好
  ...
  最后选最好的
```

---

## 两层循环的意思

```
for (let i = 0; i < s.length; i++) {
  // i = 0, 1, 2, 3, ...
  // 意思是：从不同的位置开始

  for (let j = i; j < s.length; j++) {
    // j = i, i+1, i+2, ...
    // 意思是：往后看不同的距离

    // 所以这两层循环一起，就是：
    // 试 从位置0开始往后看1个字符
    // 试 从位置0开始往后看2个字符
    // ...
    // 试 从位置1开始往后看1个字符
    // 试 从位置1开始往后看2个字符
    // ...
    // 试 遍历所有可能的片段！
  }
}
```

---

## 三个关键问题

### ❓ 1. 什么是"子串"？

```
"abcde" 这个字符串中：
  "a", "b", "c", "d", "e"           ← 单个字符
  "ab", "bc", "cd", "de"            ← 两个连续字符
  "abc", "bcd", "cde"               ← 三个连续字符
  ...
  "abcde"                           ← 整个字符串

这些都是子串（连续的一段）
```

### ❓ 2. 怎样知道"包含26个字母"？

```
如果一个子串是："abcdefghijklmnopqrstuvwxyz"
  ✓ 包含 a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
  ✓ 共26个不同的字母
  ✓ 满足条件

如果一个子串是："abcdefghijklmnopqrstuvwxy"
  ✓ 包含 a,b,c,...,y
  ✗ 缺少 z
  ✗ 只有25个不同的字母
  ✗ 不满足条件
```

### ❓ 3. 怎样找"最短的"？

```
所有满足条件的子串：
  "abcdefghijklmnopqrstuvwxyz"     长度 26 ← 最短！
  "xyzabcdefghijklmnopqrstuvwxyz" 长度 29
  "abcdefghijklmnopqrstuvwxyzx"   长度 27

选第一个（长度26）
```

---

## 代码框架（最简版）

```javascript
let 最短的 = "";

对字符串中的每一个位置 i：
  对从 i 往后的每一个位置 j：
    取出从 i 到 j 的片段

    如果这个片段包含26个字母：
      如果它比"最短的"更短：
        更新"最短的"

返回"最短的"
```

就是这样！
- 第一层循环：从哪里开始？
- 第二层循环：往后看多远？
- 每次都检查：满足条件吗？
- 记录最好的答案

```typescript
/**
 * 暴力法：枚举所有子串（用Map）
 * 最简单的讲解版本！
 */
function minWindowBruteForceMap(s: string): string {
  const ALPHABET_SIZE = 26;
  let minSubstring = '';  // 记录最短子串

  // ========== 外层循环：枚举起点 ==========
  for (let i = 0; i < s.length; i++) {
    // 每个新的起点，重置计数器
    const charCount = new Map();  // 记录这个子串里每个字母出现多少次

    // ========== 内层循环：枚举终点 ==========
    for (let j = i; j < s.length; j++) {
      const char = s[j];  // 当前字符

      // ← 加入这个字符
      if (charCount.has(char)) {
        charCount.set(char, charCount.get(char) + 1);
      } else {
        charCount.set(char, 1);
      }

      // ========== 关键：检查 ==========
      // charCount.size 就是"有多少种不同的字母"
      if (charCount.size === ALPHABET_SIZE) {
        // ← 找到了一个包含26个字母的子串！
        const substring = s.substring(i, j + 1);

        // ← 检查是否比之前的更短
        if (minSubstring === '' || substring.length < minSubstring.length) {
          minSubstring = substring;  // 更新最短的
        }
      }
    }
  }

  return minSubstring;  // 返回最短子串（如果没找到则返回空）
}

/**
 * 暴力法：枚举所有子串（用数组）
 * 用数组也完全可以！
 */
function minWindowBruteForceArray(s: string): string {
  const ALPHABET_SIZE = 26;
  let minSubstring = '';

  // 枚举所有起点
  for (let i = 0; i < s.length; i++) {
    // 用数组记录每个字母出现的次数
    const charCount = new Array(26).fill(0);  // 26个字母，初始都是0
    let uniqueCount = 0;  // 记录有多少个不同的字母出现过

    // 枚举所有终点
    for (let j = i; j < s.length; j++) {
      const char = s[j];
      const index = char.charCodeAt(0) - 'a'.charCodeAt(0);  // 转换为 0-25

      // 如果这个字母第一次出现
      if (charCount[index] === 0) {
        uniqueCount++;
      }

      charCount[index]++;

      // 检查是否包含26个字母
      if (uniqueCount === ALPHABET_SIZE) {
        const substring = s.substring(i, j + 1);

        // 记录最短的
        if (minSubstring === '' || substring.length < minSubstring.length) {
          minSubstring = substring;
        }
      }
    }
  }

  return minSubstring;
}

// 使用示例
console.log(minWindowBruteForceMap("abacbababac"));
console.log(minWindowBruteForceArray("abacbababac"));
// 输出：某个26字母子串（如果存在）
```

---

### 方案2️⃣：滑动窗口 + 哈希表（最优）⭐推荐

**核心思想：**
```
用两个指针维护一个"窗口"
左指针：window 的起点
右指针：window 的终点

思路：
1. 右指针不断向右扩展，直到找到包含所有26个字母的窗口
2. 左指针不断向左收缩，尽量缩小窗口
3. 记录最短的满足条件的窗口
```

**时间复杂度：** O(n)（两个指针各扫一遍）
**空间复杂度：** O(26) = O(1)

```typescript
/**
 * 滑动窗口法（最优！）
 *
 * 关键思想：
 * - 用哈希表记录窗口内每个字母的出现次数
 * - 用另一个变量记录"包含的不同字母个数"
 * - 不断调整左右指针
 */
function minWindow(s: string): string {
  const ALPHABET_SIZE = 26;
  const charCount = new Map<string, number>();  // 窗口内的字母计数
  let minStart = 0;  // 最短子串的起点
  let minLength = Infinity;  // 最短子串的长度
  let left = 0;  // 左指针

  // 右指针扫描字符串
  for (let right = 0; right < s.length; right++) {
    const char = s[right];

    // ← 扩展窗口：加入右指针指向的字符
    charCount.set(char, (charCount.get(char) || 0) + 1);

    // ← 检查：窗口是否包含所有26个字母？
    while (charCount.size === ALPHABET_SIZE) {
      // ← 收缩：尝试从左边删除字符，缩小窗口
      const windowLength = right - left + 1;

      // ← 记录最短的
      if (windowLength < minLength) {
        minLength = windowLength;
        minStart = left;
      }

      // ← 删除左指针指向的字符
      const leftChar = s[left];
      charCount.set(leftChar, charCount.get(leftChar)! - 1);

      // ← 如果字符数变为0，移除该字母
      if (charCount.get(leftChar) === 0) {
        charCount.delete(leftChar);
      }

      // ← 左指针右移
      left++;
    }
  }

  // ← 没找到满足条件的子串
  return minLength === Infinity ? '' : s.substring(minStart, minStart + minLength);
}

// 使用示例
console.log(minWindow("abacbababac"));
// 输出：最短的包含26个字母的子串
```

---

## 🧠 深度理解与记忆

### 核心概念：滑动窗口

**什么是滑动窗口？**

想象一个开口的框，在字符串上滑动：

```
字符串：a b a c b a b a b a c
窗口：  [...]      ← 这个框在滑动

左指针   右指针
  ↓       ↓
  a b a c b a b a b a c
  ├─────────┤
  包含的字母
```

**三个阶段：**

```
阶段1：扩展窗口
  left固定，right向右移动
  目的：找到包含所有26个字母的窗口

阶段2：检查
  检查当前窗口是否包含26个字母
  如果是，记录这个窗口

阶段3：收缩窗口
  right固定，left向右移动
  目的：缩小窗口，找更小的
  直到不满足条件为止
```

---

### 手工演示

**字符串：假设有包含所有26个字母的字符串**

```
例：s = "abcdefghijklmnopqrstuvwxyz..." (后面有重复)

初始状态：
left = 0, right = 0
charCount = {}
minLength = ∞

第1步到第26步（right 不断右移）：
当 right 到达第26时（z）
charCount = {a:1, b:1, c:1, ..., z:1}
charCount.size = 26  ← 找到了！

记录：minLength = 26, minStart = 0
现在尝试收缩（left 右移）

left = 1:
删除 s[0] = 'a'
charCount = {b:1, c:1, ..., z:1}  （少了 a）
charCount.size = 25  < 26
停止收缩，继续扩展

right = 27:
加入 s[27] = ?（假设重复）
...继续...
```

---

## 三个版本对比

| 方案 | 时间 | 空间 | 优点 | 缺点 |
|------|------|------|------|------|
| 暴力法 | O(n²) | O(1) | 简单直观 | 慢，n大时超时 |
| **滑动窗口** | **O(n)** | **O(1)** | **最优性能** | **需要理解双指针** |

---

## 记忆技巧

### 滑动窗口的三句话

```
1️⃣  右指针不断扩展：right++，加入新字符

2️⃣  检查窗口：charCount.size === 26？

3️⃣  左指针收缩：left++，尽量缩小窗口
```

### 口诀："右扩左缩，记录最小"

```
右扩：右指针向右扩展窗口，收集字符
左缩：左指针向左收缩窗口，缩小范围
记录：记录每个满足条件的最小窗口
```

---

## 代码框架速记

```typescript
// 滑动窗口框架
const charCount = new Map();
let minLength = Infinity, minStart = 0;
let left = 0;

for (let right = 0; right < s.length; right++) {
  // 1️⃣ 加入右指针的字符
  charCount.set(s[right], (charCount.get(s[right]) || 0) + 1);

  // 2️⃣ 检查窗口是否满足条件
  while (charCount.size === 26) {
    // 3️⃣ 记录
    if (right - left + 1 < minLength) {
      minLength = right - left + 1;
      minStart = left;
    }

    // 4️⃣ 删除左指针的字符，尝试缩小
    charCount.set(s[left], charCount.get(s[left]) - 1);
    if (charCount.get(s[left]) === 0) {
      charCount.delete(s[left]);
    }
    left++;  // 5️⃣ 左指针右移
  }
}

return minLength === Infinity ? '' : s.substring(minStart, minStart + minLength);
```

---

## Map vs 数组：如何选择？

### 用 Map 还是数组？都可以！

**Map 的优点和缺点：**

```typescript
// ✅ 优点：只记录出现过的字母
const charCount = new Map();
// 如果字符串只有 a, b, c，Map 就只记录这3个
// 空间效率高

// ❌ 缺点：检查"有多少个不同字母"需要 charCount.size
// charCount.size 操作很快，但逻辑稍微复杂一点
if (charCount.size === 26) { ... }
```

**数组的优点和缺点：**

```typescript
// ✅ 优点：直接用数组下标访问，速度极快
const charCount = new Array(26).fill(0);
const index = char.charCodeAt(0) - 'a'.charCodeAt(0);
charCount[index]++;  // O(1) 访问

// ✅ 优点：可以用 uniqueCount 手动追踪不同字母个数
let uniqueCount = 0;
if (charCount[index] === 0) {
  uniqueCount++;  // 更清晰！
}

// ❌ 缺点：总是预先分配26个空间
// 对于小字符串可能有点浪费（但也很少）
```

---

### 推荐方案

| 场景 | 推荐 | 原因 |
|------|------|------|
| **暴力法** | 数组 | 简单直接，字母就26个，不浪费 |
| **滑动窗口** | Map | 逻辑清晰，`.size` 更好用 |

---

## 常见错误与避坑

```typescript
// ============ 用 Map 时的错误 ============

// ❌ 错误1：检查条件用 charCount.size >= 26
// 最多也只有26个不同的小写字母

// ✅ 正确：用 charCount.size === 26
if (charCount.size === 26) { ... }

// ❌ 错误2：没有正确删除字符
charCount.delete(s[left]);  // 直接删，可能有多个

// ✅ 正确：先递减，再判断是否为0
charCount.set(s[left], charCount.get(s[left]) - 1);
if (charCount.get(s[left]) === 0) {
  charCount.delete(s[left]);
}

// ❌ 错误3：收缩时用 if 而不是 while
// 有时可能一次就能缩到不满足条件

// ✅ 正确：用 while，尽量缩小
while (charCount.size === 26) {
  // 尝试缩小
  left++;
}

// ============ 用数组时的错误 ============

// ❌ 错误1：忘记用 uniqueCount 追踪不同字母
// 每次都遍历数组检查非零个数，太慢
for (let k = 0; k < 26; k++) {
  if (charCount[k] > 0) count++;
}

// ✅ 正确：用 uniqueCount 变量
let uniqueCount = 0;
if (charCount[index] === 0) {
  uniqueCount++;  // 只在第一次 +1
}

// ❌ 错误2：字符转索引错误
const index = char.charCodeAt(0) - 'a'.charCodeAt(0);  // 对
const index = char - 'a';  // 错！JavaScript 不支持字符减法

// ❌ 错误3：初始化错误
const charCount = new Array(26);  // ❌ 全是 undefined
const charCount = new Array(26).fill(0);  // ✅ 全是 0

// ❌ 错误4：没有检查输入字符是否都是小写字母
// 如果有大写、数字或特殊字符，转换会出错

// ✅ 正确：确保只处理小写字母
if (char < 'a' || char > 'z') continue;
```

---

## 三种实现对比

| 特性 | Map版本 | 数组版本 |
|------|---------|---------|
| 代码简洁度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 执行速度 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 空间效率 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 易理解 | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| 推荐程度 | 滑动窗口时用 | 暴力法时用 |

---

## 延伸思考

### Q1: 如果是求"包含 k 个不同字母的最短子串"呢？

```typescript
// 只需改一行！
while (charCount.size === k) {  // 改这里
  // 其他逻辑不变
}
```

### Q2: 如果要包含特定的字母集合呢？

```typescript
// 改成检查特定字母
const required = new Set(['a', 'e', 'i', 'o', 'u']);  // 只要求五个元音

// 检查窗口是否包含所有必要字母
const hasAll = [...required].every(char => charCount.has(char));

while (hasAll) {
  // ...
}
```

### Q3: 时间复杂度为什么是 O(n)？

```
因为：
- 右指针从0扫到n：O(n)
- 左指针也从0扫到n：O(n)
- 两个指针各扫一遍，总共O(2n) = O(n)

不是 O(n²)，因为不是嵌套的，而是"序列"的
```

---

## 对比：窗口变化过程

```
假设字符串有大量字符，包含多个完整的字母表

初始：left=0, right=0, 窗口为空
      ↓
右扩：left=0, right=扫到第26个
      ├─────────────────┤  窗口大小=26

发现满足条件，尝试收缩：
左缩：left=1, right=还是原来的位置
      ├──────────────┤     窗口大小=25

继续扫描：
右扩：left=1, right=继续向右
      ├────────────────────┤  窗口变大

再满足条件，再收缩...

这样不断重复，找到最小的满足条件的窗口
```
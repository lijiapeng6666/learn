# 第11题详细解答：进度与重试机制（AI 生成任务）

> 题干：生成任务的进度显示和失败重试逻辑是如何实现的？（考察点：用户体验设计、错误分类与幂等、工程稳健性）

## 面试者视角（怎么答）

### 1) 进度模型与展示
- 状态分级：`QUEUED`/`RUNNING`/`SUCCEEDED`/`FAILED`/`CANCELED`，`RUNNING` 内细分阶段（预处理/推理/后处理/上传）。
- 权重化进度：各阶段按耗时占比分配权重（如 10/70/15/5），阶段内用服务端返回的 `progress` 或估算推进。
- 估算与校准：首次用历史分布估计 ETA；服务端返回阶段剩余时间时覆盖本地估计。弱网或后台暂停时冻结并提示。
- 多任务列表：任务卡片显示阶段 + 百分比 + 剩余估时；点击可看详情/日志；完成提供快捷入口（下载/预览/复用模板）。

### 2) 重试与幂等
- 错误分类：
  - 可重试：网络/超时/后端 5xx/资源限流（429）/暂时性依赖失败。
  - 不可重试：参数非法/鉴权失败/配额不足/模型不支持。
- 幂等保障：前端提交使用 `idempotencyKey`（任务参数的哈希）；后端对同 key 返回同任务，避免重复计费与排队。
- 指数退避 + 抖动：`base=1s, factor=1.6, max=20s`，对 429/503 延长间隔；提供“立即重试”入口。
- 最大尝试次数：分级上限（如网络类 5 次、5xx 3 次）；达到上限标记“可手动重试”。
- 可恢复重试：允许在“失败可重试”的阶段继续（断点续跑），避免整体重算；失败信息结构化存储，便于定位。

### 3) 前后台/离线策略
- 后台降频：`visibilitychange` 后延长轮询/退避；恢复前台触发“快速补拉”。
- 离线：检测 `navigator.onLine=false` 时暂停轮询与重试，提示“离线将自动恢复”，恢复后短间隔尝试几轮。

### 4) 体验与可见性
- 进度可视化：阶段条 + 百分比 + ETA；失败提供“重试/复制错误日志/联系客服”。
- 完成提醒：系统通知/声音/震动（移动端可选），并在任务中心置顶最近完成项。

### 5) 小结（30s）
- “我们用阶段权重+历史分布估算进度，支持 ETA 校准；错误按可重试/不可重试分类，前端携带幂等 key，重试采用指数退避+抖动并设上限；前后台与离线有降频与补拉策略，用户侧有进度、日志与一键重试。”

---

## 面试官视角（怎么问、看什么）

### 可追问清单（附考点）
- 阶段权重与 ETA 如何确定？
  - 考点：历史分布/监控回归、按模型/参数差异动态调整、服务端回传校准。
- 可重试/不可重试的边界？
  - 考点：HTTP/业务错误分类、限流策略、配额/鉴权处理、幂等保障。
- 幂等 key 的生成与冲突？
  - 考点：参数规范化与哈希、碰撞概率与处理、服务端“同 key 同任务”的一致性。
- 退避参数依据？
  - 考点：基于成本与体验的折中、p75/p95 任务时长、429/503 的特殊处理。
- 断点续跑如何实现？
  - 考点：阶段切分/中间产物持久化、任务上下文序列化、失败重入点。
- 监控与回归怎么做？
  - 考点：失败率分布、平均重试次数、ETA 准确度、用户投诉回流。

### 评估要点
- 是否有权重/ETA 数据依据；是否有幂等与退避；是否考虑离线/后台；失败可恢复与用户可达性。

### 红旗信号
- 固定进度条无校准；无限制重试；重复提交导致多次计费；无失败日志与定位信息。

---

## 代码与配置片段
```ts
// 幂等 key（参数规范化 + 哈希）
import { createHash } from 'crypto'
export function makeIdempotencyKey(input: Record<string, unknown>) {
  const json = JSON.stringify(input, Object.keys(input).sort())
  return createHash('sha256').update(json).digest('hex')
}
```
```ts
// 重试器（指数退避 + 抖动）
export async function retry<T>(fn:()=>Promise<T>, opts:{tries?:number, base?:number, factor?:number, max?:number}={}){
  const tries = opts.tries ?? 5, base = opts.base ?? 1000, factor = opts.factor ?? 1.6, max = opts.max ?? 20000
  let attempt = 0
  while(true){
    try { return await fn() } catch (e:any) {
      attempt++
      if (attempt >= tries) throw e
      const sleep = Math.min(max, Math.floor(base * Math.pow(factor, attempt)))
      const jitter = Math.floor(Math.random() * (sleep * 0.2))
      await new Promise(r=>setTimeout(r, sleep + jitter))
    }
  }
}
```
```ts
// 阶段权重进度聚合
const weights = { preprocess: 10, inference: 70, post: 15, upload: 5 } as const
export function aggregateProgress(stage: keyof typeof weights, stageProgress: number){
  const before = Object.entries(weights).reduce((s,[k,w])=> k===stage? s : s + w, 0)
  const doneBefore = Object.keys(weights).slice(0, Object.keys(weights).indexOf(stage as any)).reduce((s,k)=> s + (weights as any)[k], 0)
  return Math.min(100, Math.floor(doneBefore + stageProgress * (weights as any)[stage]))
}
```

---

## 实战建议
- 为每类模型维护阶段权重画像；ETA 与实际偏差超过阈值时报警并调整权重。
- 统一“重试策略中台”，避免各页面自行实现；失败日志结构化，保留 `traceId`。
- 明确可重试边界与上限；失败提供“一键重试”与“复制错误信息”。

## 常见坑
- 只用百分比无阶段信息，用户感知差；重试风暴；前端重复提交多任务；前后台无差异导致资源浪费。

## 总结
- 稳定的进度与重试体系 = 阶段化 + 幂等 + 退避 + 前后台策略 + 用户可达与日志，持续以数据校准与优化。

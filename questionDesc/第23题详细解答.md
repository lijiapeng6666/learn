# 第23题详细解答：订阅逻辑设计（状态与权限）

> 题干：订阅功能的状态管理和权限控制是如何实现的？（考察点：权限系统、订阅模式、支付平台差异）

## 面试者视角（怎么答）

### 1) 模型
- `Entitlement{productId,tier,features[],expireAt,autoRenew,isTrial}`；`Subscription{platform,txId,status,renewAt}`。
- 来源：服务端鉴权接口返回用户的有效 Entitlement 列表；前端仅缓存并定期刷新。

### 2) 权限与门控
- `useEntitlement` Hook：提供 `has(feature)`/`require(feature)`；界面门控（灰置/引导升级）与接口门控（后端二次校验）。
- 试用/促销：识别 `isTrial` 与剩余期；到期前提醒续费。

### 3) 平台差异
- Web（Stripe/自建）、iOS/Android（IAP）：前端仅发起支付，凭证发到后端校验并下发新版 Entitlement。
- 恢复购买：多设备登录时刷新；IAP 恢复流程（Restore Purchases）。

### 4) 刷新与一致性
- 定时刷新（如 15 分钟）或事件驱动（支付完成回调）；强制刷新按钮；缓存过期策略。
- 异常：本地显示有权限但后端判定无 → 以服务端为准并引导处理。

### 5) 小结（30s）
- “前端以 Entitlement 为核心做权限门控，状态来自服务端；支付完成后刷新权限；多平台差异由后端收敛，前端只做引导与展示。”

---

## 面试官视角（怎么问、看什么）

### 可追问清单（附考点）
- 权限与特性映射？
  - 考点：feature 列表与页面/接口门控、灰度能力。
- IAP 与 Web 的一致性？
  - 考点：后端凭证校验、对账、时差与回退。
- 刷新与缓存？
  - 考点：过期策略、强制刷新、离线处理。
- 试用与退款？
  - 考点：权益回收、提示与处理路径。

### 评估要点
- 是否服务端权威；是否有门控 Hook；是否处理平台差异与刷新路径。

### 红旗信号
- 前端本地算权限；无后端校验；支付完成不同步。

---

## 代码与配置片段
```ts
// useEntitlement（简化）
const entitlements = ref<{ features: string[]; expireAt: number }|null>(null)
export async function refreshEntitlements(){ const r = await fetch('/api/entitlements'); entitlements.value = await r.json() }
export function has(feature: string){ return !!entitlements.value?.features.includes(feature) }
```

---

## 实战建议
- 权限与界面门控标准化；所有接口也做后端门控；IAP 流程明确错误与恢复路径。

## 常见坑
- 本地缓存长期不刷新；多平台权益不一致；退款/到期未及时回收。

## 总结
- 订阅设计重心在“服务端统一权益、前端轻门控 + 刷新闭环、平台差异后端收敛”。

# 第10题详细解答：任务轮询设计（AI 生成任务）

> 题干：AI 内容生成的任务轮询机制是如何设计的？如何优化轮询性能？（考察点：异步任务、网络效率、稳定性与用户体验）

## 面试者视角（怎么答）

### 1) 模型与状态机
- 任务状态：`PENDING` → `QUEUED` → `RUNNING` → `SUCCEEDED`/`FAILED`/`CANCELED`；中间态可带 `progress`。
- 任务中心：Pinia 管理任务列表与索引，页面/模块共享；MPA 下通过持久化 + BroadcastChannel 同步（可选）。

### 2) 轮询策略
- 指数退避 + 抖动：初始 1s，乘 1.5–2.0，最大 10–30s；随机抖动避免拥挤。
- 活跃优先：前景页/活跃 tab 正常轮询；后台页延长间隔或暂停；用户可强制刷新。
- 状态驱动：`RUNNING`/`QUEUED` 正常轮询；`SUCCEEDED`/`FAILED` 停止；批量请求合并。
- 去重与合并：多个观察者监听同一 `taskId` 时复用同一轮询器；跨页共享状态。
- 事件优先：服务端支持时优先 SSE/WebSocket 推送，轮询仅兜底。

### 3) 网络与稳健性
- 错误分类：网络/超时/5xx 重试，4xx 不重试（需用户动作）；对 `429` 使用排队或退避。
- 超时与取消：`AbortController` 支持取消；超时时间随间隔适度放大。
- 合并请求：将多个 `taskId` 拼接一次查询，降低请求数；或用队列批量化。
- 版本一致性：HTML/JS 版本切换导致的接口不兼容，检测并提示刷新。

### 4) 体验与可见性
- Toast/进度：在任务卡片/列表显示状态与剩余估时；失败提供重试入口。
- 断网与离线：离线停止轮询并提示；恢复后快速补拉（短间隔几次）。
- 提醒：完成时可选通知/声音；移动端退后台停止或降频，回前台立刻补拉。

### 5) 小结（30s）
- “任务中心以状态机建模，SSE 优先、轮询兜底；轮询采用指数退避 + 抖动 + 批量查询，前后台区分节流；错误分类与取消均有兜底，跨页共享状态避免重复拉取，用户侧有进度与重试体验。”

---

## 面试官视角（怎么问、看什么）

### 可追问清单（附考点）
- 为什么轮询而非长连接？
  - 考点：后端能力/成本、SSE/WSS 可用性、断开/代理环境、降级策略。
- 退避参数如何选择？
  - 考点：初始/因子/上限、抖动算法、任务耗时分布、成本约束与用户体验平衡。
- 批量化与去重如何做？
  - 考点：合并查询、任务中心复用、跨页共享、缓存与 TTL、强一致字段刷新频率。
- 错误与 429 如何处理？
  - 考点：指数退避、排队、用户级限流提示、幂等重试、取消与清理。
- 前后台/可见性策略？
  - 考点：`visibilitychange`、后台延迟、恢复补拉、移动端省电模式。
- 完成与失败的用户反馈？
  - 考点：通知/弹窗/声音、重试/复制日志、失败分类（可重试/不可重试）。

### 评估要点
- 是否有状态机与轮询参数依据；是否有批量化/去重；是否考虑 429 与离线；是否有用户体验与回归机制。

### 红旗信号
- 固定间隔暴力轮询；多个视图重复拉取；未处理 429/离线；不可取消；无用户反馈。

---

## 代码与配置片段
```ts
// 轮询器（去重 + 指数退避 + 抖动 + 可取消）
export type TaskStatus = 'PENDING'|'QUEUED'|'RUNNING'|'SUCCEEDED'|'FAILED'|'CANCELED'
export interface Task { id: string; status: TaskStatus; progress?: number; updatedAt?: number }

const pollers = new Map<string, { stop: () => void }>()

export function observeTask(taskId: string, fetcher: (ids: string[])=>Promise<Task[]>, onUpdate:(t:Task)=>void) {
  if (pollers.has(taskId)) return pollers.get(taskId)!
  let active = true
  let interval = 1000
  const maxInterval = 15000
  const signal = new AbortController()

  async function loop(){
    while(active){
      try{
        const [task] = await fetcher([taskId])
        if(task){
          onUpdate(task)
          if(task.status === 'SUCCEEDED' || task.status === 'FAILED' || task.status === 'CANCELED') break
        }
        // 退避 + 抖动
        interval = Math.min(maxInterval, Math.floor(interval * 1.6))
        const jitter = Math.random() * (interval * 0.2)
        await new Promise(r => setTimeout(r, interval + jitter))
      }catch(e:any){
        // 简化：错误退避
        interval = Math.min(maxInterval, Math.floor(interval * 1.8))
        await new Promise(r => setTimeout(r, interval))
      }
    }
  }

  loop()
  const stop = () => { active = false; signal.abort(); pollers.delete(taskId) }
  const handleVis = () => { if(document.hidden) interval = Math.max(interval, 5000) }
  document.addEventListener('visibilitychange', handleVis)
  pollers.set(taskId, { stop })
  return { stop }
}
```
```ts
// 批量查询器（将多个观测合并一次请求）
class BatchFetcher {
  private pending = new Set<string>()
  private timer: any
  constructor(private fetcher: (ids:string[])=>Promise<Task[]>) {}
  schedule(id: string){
    this.pending.add(id)
    clearTimeout(this.timer)
    this.timer = setTimeout(async ()=>{
      const ids = Array.from(this.pending)
      this.pending.clear()
      await this.fetcher(ids)
    }, 50)
  }
}
```

---

## 实战建议
- 能用推送就用推送（SSE/WebSocket），轮询只做兜底；将轮询集中到任务中心，避免多处重复。
- 设定退避参数与上限；统一错误分类与 429 策略；可取消与离开页面清理。
- 批量化/去重 + 前后台区分；完成提醒与失败重试可达。

## 常见坑
- 固定 1s 轮询 + 每视图一份，触发“羊群效应”；忽视 429；离开页面不清理导致内存泄漏。

## 总结
- 轮询不是目的而是兜底：用状态机 + 批量化 + 退避抖动 + 前后台区分 + 取消/清理，配合推送能力，才能兼顾稳定、成本与体验。

# 第22题详细解答：积分体系实现（前端视角）

> 题干：前端积分体系的实现细节是什么？如何防止积分被篡改？（考察点：安全边界、前后端协作、幂等与一致性）

## 面试者视角（怎么答）

### 1) 模型与边界
- 积分不可被前端信任：前端只读展示与交互，写入/结算在服务端；本地仅做临时缓存与乐观 UI。
- 实体：`PointBalance{userId,balance,tier,updatedAt}`、`PointEvent{id,type,delta,traceId,ts}`。

### 2) 交互与一致性
- 事件上报：前端触发事件（观看/上传/订阅）→ 上报服务端生成 `PointEvent` 并返回新余额。
- 乐观更新：UI 先+N，失败回滚；对关键事件（付费）不乐观更新。
- 幂等：携带 `idempotencyKey` 与 `traceId`，防重复上报；服务端返回最终一致余额。

### 3) 防篡改与安全
- 不在前端保存可用余额的权威数据；本地缓存只做展示；关键操作校验登录态与风险控制。
- 接口签名与重放防护（后端）；前端仅保证 HTTPS 与正确来源。

### 4) 可视化与规则
- 显示余额、等级（tier）与下一等级所需；事件时间线；异常状态提示（风控/冻结）。

### 5) 小结（30s）
- “前端把积分当只读视图与事件入口，所有结算在后端；前端做乐观 UI 与幂等上报，并展示余额、等级与事件日志，避免任何可篡改来源。”

---

## 面试官视角（怎么问、看什么）

### 可追问清单（附考点）
- 幂等与重试？
  - 考点：idempotencyKey、退避与上限、最终一致提示。
- 风险控制？
  - 考点：设备/频率限制、IP 限制、可疑行为校验、黑名单；前端提示与兜底。
- 本地缓存与回退？
  - 考点：显示缓存 vs 权威源、离线状态、回退到上次已知余额。

### 评估要点
- 是否明确边界；是否考虑幂等/重试；是否有用户体验与异常处理。

### 红旗信号
- 前端修改余额；本地为准；无幂等与日志。

---

## 代码与配置片段
```ts
// 乐观更新（简化）
const bal = ref(0)
async function addPoints(delta:number){
  const old = bal.value
  bal.value += delta
  try {
    const res = await fetch('/api/points/add', { method:'POST', body: JSON.stringify({ delta, key }) })
    const data = await res.json(); bal.value = data.balance
  } catch(e){ bal.value = old; throw e }
}
```

---

## 实战建议
- 所有变更必须回写服务端并记录事件；前端仅做乐观反馈；重要事件不乐观。
- 建立余额与事件的“对账视图”；异常时用户可自助查看与申诉。

## 常见坑
- 前端长期缓存余额不刷新；重复上报导致多计；无幂等导致重放。

## 总结
- 积分体系要坚持“服务端权威、前端只读、幂等上报、乐观体验”，保证安全与一致。

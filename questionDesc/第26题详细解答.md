# 第26题详细解答：按需加载实现（避免过度预取）

> 题干：按需加载的具体实现方案是什么？如何避免过度预取？（考察点：懒加载、资源优化、策略权衡）

## 面试者视角（怎么答）

### 1) 路由/组件按需
- 路由：`import()` 懒加载，骨架屏兜底；热门路由 hover/idle 预取。
- 组件：重型组件用 `defineAsyncComponent`；加载失败重试与回退。

### 2) 资源按需
- 图片：`loading="lazy"` + `srcset/sizes`；首屏关键图 `fetchpriority=high`，非关键延后。
- 字体/CSS：关键字体 `preload`，其余按需；CSS code split；大型第三方样式延后插入。

### 3) 预取策略
- 条件预取：仅对高命中行为（hover/视口邻近）预取；弱网/省电模式禁用预取。
- 带宽保护：预取优先级低；并发限制；首屏阶段禁止预取。

### 4) 小结（30s）
- “按需加载从路由/组件到资源分层实现，预取基于行为与设备条件，弱网禁用/限流，避免挤占首屏。”

---

## 面试官视角（怎么问、看什么）

### 可追问清单（附考点）
- 预取触发条件？
  - 考点：hover/idle/邻近、弱网/设备自动禁用、优先级。
- 失败与回退？
  - 考点：ChunkLoadError 重试、回滚到稳定版本。
- 指标验证？
  - 考点：预取命中率、首屏带宽占用、路由切换耗时。

### 评估要点
- 是否条件化预取；是否有带宽保护与失败兜底；是否用指标验证。

### 红旗信号
- 全站预取；弱网仍大量预取；失败不回退。

---

## 代码与配置片段
```ts
// 条件预取（示意）
const canPrefetch = () => navigator.connection ? (navigator.connection as any).effectiveType !== '2g' : true
link.addEventListener('mouseenter', () => { if(canPrefetch()) import('./nextPage') })
```

---

## 实战建议
- 维护“热门路由列表”与预取白名单；弱网禁用；监控预取命中与失败。

## 常见坑
- 预取过度导致首屏抖动；错误重复；未考虑设备差异。

## 总结
- 按需加载的关键是“正确边界 + 条件预取 + 指标兜底”。

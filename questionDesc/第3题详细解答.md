# 第3题详细解答：Vue 2.7 + TypeScript

> 题干：为什么选择 Vue 2.7 而不是 Vue 3？在 Vue 2.7 中使用 TypeScript 遇到了哪些挑战？（考察点：技术选型、迁移取舍、类型系统实践）

## 面试者视角（怎么答）

### 1) 为什么选 Vue 2.7（而非直接上 Vue 3）
- 迁移成本可控：现有 2.x 生态与业务量大，短期全面迁移会挤占迭代节奏；2.7 原生内置 Composition API 与 `<script setup>`，可先“拿到 80% 的收益”。
- 依赖与插件成熟度：历史依赖（移动端组件库、播放器、老插件）对 3.x 兼容性不一；2.7 兼容面更广，减少“适配坑洞”。
- 团队学习曲线：在 2.x 语境下逐步引入 Composition API/Pinia/按需路由，更平滑。
- 过渡策略：以 2.7 为桥，先完成代码风格与工程设施升级（TS、Pinia、Vite/webpack 升级），为未来迁 3 做铺垫。

### 2) 在 Vue 2.7 使用 TypeScript 的实践
- `<script setup lang="ts">`：直接使用 `defineProps/defineEmits/defineExpose` 获取较好类型推断。
  ```vue
  <script setup lang="ts">
  interface Props { id: string; lazy?: boolean }
  const props = defineProps<Props>()
  const emit = defineEmits<{ (e:'loaded', id:string): void }>()
  
  const el = ref<HTMLDivElement|null>(null)
  onMounted(() => emit('loaded', props.id))
  </script>
  ```
- Pinia 2 + 2.7：在 2.7 下可直接使用 Pinia，配合 `storeToRefs` 与返回类型推断。
  ```ts
  // stores/session.ts
  export const useSessionStore = defineStore('session', () => {
    const token = ref<string|undefined>()
    function setToken(t?: string) { token.value = t }
    return { token, setToken }
  })
  ```
- 组件对外类型：通过 `defineExpose`/`InstanceType<typeof Comp>` 标注模板 ref。
- 工具链：`vue-tsc --noEmit` 做类型检查；Volar for Vue 2（启用 Take Over Mode）；必要时 `shims-vue.d.ts` 兜底。

### 3) 主要挑战与对应方案
- 类型覆盖不如 Vue 3 彻底：
  - 问题：Options API 下 `this` 类型复杂；部分指令/插件声明较弱。
  - 方案：新代码优先 `<script setup>` + Composition API；对旧组件增加 `defineComponent` 与显式 props/emits 类型，减少 `this` 依赖。
- 宏与宏类型：
  - 问题：宏（`defineProps/Emits`）是编译期特性，复杂泛型/默认值推断有边界。
  - 方案：为复杂 props 单独定义接口 + 显式默认值函数；事件签名用重载或字面量 `as const`。
- 模板 ref 与子组件实例类型：
  - 问题：`$refs` 在 2.x 中为宽泛 `any`。
  - 方案：避免 `$refs`，改用 `<script setup>` 的 `ref` + `defineExpose`，或 `ref<InstanceType<typeof Child>|null>()`。
- 第三方库类型与按需引入：
  - 问题：老库没有声明文件或 CJS-only，影响 treeshaking 与类型。
  - 方案：优先 ESM 版本/社区类型；用 `declare module` 临时兜底；通过 `vite/rollup alias` 去重单库多版本。
- JSX/TSX 与渲染函数：
  - 问题：2.7 的 TSX 需要 `@vue/babel-preset-jsx`（或 vue2-jsx），类型体验不如 3。
  - 方案：减少 TSX 使用，模板优先；必须使用时收敛在少数基础组件。

### 4) 与 Vue 3 的差异与取舍
- 少部分运行时能力缺失：Teleport、Suspense、并发相关优化等（2.7 无）。
- TS 体验：3.x 采用 TS 重写，类型边界更清晰；2.7 仍存在 Options 遗留类型断层。
- 性能：3.x 的编译/运行优化（hoist/static patch）更好；2.7 通过工程优化（代码分割、懒加载、按需）弥补。

### 5) 小结（30s）
- “我们选择 2.7 是出于风险与迭代节奏的平衡：拿到 Composition API 与 `<script setup>` 的开发与类型收益，同时规避 3.x 的迁移成本。类型上的短板主要在 Options 遗留、宏推断边界和第三方声明，我们通过 `<script setup>` 优先、Pinia、`vue-tsc`、显式接口与别名去重来解决，并为未来迁 3 做好了工程与风格铺垫。”

---

## 面试官视角（怎么问、看什么）

### 可追问清单（附考点）
- 为什么不直接迁 Vue 3？
  - 考点：依赖兼容性评估、排期与风险控制、对业务节奏的影响、灰度/双版本策略。
- 2.7 带来的开发能力有哪些？
  - 考点：Composition API、`<script setup>`、Pinia/按需路由、类型改进的实际收益与样例。
- 类型检查如何落地？
  - 考点：`vue-tsc` 集成、CI 守门/门禁阈值、lint 规则与 VSCode Volar 配置。
- Options 遗留如何治理？
  - 考点：新增组件一律走 `<script setup>`；旧组件改造优先级、风险点与回归策略。
- 第三方类型与 ESM 化怎么做？
  - 考点：alias 去重、`sideEffects` 标注、`declare module` 临时兜底、依赖库替换/按需加载。
- 事件与 props 的类型表达边界？
  - 考点：emits 重载、字面量收窄、复杂 props 的默认值类型推断方式。
- 模板 ref/组件实例类型如何保证？
  - 考点：`defineExpose`、`InstanceType` 与 DOM/组件 ref 的联合类型。
- 构建与工具链升级了什么？
  - 考点：Vite/webpack 版本、`rollupOptions/splitChunks`、`unplugin-*`、`esbuild` 相关。
- 未来迁 Vue 3 的路径？
  - 考点：不使用废弃 API、兼容层/适配器、依赖替换清单、可验证迁移里程碑。
- 性能与监控如何验证收益？
  - 考点：LCP/TTI/INP、包体预算、路由首跳耗时、错误率（宏/懒加载失败）。

---

## 代码与配置片段
```ts
// vue-tsc 脚本（package.json）
{
  "scripts": {
    "type-check": "vue-tsc --noEmit"
  }
}

// 典型组件（<script setup>）
// Component.vue
<script setup lang="ts">
interface Props { title: string; count?: number }
const props = defineProps<Props>()
const emit = defineEmits<{ (e:'inc'): void }>()

const n = ref(props.count ?? 0)
function inc(){ n.value++; emit('inc') }
</script>

// Pinia 示例
// stores/user.ts
export const useUserStore = defineStore('user', () => {
  const id = ref<string>('')
  const name = ref<string>('')
  return { id, name }
})
```

---

## 实战建议
- 强制新组件采用 `<script setup lang="ts">`；为复杂 props/emit 定义接口与类型别名。
- 在 CI 跑 `vue-tsc` 与体积预算；引入 `bundle analyzer`，避免无意引入 CJS 大包。
- 依赖收敛：对大库做按需与替代清单，统一别名与版本；禁止多版本共存。
- 编写“迁 3 指南”：罗列不兼容 API、替代方案与依赖适配状态。

## 常见坑
- 在 2.7 里继续依赖 `$refs`/`this`，导致类型缺失与隐式依赖；应改为组合式写法。
- 事件签名不收敛，`emit` 被当成 `any`；需显式声明。
- 引入老库 CJS 版本，导致 treeshaking 失败与体积飙升。
- TS 配置杂糅（`skipLibCheck` 滥用、`types` 污染），导致误报或漏报。

## 总结
- 2.7 是务实的“桥接”选择：获得组合式与类型收益，兼顾稳定与节奏；挑战集中在 Options 遗留、宏推断与三方类型，我们通过工程化手段、编码规范与类型守门来应对，并持续为迁 3 做准备。

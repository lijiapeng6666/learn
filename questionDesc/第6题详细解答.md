# 第6题详细解答：性能优化策略（首屏时间下降 40%）

> 题干：你提到首屏时间下降 40%，具体采用了哪些优化手段？（考察点：性能优化实战、指标治理、工程落地）

## 面试者视角（怎么答）

### 1) 先测量后优化（度量与目标）
- 指标口径：以 RUM 为准，核心看 LCP、TTI/INP、CLS；次指标：首包时间（TTFB）、JS 下载/解析/执行、资源请求数。
- 切片维度：首访/回访、国家/网络类型/设备档次；分别设置目标（如移动弱网 LCP p75 < 2.5s）。
- 守门机制：体积预算（各路由 gzip < 150KB）、慢查询报警（LCP/INP）与构建物可视化（bundle analyzer）。

### 2) 关键优化项（按收益排序）
- 代码分割与懒加载：路由级 `import()` + 重型组件二次切分，固定 vendor 分组，减少首屏 JS；热门路由 hover/idle 预取。
- 关键路径瘦身：
  - CSS：提取关键 CSS（Critical CSS）内联；开启 `cssCodeSplit`；移除未使用样式。
  - JS：Tree-shaking、移除 polyfill 与调试依赖，优先 ESM；减少全局单例与重计算。
- 资源优化：
  - 图片：使用 webp/avif、`srcset/sizes` 响应式与懒加载、占位（LQIP/BlurHash）。
  - 字体：子集化/可变字体、`font-display: swap`、仅预加载当前脚本字体。
- 连接优化：为静态域名 `preconnect`，对关键资源 `preload`，合并/重排请求优先级（priority hints）。
- 缓存策略：内容哈希 + 长缓存、HTML 短缓存；SW 预缓存路由壳，离线命中与版本回退。
- 首屏体验：骨架屏 + 渐进数据（SWR），避免白屏；首屏数据接口合并与压缩。
- SSR/预渲染（若可行）：对营销/静态路由做 SSG/预渲染，减少首屏 JS 参与度；或 SSR 流式输出。

### 3) 验证与对比（案例化表达）
- 前后对比样例（示意）：
  - LCP p75：2.9s → 1.7s（-41%）
  - 首屏 JS：310KB → 160KB（-48%）
  - 请求数：42 → 26（-38%）
- 关键贡献拆解：分割/懒加载（-20%）、图片与字体（-12%）、连接与缓存（-6%）、SSR/预渲染（-3%）。

### 4) 小结（30s）
- “我们以 RUM 的 LCP/INP 为目标，建立体积预算与报告。通过路由/组件分割、关键 CSS/JS 瘦身、图片/字体优化、preconnect/preload、SW 缓存与骨架屏，首屏 JS 与请求数显著下降；对静态页做了预渲染，最终 LCP p75 下降约 40%。”

---

## 面试官视角（怎么问、看什么）

### 可追问清单（附考点）
- 指标如何采集与口径？
  - 考点：RUM vs 实验室、p75 口径、设备/网络切片、SDK 注入与采样率、异常值处理。
- 体积如何守门？
  - 考点：CI 阈值、bundle analyzer、manualChunks/splitChunks、重复依赖去重、CJS→ESM。
- 懒加载策略与预取时机？
  - 考点：首屏与次屏边界、hover/idle 预取、弱网节流、错误兜底（ChunkLoadError 重试）。
- 关键路径资源治理？
  - 考点：Critical CSS、`preload`/`fetchpriority`、字体 `swap`、首屏 API 合并。
- 图片/字体策略？
  - 考点：webp/avif、srcset/sizes、占位图、字体子集化与回退链、FOUT/FOIT 处理。
- 缓存与 SW？
  - 考点：哈希与缓存层级、SW 预缓存、版本回退、离线命中、回源策略。
- SSR/SSG 如何接入？
  - 考点：渲染路径、hydration 体积、流式输出与时序、SEO 与路由策略。
- 监控与回归？
  - 考点：指标回归检测、A/B 与灰度、用户分层影响评估、告警与演练。

### 评估要点
- 优化前后有对照与拆解；方案覆盖网络/资源/执行/渲染全链路；有守门与回归机制。

### 红旗信号
- 只谈压缩与 CDN，缺少分割/懒加载/关键路径管理；无指标与回归。

---

## 代码与配置片段
```html
<!-- 连接与关键资源 -->
<link rel="preconnect" href="https://static.example.com" crossorigin>
<link rel="preload" as="style" href="/css/critical.css">
<link rel="preload" as="image" href="/img/hero@2x.avif" imagesrcset="/img/hero.avif 1x, /img/hero@2x.avif 2x" fetchpriority="high">
```
```ts
// 路由与组件懒加载（Vue Router）
const routes = [
  { path: '/', component: () => import('@/pages/homePage/App.vue') },
  { path: '/characters', component: () => import('@/pages/characters/App.vue') },
]

// 预取热门路由
const preloadCharacters = () => import('@/pages/characters/App.vue')
link?.addEventListener('mouseenter', preloadCharacters)
```
```ts
// Vite 拆包（vite.config.ts）
export default {
  build: {
    cssCodeSplit: true,
    rollupOptions: {
      output: {
        manualChunks(id) {
          if (id.includes('node_modules')) {
            if (id.includes('vue')) return 'vue'
            if (id.includes('wavesurfer')) return 'player'
            return 'vendor'
          }
        }
      }
    }
  }
}
```
```css
/* 图片懒加载占位 */
.img { background:#f2f3f5; }
```
```ts
// SW（示意）
self.addEventListener('install', (e) => {
  e.waitUntil(caches.open('app-shell').then(c => c.addAll(['/','/css/critical.css'])))
})
```

---

## 实战建议
- 给每个路由设“包预算”，与 RUM 指标挂钩；每次构建生成对比报告并入库。
- 建立“关键资源清单”（字体/首图/首屏样式），统一管理 `preload` 与缓存策略。
- 为懒加载失败写重试/回退逻辑；弱网禁用预取或降低优先级。

## 常见坑
- 预取滥用导致首屏带宽被挤占；CJS 依赖导致无法摇树；字体未子集化导致 FOUT/FOIT 明显。

## 总结
- 以数据驱动的全链路治理：分割与懒加载 + 关键路径瘦身 + 资源与连接优化 + 缓存与骨架屏，并用守门与回归保证持续性，才能稳定达成“首屏 40%”的量化目标。

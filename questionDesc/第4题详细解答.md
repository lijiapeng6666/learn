# 第4题详细解答：状态管理方案（多页面架构下的 Pinia 与跨页面共享）

> 题干：在多页面架构下，Pinia 的状态是如何管理的？页面间数据如何共享？（考察点：状态分层、持久化/一致性、跨页通信、工程治理）

## 面试者视角（怎么答）

### 1) 架构思路（MPA × Pinia）
- 每个页面入口（entry）各自创建 Vue 应用与 Pinia 实例，做到“页面级隔离”，避免全局单例污染与内存泄漏。
- 状态分层：
  - Core 层（跨页共享）：会话/账号/订阅/语言/主题等，持久化到本地（localStorage/IndexedDB），通过命名空间 + 版本化管理。
  - Feature 层（页面内）：与页面强耦合的 UI/编辑状态仅驻留当前页面（不持久化或短期缓存）。
- 跨页共享：通过“持久化 + 同步广播”实现：
  - 持久化（必选）：Pinia 插件将 Core store 的部分字段落盘（支持 TTL/白名单/序列化）。
  - 同步（可选）：`BroadcastChannel`/`storage` 事件在多标签页/多入口间同步快照；PWA 可通过 Service Worker 中转。

### 2) 持久化与版本化
- 命名空间：`{app}:{version}:{store}:{field}`，避免不同版本互相污染；灰度发布期间兼容旧 Key。
- 版本升级策略：语义化 `schemaVersion`，在插件内做迁移（migrate）或清理（invalidate）。
- 选择存储：
  - 轻量/小字段：`localStorage` + throttle。
  - 大对象/列表：`IndexedDB`（通过 `idb-keyval`）。
- 安全与隐私：敏感字段（token）加前端加密无实际安全价值，应更偏向短期存储 + HttpOnly Cookie/后端会话；至少做域隔离与最小化存储。

### 3) 跨页同步
- `BroadcastChannel('app-core')` 广播变更；不支持时回退到 `window.addEventListener('storage')`。
- 冲突解决：采用“最新写入 wins + 版本号/时间戳”策略；对重要字段（余额/订阅）以服务端为准并定期校准。
- 性能：对频繁变化字段节流/合并（如 300ms），避免抖动与环回风暴。

### 4) 初始化与水合（Hydration）
- 启动顺序：创建 Pinia -> 安装持久化/同步插件 -> 读取本地快照并水合 -> 渲染应用 -> 后台拉新（SWR）。
- SWR（stale-while-revalidate）：页面先用本地快照渲染，后台拉取远端并写回，触发最小重绘。

### 5) 与 SPA 的差异
- SPA：天然单运行时，store 常驻内存，跨路由共享简单。
- MPA：每页独立运行时，需要“持久化 + 同步”层来达成共享；好处是页面隔离更好，坏处是复杂度与一致性成本上升。

### 6) 小结（30s）
- “我们将 Pinia 拆成 Core/Feature 两层，Core 通过插件做持久化（TTL/版本化/字段白名单）并用 BroadcastChannel 同步到各入口；页面启动先水合本地快照，再 SWR 拉远端校准。这样既保证跨页数据一致，也保留了 MPA 的隔离与稳态。”

---

## 面试官视角（怎么问、看什么）

### 可追问清单（附考点）
- 为什么选 Pinia 而不是 Vuex？
  - 考点：类型推断/组合式契合度、开发体验、插件生态、体积差异、与 2.7 兼容性。
- Store 如何分层与命名？
  - 考点：Core/Feature 边界、命名空间、循环依赖与共享模块抽取、目录与所有权。
- 持久化策略？
  - 考点：字段白/黑名单、TTL、schemaVersion、序列化器、敏感字段策略、IndexedDB 选型与落盘时机。
- 同步与一致性如何保障？
  - 考点：BroadcastChannel/storage 事件、去抖/节流、防环回、版本冲突解决、最终一致性与服务端权威源。
- 启动顺序与水合？
  - 考点：插件安装顺序、首屏时间影响、SWR、离线与失败兜底、灰度期间的兼容。
- 多标签页/多入口并发写入？
  - 考点：锁与事务（IDB 事务/简单互斥）、时间戳/向量时钟的必要性与代价、关键字段的幂等设计。
- 监控与回归？
  - 考点：状态漂移/丢失报警、广播失败率、持久化失败（容量/权限）统计、用户影响半径评估。
- 安全与隐私边界？
  - 考点：最小存储、加密误区、权限隔离、清退与登出流程的一致性。
- 与服务端契约？
  - 考点：缓存层角色、版本协商、离线与重试策略、批量同步与节流。
- 在 MPA 下的 DX 与性能？
  - 考点：模板/脚手架复用、插件复用、体积与首屏影响评估、可观测性接入。

---

## 代码与配置片段
```ts
// store/install.ts —— 每个入口安装同一套 Pinia 与插件
import { createPinia, PiniaPluginContext } from 'pinia'

type PersistOpt = { include?: string[]; ttlMs?: number; ns: string }
function persistPlugin(opt: PersistOpt) {
  return (ctx: PiniaPluginContext) => {
    const { store } = ctx
    const include = new Set(opt.include ?? [])
    const key = (field: string) => `${opt.ns}:${store.$id}:${field}`

    // 水合
    for (const f of include) {
      const raw = localStorage.getItem(key(f))
      if (raw) {
        try { (store as any)[f] = JSON.parse(raw).v } catch {}
      }
    }

    // 订阅持久化（节流）
    let timer: any
    store.$subscribe((_mutation, state) => {
      clearTimeout(timer)
      timer = setTimeout(() => {
        const now = Date.now()
        for (const f of include) {
          const v = (state as any)[f]
          localStorage.setItem(key(f), JSON.stringify({ v, t: now }))
        }
      }, 200)
    })
  }
}

export function installStore(app: import('vue').App, ns: string) {
  const pinia = createPinia()
  pinia.use(persistPlugin({ ns }))
  app.use(pinia)
  return pinia
}

// stores/core/session.ts —— 跨页共享的核心 Store
import { defineStore } from 'pinia'
export const useSessionStore = defineStore('core.session', () => {
  const token = ref<string|undefined>()
  const locale = ref<'en'|'zh'|'ja'>('en')
  function setToken(t?: string){ token.value = t }
  return { token, locale, setToken }
})

// 跨页同步（可选）：BroadcastChannel
const bc = 'BroadcastChannel' in window ? new BroadcastChannel('app-core') : null
watch(() => ({ token: useSessionStore().token, locale: useSessionStore().locale }), (val) => {
  bc?.postMessage({ t: Date.now(), k: 'session', v: val })
}, { deep: true })

bc?.addEventListener('message', (e: MessageEvent) => {
  const s = useSessionStore()
  if (e.data?.k === 'session') {
    const { token, locale } = e.data.v || {}
    if (typeof token !== 'undefined') s.token = token
    if (typeof locale !== 'undefined') s.locale = locale
  }
})
```

---

## 实战建议
- Store 目录按 Core/Feature 分层；Core 开启持久化并设置 TTL/版本；Feature 默认不持久化。
- 关键字段（token、订阅状态）以服务端为权威源，页面启动后做一次校准；本地仅作缓存。
- 广播要做节流与环回保护；对不支持 BroadcastChannel 的环境回退到 `storage` 事件。
- 为持久化写单元测试（序列化/迁移/失效），并在 CI 做“跨版本兼容”回归。
- 定义“状态预算”（避免把大数组/二进制塞进 localStorage），大对象用 IndexedDB。

## 常见坑
- 将所有 Store 都持久化，导致大对象频繁写入、性能抖动与存储爆满。
- 未做版本化与迁移，发布后旧快照污染新版本造成异常。
- 广播环回（A→B→A）导致无限循环；需标记来源或做时间窗抑制。
- 把安全寄托在前端加密上；敏感信息应最小存储并以后端会话为准。

## 总结
- MPA 下用 Pinia 的关键是“分层、持久化、同步、校准”：Core 跨页共享 + Feature 页面内隔离；持久化要做命名空间与版本化；同步用 BroadcastChannel/Storage 事件；最终一致性以服务端为准，通过 SWR 校准，全局体验稳定且可维护。

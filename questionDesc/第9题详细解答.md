# 第9题详细解答：文件上传机制（TTV/ITV 与大文件处理）

> 题干：Text-to-Video/Image-to-Video 的上传流程是怎样的？如何处理大文件上传？（考察点：文件处理、异步与稳健性、用户体验）

## 面试者视角（怎么答）

### 1) 端到端流程（S3/OSS 预签名为例）
1. 创建上传会话：前端上报文件元信息（名称/大小/类型/哈希），后端返回 `uploadId`、建议 `chunkSize`、并下发每片的预签名 URL 或 `complete` 接口。
2. 分片与并发：按 `chunkSize` 切片（如 5–10MB），并发 3–6 路上传；失败重试（指数退避 + 抖动）。
3. 完成与校验：全部分片成功后调用 `complete`；后端合并并校验哈希，返回 `fileId`/`assetUrl`。
4. 业务入库：将 `fileId` 绑定到任务（TTV/ITV），进入后续生成或审核流程。

### 2) 大文件策略
- 断点续传：
  - 本地保持 `uploadId` 与已完成分片索引；刷新后可从断点继续。
  - 失败处理：网络/权限/S3 4xx/5xx 分类；重试上限后回滚并提示。
- 速率与内存：
  - 限制并发与切片大小避免占满带宽与内存；使用 `Blob.slice` 流式读取，避免整文件加载。
  - 背压控制：队列 + 信号量；`AbortController` 支持暂停/取消。
- 完整性：
  - 客户端哈希（WebCrypto/SparkMD5）比对；后端返回 ETag/MD5；必要时范围校验重发。
- 类型与转码：
  - 图片：压缩与 EXIF 清理（质量 0.7–0.85）；视频：仅做容器/编解码校验与时长/分辨率限制，转码交由后端。
- 移动端特殊：
  - iOS 照片 HEIC → 兼容策略（后端/前端转换）；Android 多厂商权限与路径兼容；前后台切换暂停与恢复。

### 3) 用户体验
- 进度与状态：分片完成进度条、速度/剩余时间估算；暂停/继续；失败分片可重试。
- 失败可恢复：刷新后恢复队列；多标签页间广播进度（BroadcastChannel）。
- 限制与提示：尺寸/类型/分辨率/时长约束前置校验；费用/配额提示；蜂窝网络警示。

### 4) 安全与合规
- 直传安全：仅预签名直传存储；跨域 CORS 受控；病毒扫描与内容审核在后端异步进行。
- 隐私：遵循用户同意与删除请求（GDPR）；凭证最小化暴露，有效期短。

### 5) 小结（30s）
- “我们采用预签名直传 + 分片并发 + 断点续传，前端做哈希与速率控制，失败指数退避；完成后 `complete` 合并校验并返回 `fileId`。用户可暂停/续传，异常可恢复；图片压缩与视频校验在端侧，转码在后端。”

---

## 面试官视角（怎么问、看什么）

### 可追问清单（附考点）
- 失败与重试策略？
  - 考点：分类（4xx/5xx/网络）、指数退避 + 抖动、分片级重试、全局终止条件与用户提示。
- 断点续传如何实现？
  - 考点：`uploadId` 与已传分片索引持久化、刷新恢复、哈希校验、会话过期处理。
- 并发与背压？
  - 考点：信号量/队列、`AbortController`、内存与带宽上限、弱网/前后台降级。
- 文件校验与重复上传消除？
  - 考点：客户端预哈希、秒传策略、后端去重、冲突处理。
- 安全与合规？
  - 考点：预签名权限、CORS、病毒/鉴黄/涉政审核、GDPR 删除与数据驻留（区域化存储）。
- 端侧处理与兼容？
  - 考点：图片压缩、EXIF、HEIC、视频元信息读取、iOS/Android WebView 差异。

### 评估要点
- 是否覆盖失败分类与恢复；是否有并发/背压与内存控制；是否有校验与去重；用户体验是否完善。

### 红旗信号
- 单请求直传无分片；无断点续传；无限制重试；无哈希校验与安全策略。

---

## 代码与配置片段
```ts
// 分片上传（示意）
export async function uploadFile(file: File, getPresign: (i:number)=>Promise<string>, opts?: { chunkSize?: number; concurrency?: number; signal?: AbortSignal; onProgress?: (p:number)=>void }) {
  const chunkSize = opts?.chunkSize ?? 5 * 1024 * 1024
  const concurrency = opts?.concurrency ?? 4
  const total = Math.ceil(file.size / chunkSize)
  let uploaded = 0
  const queue: number[] = Array.from({ length: total }, (_, i) => i)
  const workers: Promise<void>[] = []

  async function worker(){
    while(queue.length){
      const i = queue.shift()!
      const start = i * chunkSize
      const end = Math.min(file.size, start + chunkSize)
      const blob = file.slice(start, end)
      const url = await getPresign(i)
      const res = await fetch(url, { method: 'PUT', body: blob, signal: opts?.signal })
      if(!res.ok) throw new Error(`chunk ${i} failed: ${res.status}`)
      uploaded++
      opts?.onProgress?.(uploaded/total)
    }
  }

  for(let k=0;k<concurrency;k++) workers.push(worker())
  await Promise.all(workers)
}
```
```ts
// 断点信息（本地持久化）
interface UploadSession { uploadId: string; fileName: string; size: number; done: number[] }
```

---

## 实战建议
- 选择统一的分片大小与并发，结合 RUM 数据按网络/设备动态调整；失败/取消要有可恢复路径。
- 图片端侧压缩 + 去 EXIF；大视频避免解码与转码占用内存，交由后端处理。
- 预签名有效期短并可刷新；后台对完成但未合并的会话做生命周期清理。

## 常见坑
- 过大并发占满带宽导致其他资源饿死；未处理 iOS 前后台切换；无断点信息导致刷新重来。

## 总结
- 大文件上传的关键在“分片并发 + 断点续传 + 完整性校验 + 体验兜底”，辅以安全与合规策略，才能稳定支撑 TTV/ITV 的多媒体重负载场景。

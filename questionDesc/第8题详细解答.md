# 第8题详细解答：组件库设计（复用、通用性与扩展性）

> 题干：组件库复用是如何实现的？如何保证组件的通用性和扩展性？（考察点：组件设计思维、抽象能力、工程化）

## 面试者视角（怎么答）

### 1) 设计原则与分层
- 分层模型：
  - Base（原子）：无业务语义，仅样式与交互原子，如 `Button`、`Input`、`Modal`、`Icon`。
  - Composite（组合）：通用业务模式，如 `Uploader`、`Form`、`Table`、`VideoPlayer`。
  - Domain（领域）：轻业务胶水层，如 `CreditsBadge`、`SubscriptionGate`，对外仍保留可配置性。
- 约束与契约：以类型定义 props/slots/emits；单向数据流 + 受控/非受控模式并存（如 `value` + `onUpdate:value`）。
- 无渲染（Renderless）与插槽：将逻辑与视图解耦，复杂场景通过 `v-slot` 自定义外观。
- 设计令牌（Design Tokens）：颜色/间距/字号等通过 CSS 变量暴露，支持主题/品牌切换与暗黑模式。

### 2) 工程与性能
- Tree-shaking 友好：ESM 输出、`sideEffects:false`、按需导入、样式与逻辑分发。
- 体积治理：避免引入 CJS 大库；公共依赖外部化或合并；提供 `babel-plugin-import/unplugin` 自动按需。
- 可访问性（a11y）：语义标签、ARIA 属性、键盘可达、焦点管理；国际化文本通过 `i18n` 插槽或 props 提供。
- SSR/CSR 兼容：避免直接访问 `window/document`；将副作用放在挂载阶段；提供 `client-only` 包裹建议。

### 3) 扩展性策略
- Props 扩展模式：保留 `...attrs` 透传、`class`/`style` 合并；复杂可配置项用对象 props（如 `UploaderOptions`）。
- 插槽优先：将可变 UI 暴露为插槽（如空态、占位、动作区），保留默认渲染。
- 事件协议：明确事件语义与负载类型；错误通过 `onError` 与返回值区分可恢复/不可恢复。
- Hook/Composables：将跨组件逻辑（如节流上传、轮询、埋点）抽为可复用 `useXxx`。

### 4) 文档与质量
- Storybook/Docs：为每个组件提供交互文档、可视快照；示例覆盖 props/slots/交互状态。
- 单测与可视回归：行为单测（交互/状态机）+ 视觉回归（关键组件）；快照控制漂移。
- 版本策略：SemVer + 变更日志；破坏性变更有 Codemod 或迁移指南。

### 5) 小结（30s）
- “我们以 Base/Composite/Domain 分层 + Renderless/插槽保障通用性，用设计令牌与类型契约保证一致性；工程上 ESM/按需/a11y/SSR 兼容，配合文档、单测与 SemVer，既复用稳定又便于扩展与品牌化定制。”

---

## 面试官视角（怎么问、看什么）

### 可追问清单（附考点）
- 如何划分通用与业务边界？
  - 考点：分层清晰、抽象最小化、避免“万能组件”、领域胶水层的边界管理。
- 如何支持主题与品牌化？
  - 考点：Design Tokens、CSS 变量、暗黑模式、Token 与组件耦合度、局部主题隔离。
- 可访问性落实程度？
  - 考点：语义/ARIA/键盘导航/焦点陷阱、对话框/抽屉无障碍实践。
- 按需与体积控制？
  - 考点：ESM 输出、`sideEffects`、自动按需、重复依赖去重、bundle 报告。
- 扩展点设计？
  - 考点：插槽 vs props vs renderless、事件协议、错误/空态可定制、`attrs` 透传策略。
- 文档与质量保障？
  - 考点：Storybook、可视回归、覆盖率、破坏性变更的迁移配套。
- API 稳定性与版本策略？
  - 考点：SemVer、弃用期与 Deprecation 提示、Codemod 与迁移指南、变更日志与影响面评估、Feature Flag 灰度发布。
- 发行与构建产物形态？
  - 考点：多格式输出（ESM/CJS/UMD）与 `exports` 字段、`types` 与 `.d.ts` 完整度、`sideEffects` 与按需导入路径稳定性、样式产物（独立 CSS vs 内联）。
- SSR 与水合一致性？
  - 考点：仅客户端副作用隔离（onMounted/if (typeof window)）、水合不匹配定位与回退、稳定 ID/`useId`、`client-only` 包裹建议。
- 可访问性验证与测试？
  - 考点：axe/eslint a11y 规则、键盘导航用例覆盖、焦点陷阱与逃逸（Esc）、可读名称/关系属性、对比度与动态文案。
- 性能预算与基准？
  - 考点：渲染/更新耗时基线、内存与节点数量上限、长列表虚拟化策略、动画/过渡开销、RUM 指标与回归。
- 国际化与 RTL 支持？
  - 考点：默认文案如何接入宿主 i18n、ICU/占位安全、RTL 逻辑属性与图标镜像、文案膨胀 30% 不截断。
- 主题切换与运行时成本？
  - 考点：CSS 变量动态切换无重排、局部/全局主题隔离、暗黑模式策略、主题 Token 的稳定性与覆盖面。
- 扩展机制与 Renderless 复用？
  - 考点：逻辑与视图解耦、插槽渲染边界、受控/非受控切换、组合式 hooks 的 API 稳定与依赖注入。
- 发布与消费兼容性？
  - 考点：Vite/Webpack/Rollup 下的路径与别名、Node/浏览器条件导出、浏览器支持范围与 Polyfill 边界、peerDependencies 管理。
- 样式隔离与覆盖策略？
  - 考点：scoped/BEM/CSS Layers、选择器优先级规范、可覆盖 surface（CSS 变量/类名）、避免全局泄漏与冲突。
- 文档与演示工程？
  - 考点：Storybook/示例即文档、交互态覆盖、可复制的最小用例、错误案例与对比。
### 评估要点
- 分层是否可落地；扩展点是否够用不越权；有无体积与 a11y 证据；文档测试是否完善。

### 红旗信号
- 过度抽象/巨石组件、强耦合样式、不可用插槽、CJS 体积膨胀、无 a11y/文档/测试。

---

## 代码与配置片段
```vue
<!-- BaseButton.vue -->
<template>
  <button
    class="btn"
    :class="[`btn--${variant}`, { 'is-loading': loading }]"
    :disabled="disabled || loading"
    v-bind="$attrs"
    @click="onClick"
  >
    <slot name="icon" />
    <span><slot /></span>
  </button>
</template>
<script setup lang="ts">
interface Props { variant?: 'primary'|'secondary'|'ghost'; disabled?: boolean; loading?: boolean }
const props = withDefaults(defineProps<Props>(), { variant: 'primary', disabled: false, loading: false })
const emit = defineEmits<{ (e:'click', ev: MouseEvent): void }>()
function onClick(ev: MouseEvent){ if(!props.loading && !props.disabled) emit('click', ev) }
</script>
<style scoped>
.btn { --btn-bg: var(--color-primary); padding: 10px 16px; border-radius: 8px; }
.btn--secondary { --btn-bg: var(--color-secondary); }
</style>
```
```ts
// index.ts —— 按需导出，支持 treeshaking
export { default as BaseButton } from './base/BaseButton.vue'
export { default as Uploader } from './composite/Uploader.vue'
```
```ts
// 设计令牌（tokens.css）
:root{ --color-primary:#4f46e5; --color-secondary:#64748b; }
[data-theme="dark"]{ --color-primary:#818cf8; --color-secondary:#94a3b8; }
```

---

## 实战建议
- 建 Storybook + Play 功能页，覆盖场景与边界；接入 `visual regression` 做回归。
- 以 tokens 驱动样式；避免硬编码色值与尺寸；主题切换走 CSS 变量。
- 严格类型与事件约束；文档自动化（示例即文档）。

## 常见坑
- 为“复用”牺牲易用性，导致二次封装泛滥；样式强耦合无法品牌化；CJS 依赖破坏按需与摇树。

## 总结
- 组件库的关键是“合适的分层 + 明确的扩展点 + 工程化治理”，用 tokens/插槽/类型/a11y/ESM 共同保证通用与可扩展。

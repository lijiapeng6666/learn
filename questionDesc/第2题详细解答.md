# 第2题详细解答：代码分割策略

> 题干：页面级代码分割是如何实现的？相比单页应用有什么优势和劣势？（考察点：性能优化、打包策略、SPA vs MPA 理解）

## 面试者视角（怎么答）

### 1) 实现思路（以 Vue + Vite/webpack 为例）
- 路由级懒加载：在路由处切分代码，按需加载页面所需模块，降低首屏 JS 体积。
  ```ts
  // Vue Router
  const routes = [
    { path: '/home', component: () => import('@/pages/homePage/App.vue') },
    { path: '/characters', component: () => import('@/pages/characters/App.vue') },
  ]
  ```
- 组件级懒加载：对较大的非首屏组件做二次切分，配合 Skeleton/Suspense 提升体验。
  ```ts
  import { defineAsyncComponent } from 'vue'
  const HeavyPanel = defineAsyncComponent(() => import('./HeavyPanel.vue'))
  ```
- 公共依赖拆分：将体积大、变化少的依赖拆分为长期缓存的 vendor/chunk；避免重复打进各路由。
  - Vite（Rollup）
    ```ts
    // vite.config.ts
    export default {
      build: {
        rollupOptions: {
          output: {
            manualChunks: {
              vue: ['vue', 'vue-router'],
              player: ['wavesurfer.js'],
            }
          }
        },
        cssCodeSplit: true,
      }
    }
    ```
  - webpack：`splitChunks.cacheGroups` 控制 vendor/common 的拆分归并。
- 资源与样式拆分：开启 `cssCodeSplit`；路由内按需引入局部样式与资源，避免全局注入。
- 预获取与预加载：
  - 进入空闲时机或用户 hover 预拉取下一个可能访问的路由包（`requestIdleCallback`/鼠标悬停触发 `import()`）。
  - 服务端可用 `link rel="prefetch/preload"` 标记，或在 SPA 内动态插入。
- 错误与降级：对 `import()` 失败（离线/缓存损坏）处理重试和回退页面；路由守卫/全局错误拦截统一兜底。
- 量化评估：关注 LCP、TTI、FID、JS 下载/执行时长、路由切换耗时；用 `rollup-plugin-visualizer/webpack-bundle-analyzer` 观察 chunk 图谱。

### 2) 与「不做分割的单页应用（单包 SPA）」对比
- 优势：
  - 首屏更小：只加载首屏必需代码，减少下载与解析执行成本。
  - 缓存更友好：业务路由变更不会频繁使 vendor 失效；长缓存命中率更高。
  - 失败隔离：单个路由包损坏不致整体不可用；回退与重试更精细。
- 劣势：
  - 运行期复杂度增加：需要处理懒加载时序、Skeleton/错误边界、预加载策略。
  - 首次进入某路由会有额外延迟：需要网络请求 + 解析执行该 chunk。
  - 可能的切分过度：大量微小 chunk 导致请求开销与调度复杂（尤其弱网/高 RTT）。

### 3) 与多页面应用（MPA）对比（SPA + 路由分割 vs 传统 MPA）
- SPA + 分割的优势：
  - 导航体验丝滑：前端路由切换，无整页刷新，状态可跨页保留。
  - 资源可共享：vendor 只下载一次，跨路由复用，缓存收益更集中。
  - 交互上限更高：持续连接、背景任务、动画过渡更顺畅。
- SPA + 分割的劣势：
  - 仍需较大的运行时与路由框架；内存常驻更高。
  - SEO/首屏 SSR 要求高，需要 SSR/同构或静态预渲染来弥补。
- MPA 的优势：
  - 天然页面级隔离：每页最小依赖集，渲染由浏览器接管，失败不相互影响。
  - 直出更友好：SSR/静态 HTML 成本低，首屏可非常快，SEO 简单。
- MPA 的劣势：
  - 跳转刷新导致上下文丢失；跨页共享状态与通信复杂。
  - 依赖可能重复下载，难以实现前端层面的细粒度共享缓存。

### 4) 何时选用哪种
- 业务强交互、状态长时保留、页面间强耦合：优先 SPA + 路由级代码分割。
- 信息展示、路由松耦合、SEO 强诉求：优先 MPA 或 SSR/SSG。
- 混合架构：核心流程用 SPA，外围文档/营销页用 MPA/SSG。

### 5) 小结术（30s 版本）
- “我们在路由处用 `import()` 做页面级懒加载，重型组件二次切分，同时通过 `manualChunks/splitChunks` 把稳定依赖拆到 vendor。为避免路由首跳抖动，我们做了 hover/空闲预取，并用 Skeleton 与错误边界兜底。度量上跟踪 LCP/TTI 和路由切换耗时。相较单包 SPA 首屏更小；相较 MPA 导航体验更顺畅，但需要额外运行时与预取策略来平衡体验与体积。”

---

## 面试官视角（怎么问、看什么）

### 可追问清单（附考点）
- 你们按什么维度切分边界？路由、组件、业务域还是数据流？
  - 考点：切分维度选择与边界稳定性（路由/功能域/组件/数据流/资源类型）、解耦与循环依赖处理（import 图断裂策略）、共享依赖归属与去重复（避免跨域重复打包）、可观察性（chunk 依赖图/模块热度）、命名与分组约定（manualChunks/cacheGroups 规则）、对状态管理的影响（store 分片与懒加载恢复）、与目录结构/代码所有权的一致性。
- 如何避免切分过细导致的请求风暴？有没有合并/归并策略？
  - 考点：请求并发与优先级（prefetch/preload/lazy 的带宽竞争）、chunk 尺寸预算（最小/最大包阈值）、构建归并配置（Vite manualChunks 函数/webpack splitChunks.minSize、maxInitialRequests）、动态 import 粒度控制与入口收敛、HTTP/2/3 多路复用下的权衡、冷热路径分级（热门路由预取、冷门保持懒加载）、CSS/字体合并策略、以指标驱动的归并（路由切换耗时/请求数 p75/p95）。
- vendor 拆分的原则是什么？如何保证长期缓存与最小失效面？
  - 考点：稳定依赖与业务代码隔离标准、语义化版本与 lockfile 策略、分组命名与输出稳定性（防哈希漂移）、多版本库去重（alias/dedupe）、ESM 优先与 tree-shaking/sideEffects、超大三方的二次拆分（如 lodash-es/monaco/wavesurfer）、浏览器缓存策略（immutable/etag）、deterministic chunk 与 runtime/manifest 的处理。
- 首次进入非首屏路由的体验如何保障？预取触发时机如何设计？
  - 考点：触发时机（hover/idle/in-viewport/网络状态感知）、preload vs prefetch 的差异与使用边界、预取竞态与取消（AbortController）、弱网/低端设备上的节流与降级、骨架屏/占位/渐进数据加载、本地命中策略（HTTP 缓存/SW 缓存）、带宽不扰动首屏的控制、预取命中率与收益监控。
- 懒加载失败如何处理？是否做了重试、离线策略、fallback？
  - 考点：ChunkLoadError 分类与检测（超时/DNS/SRI）、重试策略（指数退避/版本回退/清缓存提示）、离线与弱网处理（SW、离线页）、全局错误边界与兜底 UI、CDN 与多域回退、source map 与错误上报链路、HTML/JS 版本不一致检测与修复、用户交互（重试按钮/刷新引导）。
- 如何验证分割收益？有哪些指标阈值与看板？
  - 考点：指标体系（LCP/TTI/FID/INP、JS 下载/解析/执行）、路由切换 TTI 与首跳耗时、冷/热启动拆分与对比、A/B 或灰度实验设计、体积分布与模块热度可视化（bundle analyzer）、阈值与预算守门（CI 报警）、端侧维度切片（网络/设备分层）、成本收益分析（请求数/CPU/内存/电量）。
- CSS/字体/图片如何随页面按需加载与缓存？
  - 考点：CSS Code Split 与关键渲染路径优化（Critical CSS）、样式局部化（CSS Modules/Scoped/SFC）、字体子集化与 `font-display`、字体/关键资源 `preload` 与连接优化（preconnect/dns-prefetch）、图片格式与自适应（webp/avif、srcset/sizes、懒加载）、Icon 方案（Iconfont/SVG Sprite）、缓存与失效控制（immutable/etag）、样式副作用与 `sideEffects` 管控、动态主题/按需变量注入。
- 是否遇到 chunk 重复/漂移（哈希频繁变化）的情况，如何定位？
  - 考点：重复模块识别与去重（analyzer 图谱、模块去重策略）、入口与分组稳定化（固定 manualChunks）、小改动引发大面积哈希变化的成因（模块排序/hash seed）、包管理一致性与锁文件策略、动态 import 路径与参数稳定性、提取 runtime/manifest 降低漂移、构建器选项（deterministicIds/minifyInternalExports）、CI 产物 diff 与发布对比。
- SSR/静态化是否参与？流式渲染与分块交付如何配合？
  - 考点：SSR/SSG 与懒加载配合（异步组件收集、Suspense/岛屿架构/部分水合）、水合阶段的 chunk 预加载（modulepreload links）、边缘渲染/流式输出对 LCP 的影响、服务端数据注水 vs 客户端拉取、代码分割对 SSR 路由渲染的影响（按路由收集依赖）、SEO/可爬取性保障、500 兜底与错误传播、双产物一致性验证（server/client）。
- 打包分析中发现的最大“胖包”是什么，如何瘦身？
  - 考点：定位方法（bundle analyzer、导出体积分析/coverage）、替换或拆分重库（按需引入/更轻替代）、本地化与数据字典拆分（locale/schema/词典按需）、动态 import 子功能/子路由、运行时优化（延迟注册、减少全局单例）、代码层优化（dead code/调试依赖清理、sideEffects 标注）、监控复验（瘦身前后体积与性能指标对比）、体积守门（lint/CI budget/失败门槛）。
### 评估要点
- 是否能画出 chunk 依赖图并给出可验证的数据对比。
- 是否理解网络与执行的双重瓶颈（下载 vs 解析/执行）。
- 是否具备实际兜底方案（Skeleton、错误边界、预取策略）。
- 是否考虑缓存与发布（内容哈希、分组拆包、缓存层策略）。

### 红旗信号
- 只谈“用懒加载更快”，缺乏指标与取舍意识。
- 过度依赖预取，忽略弱网和设备性能差异。
- 忽视错误场景（ChunkLoadError）与离线体验。

---

## 面试者如何引导面试官继续深入
- “我们基于 Vite 的 `manualChunks` 做了域内拆分，是否需要我展开 vendor 策略与缓存命中数据？”
- “为降低路由首跳延迟，我们做了 hover/空闲预取和骨架屏，想听听您对预取时机的优化建议吗？”
- “我们遇到过 chunk 漂移问题，后来通过固定入口与分组解决，我可以分享排查过程。”
- “除了路由切分，我们还做了组件级懒加载与动画延迟挂载，是否需要看一下代码片段？”
- “我们对 LCP/TTI 建立了阈值告警和对比实验，是否需要我展示指标截图与实验设计？”

---

## 代码与配置片段
```ts
// 1) 路由级懒加载（Vue Router）
const routes = [
  { path: '/ttv', component: () => import('@/src/pages/aiVideo/components/TextToVideo/index.vue') },
  { path: '/itv', component: () => import('@/src/pages/aiVideo/components/ImageToVideo/index.vue') },
]

// 2) 组件级懒加载（Vue 3）
import { defineAsyncComponent } from 'vue'
export const VideoSwiper = defineAsyncComponent(() => import('@/src/pages/characters/components/VideoSwiper/index.vue'))

// 3) Vite: vendor 拆分与 CSS 拆分
// vite.config.ts
export default {
  build: {
    cssCodeSplit: true,
    rollupOptions: {
      output: {
        manualChunks: (id) => {
          if (id.includes('node_modules')) {
            if (id.includes('vue')) return 'vue'
            if (id.includes('wavesurfer')) return 'player'
            return 'vendor'
          }
        }
      }
    }
  }
}

// 4) 预取示例：用户 hover 提前拉取下个路由包
const preloadCharacters = () => import('@/src/pages/characters/App.vue')

const link = document.querySelector('#to-characters')
link?.addEventListener('mouseenter', () => {
  // 空闲/悬停时预拉取，下次点击瞬开
  preloadCharacters()
})
```

---

## 实战建议清单（落地可执行）
- 为各主路由设定“包预算”（如 < 150 KB gzip），超限自动报警。
- 用 `rollup-plugin-visualizer`/`webpack-bundle-analyzer` 每个版本生成可比报告。
- 对“次热门路由”启用 hover/空闲预取，对“冷门路由”保持按需加载。
- 首屏用 Skeleton/骨架与渐进数据加载，避免白屏与布局抖动。
- 对 `import()` 失败实现指数退避重试 + 退回稳定版本。
- 固定 vendor 分组，避免小改动引发大面积哈希漂移，提升缓存命中。
- 定期扫描重复依赖与相同大库的多版本问题，做别名收敛。

## 常见坑
- 过度切分造成碎片化请求；或公共依赖未抽出导致多路由重复打包。
- 动态 `import()` 变量化带来无法良好切分或失去预编译优化。
- 预取过激在弱网设备上适得其反，挤占首屏带宽。
- CSS 未拆分/全局注入导致首屏样式体积过大。
- 哈希漂移导致缓存失效频繁；需稳定入口与输出分组。

## 总结
- 页面级代码分割的核心是“在正确的边界做切分 + 在正确的时机做加载”。
- 与单包 SPA 相比，首屏更小、缓存更稳，但需要更复杂的懒加载与预取治理；
- 与 MPA 相比，交互更顺滑、资源可共享，但需补齐 SEO/首屏与运行时开销。

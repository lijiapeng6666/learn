# 第13题详细解答：音轨模型设计（统一轨道抽象）

> 题干：统一音轨模型是如何抽象的？支持哪些音频操作？（考察点：数据模型设计、时间线与编辑操作、可扩展性）

## 面试者视角（怎么答）

### 1) 模型抽象（时间线/轨道/片段/自动化）
- 时间线（Timeline）：统一时间基（秒/采样），包含 BPM/节拍/拍点；提供光标/标尺/网格对齐。
- 轨道（Track）：类型 `audio|music|voice|sfx|bus`，包含静音/独奏、音量、声像、效果链（FX）。
- 片段（Clip）：引用资源（`assetId/url`）、起始时间 `start`、入点 `in`、长度 `duration`、淡入淡出、包络。
- 自动化（Automation）：关键帧曲线控制 `gain/pan/filter` 等参数，支持线性/指数/样条插值。

### 2) 操作与约束
- 基础编辑：添加/删除/移动/复制/分割/拼接；对齐网格（quantize）与吸附（snap）。
- 包络与淡变：片段级与轨道级包络；淡入/淡出曲线可选（线性/指数）。
- 混音与总线：轨道路由到 `bus`，bus 上应用全局 FX 与限幅；导出时按路由混合。
- 冲突与重叠：同轨片段不重叠（或以优先级/层级解决）；跨轨混合按路由规则。

### 3) 序列化与持久化
- Schema 版本化：`schemaVersion` + 迁移脚本；资源与时间线分离，引用 `assetId` 以便缓存与去重。
- 快照与撤销：以“命令模式”记录变更，支持多步撤销/重做；快照阈值控制体积。

### 4) 播放与导出
- 播放：按时间线驱动 `AudioBufferSourceNode`/`MediaElement`；遇到片段触发调度；自动化参数在时间轴上调度。
- 导出：`OfflineAudioContext` 逐轨渲染 → bus 混合 → 输出文件（WAV/MP3）；长轨分段渲染合并，降低内存峰值。

### 5) 小结（30s）
- “我们以 时间线-轨道-片段-自动化 的层次抽象，支持分割/拼接/包络/路由与总线混音，序列化版本化并支持快照与撤销；播放调度与离线导出分离，保证编辑流畅与导出可靠。”

---

## 面试官视角（怎么问、看什么）

### 可追问清单（附考点）
- 时间基与对齐？
  - 考点：秒/采样/节拍转换、网格吸附、精度与累积误差。
- 重叠与优先级？
  - 考点：同轨不重叠策略、跨轨混合、淡入淡出交叠处理。
- 自动化曲线？
  - 考点：关键帧数据结构、插值算法、实时调度的性能。
- 撤销与快照？
  - 考点：命令模式、内存控制、跨页面持久化与恢复。
- 导出路径与内存？
  - 考点：离线渲染、分段导出、峰值内存监控、格式选择。

### 评估要点
- 模型是否自洽且可扩展；编辑操作是否完善；播放/导出路径是否清晰；性能与内存考虑是否充分。

### 红旗信号
- 模型混乱、时间基不一致；无撤销/重做；导出走前台实时录制导致质量与稳定性差。

---

## 代码与配置片段
```ts
// 基础类型
export type TimeSec = number
export type TrackType = 'audio'|'music'|'voice'|'sfx'|'bus'
export interface Clip {
  id: string; assetId: string; start: TimeSec; in: TimeSec; duration: TimeSec;
  fadeIn?: { t: TimeSec; curve: 'linear'|'exp' }
  fadeOut?: { t: TimeSec; curve: 'linear'|'exp' }
}
export interface AutomationPoint { t: TimeSec; v: number }
export interface Track {
  id: string; type: TrackType; name: string; mute?: boolean; solo?: boolean;
  gain: number; pan: number; fx?: string[]; clips: Clip[]; automation?: { gain?: AutomationPoint[] }
}
export interface Timeline { bpm?: number; tracks: Track[]; markers?: { t: TimeSec; label: string }[] }
```
```ts
// 操作：分割 clip
export function splitClip(track: Track, clipId: string, t: TimeSec){
  const i = track.clips.findIndex(c=>c.id===clipId); if(i<0) return
  const c = track.clips[i]
  if (t<=c.start || t>=c.start+c.duration) return
  const left: Clip = { ...c, id: c.id+':L', duration: t - c.start }
  const right: Clip = { ...c, id: c.id+':R', in: c.in + (t - c.start), start: t, duration: c.start + c.duration - t }
  track.clips.splice(i,1,left,right)
}
```
```ts
// 自动化插值（线性）
export function interp(points: AutomationPoint[], t: number){
  if(!points.length) return 1
  const i = points.findIndex(p=>p.t>t)
  if(i<=0) return points[0].v
  const a = points[i-1], b = points[i]
  const r = (t-a.t)/(b.t-a.t)
  return a.v + r*(b.v-a.v)
}
```

---

## 实战建议
- 时间基统一为秒（浮点）并在导出阶段转采样；对齐/吸附保留网格与微调。
- 轨道内保持 clips 有序且不重叠；跨轨冲突由混音规则处理。
- 命令模式记录编辑操作；重要操作前后做轻量快照，支持跨页恢复。

## 常见坑
- 漂移与精度问题导致对齐失真；未限制重叠导致播放/导出异常；撤销粒度过粗或内存爆。

## 总结
- 统一音轨模型核心在于“清晰的层次与约束 + 完整的编辑操作 + 稳健的序列化/导出路径”，才能支撑复杂音频编辑与后续生成。

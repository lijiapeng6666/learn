# 前端技术栈原理 - React与Vue面试题精选

## React篇

### 1. React的核心思想是什么？
**答案要点：**
- 组件化开发
- 单向数据流
- 虚拟DOM
- 声明式编程

### 2. 什么是JSX？它的本质是什么？
**答案要点：**
- JavaScript的语法扩展
- 允许在JavaScript中编写类似HTML的代码
- 本质上是React.createElement()函数的语法糖
- 通过Babel转译为JavaScript对象

### 3. React组件的生命周期有哪些？
**答案要点：**
- 挂载阶段：constructor、getDerivedStateFromProps、render、componentDidMount
- 更新阶段：getDerivedStateFromProps、shouldComponentUpdate、render、getSnapshotBeforeUpdate、componentDidUpdate
- 卸载阶段：componentWillUnmount
- 错误处理：getDerivedStateFromError、componentDidCatch

### 4. 函数组件与类组件的区别？
**答案要点：**
- 语法定义不同：函数组件是纯函数，类组件需要继承React.Component
- 状态管理：函数组件通过Hooks管理状态，类组件通过this.state和this.setState()
- 生命周期：函数组件通过useEffect等Hooks模拟，类组件有完整的生命周期方法
- 性能：函数组件更轻量，渲染性能通常更好

### 5. React Hooks的原理和常用Hook有哪些？
**答案要点：**
- 原理：基于闭包实现状态保存，通过调用顺序确定状态对应关系
- useState：状态管理
- useEffect：处理副作用
- useContext：获取上下文
- useReducer：复杂状态管理
- useMemo和useCallback：性能优化
- useRef：引用DOM或保存变量

### 6. 虚拟DOM的工作原理？
**答案要点：**
- 是JavaScript对象，描述真实DOM结构
- Diff算法：通过新旧虚拟DOM对比，找出需要更新的部分
- 批量更新：收集多次更新，一次性应用到真实DOM
- 跨平台：抽象了DOM操作，便于跨平台渲染

### 7. React中的状态管理方案有哪些？
**答案要点：**
- 组件内状态：useState、this.state
- 上下文：Context API
- 第三方库：Redux、MobX、Recoil、Zustand
- 服务端状态：React Query、SWR

### 8. React中的性能优化方法有哪些？
**答案要点：**
- React.memo缓存组件
- useMemo缓存计算结果
- useCallback缓存函数
- 懒加载：React.lazy和Suspense
- 虚拟列表处理大数据
- 合理使用key属性
- 避免不必要的重新渲染

### 9. React中的Fiber架构是什么？
**答案要点：**
- 重新实现的核心算法，React 16引入
- 可中断、可恢复的渲染过程
- 将渲染工作分解为小单元
- 优先级调度，提高用户交互响应性
- 双缓冲技术，保证渲染一致性

### 10. React中的Context API如何使用？
**答案要点：**
- 创建上下文：React.createContext()
- 提供上下文：Context.Provider
- 消费上下文：Context.Consumer或useContext
- 适用于跨组件共享状态
- 避免过度使用，可能导致组件复用性降低

### 11. React中的错误边界是什么？
**答案要点：**
- 捕获子组件树的JavaScript错误
- 记录错误并展示备用UI
- 通过实现getDerivedStateFromError或componentDidCatch方法
- 无法捕获事件处理器、异步代码、服务端渲染中的错误
- 只能在类组件中实现

### 12. React中的Portals是什么？
**答案要点：**
- 将子节点渲染到父组件DOM层次结构之外
- 适用于模态框、弹出菜单等场景
- 语法：ReactDOM.createPortal(child, container)
- 事件冒泡仍遵循React组件树，而非DOM树

### 13. React中的受控组件和非受控组件的区别？
**答案要点：**
- 受控组件：表单数据由React组件控制，通过props和state
- 非受控组件：表单数据由DOM自身处理，通过ref获取
- 受控组件更符合React数据流理念，但代码量较大
- 非受控组件代码简洁，但不易于数据验证和处理

### 14. React中的高阶组件(HOC)是什么？
**答案要点：**
- 接收组件作为参数并返回新组件的函数
- 用于复用组件逻辑
- 不修改原始组件，而是通过组合创建新组件
- 常见应用：权限控制、数据获取、状态共享

### 15. React中的Suspense和Lazy是什么？
**答案要点：**
- 用于处理代码分割和异步加载
- React.lazy：动态导入组件
- Suspense：在异步组件加载时显示fallback内容
- 可用于数据获取（实验性）
- 提升应用性能和用户体验

### 16. Redux的工作原理是什么？
**答案要点：**
- 单一数据源：整个应用的状态存储在单个store中
- 状态只读：只能通过触发action来修改状态
- 使用纯函数reducer进行状态修改
- 数据流：action → reducer → store → view
- 中间件处理副作用

### 17. React Router的工作原理是什么？
**答案要点：**
- 基于History API或hash实现前端路由
- 声明式路由配置
- 动态路由匹配
- 嵌套路由支持
- 路由守卫和权限控制

### 18. React中的事件机制是什么？
**答案要点：**
- 合成事件系统，非原生DOM事件
- 事件委托到document级别（React 16前）或root级别（React 17+）
- 跨浏览器一致性
- 异步执行，可通过e.persist()保留事件引用
- 与原生事件混用时需注意执行顺序

### 19. React中的Refs是什么？
**答案要点：**
- 访问DOM节点或React元素实例
- 创建方式：React.createRef()、useRef()、回调Refs
- 适用场景：管理焦点、触发动画、集成第三方DOM库
- 避免过度使用，破坏声明式编程范式

### 20. React中的状态更新为什么是异步的？
**答案要点：**
- 批处理多次更新，减少渲染次数
- 提高性能，避免不必要的计算
- 保证内部一致性，防止部分状态更新导致的问题
- 在事件处理函数外可能表现为同步（React 18前）
- React 18中的自动批处理使所有更新都为异步

## Vue篇

### 21. Vue的核心特性有哪些？
**答案要点：**
- 响应式数据绑定
- 组件化开发
- 指令系统
- 模板语法
- 虚拟DOM

### 22. Vue2和Vue3的区别有哪些？
**答案要点：**
- 响应式系统：Object.defineProperty vs Proxy
- API风格：选项式API vs 组合式API
- 性能提升：更小的包体积、更快的渲染
- TypeScript支持增强
- 新特性：Teleport、Fragments、Suspense

### 23. Vue的响应式原理是什么？
**答案要点：**
- Vue2：通过Object.defineProperty劫持对象属性的getter和setter
- Vue3：通过Proxy代理整个对象
- 依赖收集：在getter中收集依赖
- 派发更新：在setter中通知依赖更新
- 异步更新队列：多次修改合并为一次DOM更新

### 24. Vue的生命周期钩子有哪些？
**答案要点：**
- 创建阶段：beforeCreate、created
- 挂载阶段：beforeMount、mounted
- 更新阶段：beforeUpdate、updated
- 卸载阶段：beforeUnmount、unmounted
- 错误处理：errorCaptured
- 特殊钩子：activated、deactivated（keep-alive组件）

### 25. Vue中的计算属性和侦听器的区别？
**答案要点：**
- 计算属性：基于依赖进行缓存，依赖不变不会重新计算
- 侦听器：监听特定数据变化执行回调
- 计算属性适合依赖数据计算派生值
- 侦听器适合执行异步操作或开销较大的操作
- 计算属性必须有返回值，侦听器不需要

### 26. Vue中的组件通信方式有哪些？
**答案要点：**
- 父子组件：props/emit
- 祖先后代：provide/inject
- 任意组件：EventBus（Vue2）、Vuex/Pinia
- 兄弟组件：通过共同父组件或状态管理
- 组件实例引用：$refs、$parent、$children

### 27. Vue中的指令系统是什么？
**答案要点：**
- 内置指令：v-if、v-for、v-bind、v-on、v-model等
- 自定义指令：全局和局部注册
- 指令钩子函数：created、beforeMount、mounted等
- 指令参数和修饰符
- 动态指令参数

### 28. Vue中的插槽(slot)是什么？
**答案要点：**
- 内容分发机制，实现组件内容的可定制化
- 默认插槽：无名插槽
- 具名插槽：通过name属性区分
- 作用域插槽：向子组件传递数据
- v-slot指令（简写为#）

### 29. Vuex的工作原理是什么？
**答案要点：**
- 单一状态树：所有状态集中管理
- 核心概念：state、getters、mutations、actions、modules
- 严格模式：只能通过mutation修改状态
- 单向数据流：view → actions → mutations → state → view
- 模块化管理大型应用状态

### 30. Vue Router的导航守卫有哪些？
**答案要点：**
- 全局守卫：beforeEach、afterEach、beforeResolve
- 路由独享守卫：beforeEnter
- 组件内守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave
- 完整导航解析流程
- 应用场景：权限控制、数据预获取、跳转确认

### 31. Vue中的虚拟DOM是什么？
**答案要点：**
- JavaScript对象，描述真实DOM结构
- diff算法：同层比较，深度优先
- key属性的重要性
- 批量更新DOM，提高性能
- 跨平台渲染的基础

### 32. Vue3的组合式API(Composition API)是什么？
**答案要点：**
- 基于函数的API，提高代码复用性和组织性
- 核心函数：setup、ref、reactive、computed、watch
- 生命周期钩子：onMounted、onUpdated等
- 与选项式API的对比
- 逻辑复用：组合函数（composables）

### 33. Vue中的keep-alive是什么？
**答案要点：**
- 缓存组件实例，避免重新渲染
- include/exclude属性控制缓存组件
- max属性限制缓存组件数量
- activated和deactivated生命周期钩子
- 应用场景：标签页切换、列表/详情切换

### 34. Vue中的异步组件是什么？
**答案要点：**
- 按需加载组件，提高首屏加载速度
- Vue2：工厂函数返回Promise
- Vue3：defineAsyncComponent函数
- 加载状态处理：loading和error组件
- 与Suspense组件配合使用

### 35. Vue中的mixin和组合式函数的区别？
**答案要点：**
- mixin：选项合并，可能存在命名冲突
- 组合式函数：显式导入和使用，命名清晰
- mixin来源不明确，组合式函数来源可追踪
- mixin适用于Vue2，组合式函数适用于Vue3
- 组合式函数更灵活，可以接受参数

### 36. Vue中的渲染函数和JSX是什么？
**答案要点：**
- 渲染函数：使用JavaScript创建虚拟DOM
- JSX：JavaScript的语法扩展，需要配置babel
- 适用场景：复杂逻辑渲染、高度动态内容
- 与模板的对比：灵活性vs直观性
- h函数的使用方法

### 37. Pinia与Vuex的区别？
**答案要点：**
- 更简洁的API设计，无mutations概念
- 完全TypeScript支持
- 更好的开发体验：自动补全、类型推断
- 模块化设计，无需嵌套模块
- 轻量级，体积更小

### 38. Vue中的自定义事件是什么？
**答案要点：**
- 组件通信机制：子组件向父组件传递信息
- 事件定义：emits选项
- 事件触发：$emit方法
- 事件验证：类型和验证函数
- v-on指令（简写为@）监听事件

### 39. Vue的性能优化方法有哪些？
**答案要点：**
- 合理使用v-show和v-if
- 使用key管理可复用元素
- 使用keep-alive缓存组件
- 异步组件和路由懒加载
- 虚拟滚动处理大列表
- 函数式组件用于简单组件
- 避免不必要的组件更新

### 40. Vue中的SSR(服务端渲染)是什么？
**答案要点：**
- 在服务器生成HTML，发送到客户端
- 优势：更好的SEO、更快的首屏加载
- 实现方式：Nuxt.js、Vue SSR
- 同构应用：服务端和客户端共享代码
- 注意事项：避免副作用、特定生命周期钩子只在客户端执行

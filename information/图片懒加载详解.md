# 图片懒加载详解 - 原理 + 代码 + 记忆法

## 🎯 核心概念：一句话记住

**懒加载 = 延迟加载 = 只在用户看到时才加载图片**

```
普通加载：页面打开 → 所有图片都加载
懒加载：  页面打开 → 只加载可见区域的图片 → 用户滚动 → 新图片加载
```

---

## 📊 为什么需要懒加载？

| 问题 | 影响 |
|------|------|
| 页面有100张图片 | 没有懒加载全部加载，慢死 |
| 用户只看前5张图片 | 剩下95张图片的流量被浪费 |
| 首屏加载时间长 | 用户体验差，可能直接关闭 |

**懒加载的收益**：
- ✅ 首屏加载快 50-80%
- ✅ 节省带宽 30-60%
- ✅ 减少服务器压力

---

## 🏗️ 实现原理（3个步骤）

### 步骤1：识别"可见区域"

```
浏览器窗口
┌─────────────────────────┐
│  可见区域（viewport）    │  ← 用户能看到的部分
│                         │
└─────────────────────────┘
        ↓ 下拉
┌─────────────────────────┐
│  可见区域                 │
│  └─────────────────────┐ │
│    │  图片（隐藏）      │ │
│    │  需要加载          │ │
│    └─────────────────────┘ │
└─────────────────────────┘
```

### 步骤2：判断图片是否在可见区域

```javascript
// 核心判断逻辑
图片距离顶部的距离 <= 窗口高度 + 滚动距离
        ↓
如果为真 → 图片在视口内 → 加载它
```

### 步骤3：加载图片

```
<img data-src="real.jpg" src="placeholder.jpg">
           ↓
     真实图片地址
           ↓
   判断在可见区域内
           ↓
   src = data-src
           ↓
   浏览器加载真实图片
```

---

## 💡 3种实现方式（从简到难）

### 方式1：传统方式 - 监听滚动事件（了解即可）

```javascript
// ❌ 问题：频繁触发，性能差，不推荐
window.addEventListener('scroll', function() {
  images.forEach(img => {
    if (图片在可见区域) {
      img.src = img.dataset.src;
    }
  });
});
```

**记忆点**：滚动事件太频繁，就像一秒钟触发100次，会卡顿。

---

### 方式2：节流优化（有改进，但不是最佳）

```javascript
// 每隔200ms检查一次，而不是每次滚动都检查
let lastTime = 0;
window.addEventListener('scroll', function() {
  const now = Date.now();
  if (now - lastTime > 200) {
    checkImages();
    lastTime = now;
  }
});
```

**记忆点**：给滚动事件"加刹车"，减少检查次数。

---

### 方式3：Intersection Observer API（推荐！）

```javascript
// 创建一个观察器
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    // 如果图片进入视口
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      observer.unobserve(img); // 加载后停止观察
    }
  });
});

// 观察所有图片
document.querySelectorAll('img[data-src]').forEach(img => {
  observer.observe(img);
});
```

**为什么推荐？**
- ✅ 性能最好（浏览器原生支持，底层优化）
- ✅ 代码简洁
- ✅ 自动处理滚动事件

**记忆点**：IntersectionObserver = "十字路口观察者"，自动检测元素何时进入视口。

---

## 🎓 完整实现对比

### HTML部分（所有方式都一样）

```html
<!-- data-src 保存真实图片地址 -->
<!-- src 是占位图（小图或模糊图） -->
<img
  data-src="https://example.com/real-image.jpg"
  src="https://example.com/placeholder.jpg"
  alt="商品图"
>

<style>
  img {
    width: 200px;
    height: 200px;
    object-fit: cover;
  }
</style>
```

### 完整的Intersection Observer实现

```javascript
function lazyLoadImages() {
  // 配置选项
  const options = {
    root: null,           // 使用视口作为根
    rootMargin: '50px',   // 提前50px时开始加载（优化体验）
    threshold: 0.1        // 元素显示10%时触发
  };

  // 创建观察器
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;

        // 加载图片
        img.src = img.dataset.src;

        // 移除data-src属性（可选）
        img.removeAttribute('data-src');

        // 加载完成后停止观察
        observer.unobserve(img);

        // 可选：添加加载完成的类名
        img.classList.add('loaded');
      }
    });
  }, options);

  // 观察所有需要懒加载的图片
  document.querySelectorAll('img[data-src]').forEach(img => {
    observer.observe(img);
  });
}

// 页面加载完成后执行
document.addEventListener('DOMContentLoaded', lazyLoadImages);
```

### 配置选项详解

```
rootMargin: '50px'
    ↓
    用户看到图片前50px时，就开始加载
    ↓
    这样用户看到完整图片，避免加载延迟

threshold: 0.1
    ↓
    图片显示在视口10%时触发
    ↓
    越小越快加载，但越容易误触发
```

---

## 🔄 高级技巧

### 1. 加载失败重试

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      const src = img.dataset.src;

      // 创建临时图片测试
      const tempImg = new Image();
      tempImg.src = src;

      tempImg.onload = () => {
        img.src = src;
        observer.unobserve(img);
      };

      tempImg.onerror = () => {
        // 失败后3秒重试
        setTimeout(() => {
          observer.observe(img);
        }, 3000);
      };
    }
  });
});
```

### 2. 渐进式加载（模糊到清晰）

```html
<!-- 先加载小图（模糊），再加载大图（清晰） -->
<img
  src="https://example.com/tiny.jpg"              <!-- 占位图：1KB -->
  data-src="https://example.com/large.jpg"       <!-- 真实大图：500KB -->
  alt="商品"
>
```

```javascript
const img = entry.target;

// 先加载占位图
const placeholder = new Image();
placeholder.src = img.src;

// 异步加载真实大图
const realImg = new Image();
realImg.src = img.dataset.src;

realImg.onload = () => {
  img.src = realImg.src;
  img.classList.add('loaded');
};
```

### 3. 响应式图片加载

```html
<img
  data-src-mobile="https://example.com/mobile.jpg"
  data-src-desktop="https://example.com/desktop.jpg"
  src="placeholder.jpg"
  alt="商品"
>
```

```javascript
if (window.innerWidth < 768) {
  img.src = img.dataset.srcMobile;
} else {
  img.src = img.dataset.srcDesktop;
}
```

---

## 📝 记忆法总结

### 快速记忆（5个关键词）

| 关键词 | 含义 |
|--------|------|
| **延迟** | 不是立即加载 |
| **可见** | 只加载能看到的 |
| **data-src** | 存放真实地址 |
| **观察者** | IntersectionObserver自动检测 |
| **滚动** | 用户滚动时加载 |

### 图像理解

```
┌──────────────────────────┐
│  页面打开                 │
│  ✅ 可见的图片加载        │
│  ❌ 不可见的不加载        │
└──────────────────────────┘
         ↓ 用户滚动
┌──────────────────────────┐
│  新的可见区域            │
│  ✅ 新加载的图片加载      │
│  之前的图片保持不变      │
└──────────────────────────┘
```

---

## 🧪 面试常见问题

### Q1: 懒加载和预加载的区别？

```
懒加载：需要时才加载（节省资源）
预加载：提前加载（优化体验）

举例：
- 电商首页用懒加载（用户可能不往下滑）
- 相册APP用预加载（用户一定会看下一张）
```

### Q2: 如何处理图片加载失败？

```javascript
// 方案1：使用备用图片
img.onerror = () => {
  img.src = 'fallback.jpg';
};

// 方案2：显示加载失败提示
img.onerror = () => {
  img.style.display = 'none';
  img.parentNode.textContent = '图片加载失败';
};
```

### Q3: 如何测试懒加载是否生效？

```javascript
// 在控制台运行
const images = document.querySelectorAll('img[data-src]');
console.log('待加载图片数:', images.length);

// 滚动后再检查
images.forEach(img => {
  console.log(img.src === img.dataset.src ? '已加载' : '未加载');
});
```

### Q4: SEO会受影响吗？

```
❌ 问题：搜索引擎爬虫不会滚动，看不到懒加载的图片
✅ 解决：
1. 为img标签保留src属性（占位图）
2. 在<noscript>标签中放真实图片
3. 或者用data-src + 预加载关键图片

<noscript>
  <img src="real-image.jpg" alt="描述">
</noscript>
```

---

## 🚀 性能数据参考

```
优化前（加载100张图片）
├─ 首屏加载时间：5.2s
├─ 总体积：15MB
└─ 初始化内存：180MB

优化后（懒加载）
├─ 首屏加载时间：1.8s （快66%）
├─ 初始化数据量：2.5MB （省83%）
└─ 初始化内存：45MB （省75%）
```

---

## 📚 学习路径

```
1️⃣ 理解原理（5分钟）
   ↓
2️⃣ 手写代码（15分钟）
   → 从IntersectionObserver开始
   ↓
3️⃣ 实际项目中使用（30分钟）
   → 找一个有图片的页面改造
   ↓
4️⃣ 性能对比验证（10分钟）
   → DevTools -> Lighthouse
   ↓
5️⃣ 优化和扩展（持续）
   → 加入加载失败处理
   → 加入进度条显示
```

---

## 💻 完整工作示例

```html
<!DOCTYPE html>
<html>
<head>
  <style>
    .image-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      padding: 20px;
    }

    img {
      width: 100%;
      height: 300px;
      object-fit: cover;
      background: #f0f0f0;
      transition: opacity 0.3s;
    }

    img.loaded {
      animation: fadeIn 0.3s;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
  </style>
</head>
<body>

<div class="image-grid">
  <!-- 占位图：tiny.jpg (1KB) -->
  <!-- 真实图：large.jpg (500KB) -->
  <img src="tiny.jpg" data-src="large.jpg" alt="图片1">
  <img src="tiny.jpg" data-src="large.jpg" alt="图片2">
  <img src="tiny.jpg" data-src="large.jpg" alt="图片3">
  <!-- ... 更多图片 ... -->
</div>

<script>
function initLazyLoad() {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        img.classList.add('loaded');
        observer.unobserve(img);
      }
    });
  }, {
    rootMargin: '50px',
    threshold: 0.1
  });

  document.querySelectorAll('img[data-src]').forEach(img => {
    observer.observe(img);
  });
}

document.addEventListener('DOMContentLoaded', initLazyLoad);
</script>

</body>
</html>
```

---

## ✅ 面试回答模板

> "图片懒加载是一种性能优化技术，核心思想是**延迟加载图片，只在用户看到时才加载**。
>
> **原理**：通过 IntersectionObserver API 监测图片是否进入视口，进入视口后才设置真实的 src 地址。
>
> **优势**：
> - 首屏加载速度快 50-80%
> - 节省带宽 30-60%
> - 改善用户体验
>
> **实现**：使用 data-src 存放真实地址，再用 IntersectionObserver 观察，当图片进入视口时将 data-src 赋值到 src。"

---

**建议**：背会这个文档的"核心概念"和"3种实现方式"就够面试了！其他作为扩展知识。

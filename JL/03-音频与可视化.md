# 音频与可视化：Web Audio/WaveSurfer 扩展与视频加载优化

## 背景与目标
- 业务包含配音、语音克隆、翻译等音视频能力，需要可交互的波形编辑与稳定的播放体验；视频首帧与加载也要尽量稳定。

## 方案与实现
- 波形渲染与交互
  - 在自研的 WaveSurfer 封装中扩展时间轴/缩放/选区等插件（`src/src/utils/SoundwaveDiagram/*`）。
  - 以 Web Audio 解码、Canvas 渲染，支持 minPxPerSec 缩放、区域选择与 redraw 事件；提供 `renderer.setRegion` 等编程接口。
- 播放器统一
  - 使用 Howler 作为统一音频播放器，封装加载/播放/错误回调，驱动 UI 状态（`src/src/hooks/useAudioPlayer.ts`）。
- 音频工具化
  - 时长探测：URL 级与数据级两种方式（`src/src/utils/audioUtils.ts`）。
  - 图片合成与比例计算：双图合成、cover/contain 绘制、比例探测（`src/src/utils/imageProcess.ts`）。
- 视频加载状态优化
  - 引入 LRU 级别的视频加载状态缓存，标记 `isLoaded/loadTime/error`，定期过期清理与命中统计，减少重复等待（`src/src/utils/videoCache.ts`）。

## 成果（口径）
- 波形编辑稳定且可扩展：可在 LipSync/配音等场景复用同一套时间轴与选区交互。
- 播放体验一致：Howler 统一播放/错误处理，避免多套播放器行为不一致。
- 视频命中率提升：相同视频切换/进出视图时不必重复等待首帧，降低等待时间（建议补齐命中率与平均加载时间数据）。

## 常见追问与回答建议
- Q：为何自研 WaveSurfer 扩展而不是直接用现成库？
  - A：需要更细粒度的渲染/交互控制，与现有业务状态（如选区、缩放、时间轴刻度）耦合；同时避免体积和不必要依赖。
- Q：LRU 缓存的淘汰策略？
  - A：基于 `lastAccessed` 的 LRU，超过 `maxAge` 清理；达到 `maxSize` 驱逐最久未访问项；支持统计命中率。
- Q：音频时长的准确性如何保证？
  - A：优先 `loadedmetadata` 获取精确时长；数据级解析作为后备，避免跨域或 metadata 丢失导致的异常。

## 代码证据点
- WaveSurfer 扩展：`src/src/utils/SoundwaveDiagram/*`
- 播放器封装：`src/src/hooks/useAudioPlayer.ts`
- 工具函数：`src/src/utils/audioUtils.ts`, `src/src/utils/imageProcess.ts`
- 视频缓存：`src/src/utils/videoCache.ts`

